<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Dependent Pair Types</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="dependent-pair-types">
<h1 class="title">Dependent Pair Types</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/51053375">https://stackoverflow.com/q/51053375</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>In software foundations, <a class="reference external" href="http://www.seas.upenn.edu/~cis500/current/sf/lf-current/Logic.HTML">Logic in Coq</a>,
we are introduced to parametrized propositions:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">is_three</span> (<span class="nv">n</span> : nat) : <span class="kt">Prop</span> :=
  n = <span class="mi">3</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="dependent-pair-types-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="dependent-pair-types-v-chk0"><span class="kn">Check</span> is_three.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">is_three
     : nat -&gt; <span class="kt">Prop</span></blockquote></div></div></small></span></pre><p>which reminds me of dependent pair types, which from <a class="reference external" href="https://mdnahas.github.io/doc/Reading_HoTT_in_Coq.pdf">Reading HoTT in
Coq</a> we have
dependent pair types to be defined:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">sigT</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) : <span class="kt">Type</span> :=
  existT : <span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; sigT P.</span></span></pre><p>Can someone explain how are they different and also in Reading HoTT in
Coq, it says &quot;Since we haven't defined propositional equality, we
can't do much that is interesting here&quot;, why can't we do anything
interesting without propositional equality?</p>
</section>
<section id="answer">
<h2>Answer</h2>
<p>Let us pretend for now that the HoTT code uses <span class="docutils literal">A <span class="pre">-&gt;</span> Prop</span> instead
of <span class="docutils literal">A <span class="pre">-&gt;</span> Type</span>; the difference between the two is orthogonal to your
question.</p>
<p>A parametrized proposition <span class="docutils literal">P : A <span class="pre">-&gt;</span> Prop</span> is simply property of
elements of the type <span class="docutils literal">A</span>. Besides the simple <span class="docutils literal">is_three</span>
proposition above, we can express more complex properties of natural
numbers in this fashion. For instance:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">even</span> (<span class="nv">n</span> : nat) : <span class="kt">Prop</span> :=
  <span class="kr">exists</span> <span class="nv">p</span>, n = <span class="mi">2</span> * p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">prime</span> (<span class="nv">n</span> : nat) : <span class="kt">Prop</span> :=
  n &gt;= <span class="mi">2</span> /\
  <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span>, n = p * q -&gt; p = n \/ p = <span class="mi">1</span>.</span></span></pre><p>The type <span class="docutils literal">sigT A P</span> type allows us to restrict the type <span class="docutils literal">A</span> to
elements that satisfy the property <span class="docutils literal">P</span>. For instance, <span class="docutils literal">sigT nat even</span> is the type of all even numbers, <span class="docutils literal">sigT nat prime</span> is the type
of all prime numbers, etc. In Coq, properties are the more primitive
concept, and subset types like <span class="docutils literal">sigT</span> are a derived concept.</p>
<p>In traditional mathematics, the concepts of property and subset can
almost be conflated: saying that 2 is a prime number is equivalent to
saying that it belongs to the set of all prime numbers. In Coq's type
theory, this is not quite the case, because being an element of a type
is not a proposition: you cannot, for instance, state a theorem saying
that 2 is an element of <span class="docutils literal">sigT nat prime</span>. The following snippet
throws an error:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="dependent-pair-types-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="dependent-pair-types-v-chk1"><span class="kn">Lemma</span> <span class="nf">bogus</span> : (<span class="mi">2</span> : {x : nat &amp; prime x}).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The term <span class="s2">&quot;2&quot;</span> has type <span class="s2">&quot;nat&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type
 <span class="s2">&quot;{x : nat &amp; prime x}&quot;</span>.</blockquote></div></div></small></span></pre><p>(The <span class="docutils literal">{ ... &amp; ... }</span> is syntactic sugar for the <span class="docutils literal">sigT</span> type
defined in Coq's standard library.)</p>
<p>The closest we can get is to say that 2 can be extracted from that
type:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="dependent-pair-types-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="dependent-pair-types-v-chk2"><span class="kn">Lemma</span> <span class="nf">fixed</span> : <span class="kr">exists</span> <span class="nv">x</span> : {x : nat &amp; prime x}, <span class="mi">2</span> = projT1 x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">x</span> : {x : nat &amp; prime x}, <span class="mi">2</span> = projT1 x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>where <span class="docutils literal">projT1</span> is the function that extracts the first component of
the dependent pair. However, this is much more cumbersome than simply
stating that 2 is prime:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="dependent-pair-types-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="dependent-pair-types-v-chk3"><span class="kn">Lemma</span> <span class="nf">prime_two</span> : prime <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">prime <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>In general, parametrized propositions are more useful in Coq, but
there are cases where <span class="docutils literal">sigT</span> type comes in handy; for instance, when
we only care about the elements of a type that satisfy a certain
property. Imagine that you implement a associative map in Coq using a
type of binary search trees. You might begin by defining a type
<span class="docutils literal">tree</span> of <em>arbitrary</em> trees:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">tree</span> :=
| Leaf : tree
| Node : tree -&gt; nat -&gt; nat -&gt; tree -&gt; tree.</span></span></pre><p>This type defines a binary tree whose nodes store a key-value pair of
natural numbers. To implement functions for looking up an element,
updating a value, etc., using this type, we might maintain the
invariant that the keys of the tree are sorted (that is, that the keys
on the left subtree are less than the keys of a node, and the opposite
for the right subtree). Since users of this tree will not want to
consider trees that do not satisfy this invariant, we might use
instead the type <span class="docutils literal">sigT tree well_formed</span>, where <span class="docutils literal">well_formed : tree <span class="pre">-&gt;</span> Prop</span> expresses the above invariant. The main advantage is that
this simplifies the interface of our library: instead of having a
separate lemma saying that the insertion function preserves the
invariant, this would be automatically expressed in the type of the
insertion function itself; users wouldn't even need to bother arguing
that the trees that they construct using the interface respect the
invariant.</p>
<p>As for your second question, equality is so fundamental that it is
hard to define interesting properties without it. For instance, the
properties <span class="docutils literal">even</span> and <span class="docutils literal">prime</span> above are both defined using
equality.</p>
</section>
</div>
</main>
</div></body>
</html>
