<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>Proving decidability for a datatype that includes a vector</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="proving-decidability-for-a-datatype-that-includes-a-vector">
<h1 class="title">Proving decidability for a datatype that includes a vector</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/55335098">https://stackoverflow.com/q/55335098</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>I'm trying to work with a datatype that represents expressions in a
sort of universal algebra context. The usual way to express this in
(pen and paper) maths is that you have a set of function symbols, F,
together with an arity function. An expression is a tree where each
node is labelled with a function symbol and it has as many children as
its arity. In this particular example, I've also got a set of atomic
variables that get injected explicitly as terms.</p>
<p>It's pretty clear how to write this down with Coq (I've got a snippet
of code at the bottom), but I'd like to prove some sort of
decidability result. I've managed to prove decidability for vectors
(&quot;If I have decidability on A, then I can get decidability on
VectorDef.t A n&quot;), but I can't work out how to do the same for my tree
type.</p>
<p>I tried doing an explicit recursion over the structure of a tree, but
I ended up needing to call out to my &quot;decidable vector&quot; function,
which doesn't get past the termination checker. This is reasonable,
since the vector function expects to be given a discriminator for
arbitrary elements of its underlying type and this obviously doesn't
bottom out!</p>
<p>I can't work out how to tell Coq that (by induction) I have
decidability for some terms, and these are the only terms that appear
in the vectors in question. Is there a standard trick for doing this
sort of thing?</p>
<p>Below, the data types in question:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require</span> Vectors.VectorDef.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">vec</span> := VectorDef.t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">VTree</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* If it helps, I have a definition for this function *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">dec_vec</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
    (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}) -&gt;
    <span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">v</span> <span class="nv">v&#39;</span> : vec A n), {v = v&#39;} + {v &lt;&gt; v&#39;}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">V</span> : <span class="kt">Set</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">F</span> : <span class="kt">Set</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">a</span> : F -&gt; nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">VTree</span> : <span class="kt">Type</span> :=
  | varTerm : V -&gt; VTree
  | funTerm (f : F) (ts : vec VTree (a f)) : VTree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">DecVTree</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hypothesis</span> <span class="nv">decV</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hypothesis</span> <span class="nv">decF</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk0"><span class="kn">Definition</span> <span class="nf">decVTree</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>dec_vec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}) -&gt;
<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">v</span> <span class="nv">v&#39;</span> : vec A n),
{v = v&#39;} + {v &lt;&gt; v&#39;}</span></span></span><br><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* ??? *)</span>
</span></pre></div>
<div class="section" id="answer-li-yao-xia">
<h1>Answer (Li-yao Xia)</h1>
<p>There are two challenging aspects to this problem.</p>
<ol class="arabic simple">
<li>Dependently typed programming with indexed types in Coq</li>
<li>Nested recursive types</li>
</ol>
<div class="section" id="dependently-typed-programming-with-indexed-types-in-coq">
<h2>Dependently typed programming with indexed types in Coq</h2>
<p>By &quot;indexed type&quot; I am referring here specifically to inductive types
like <tt class="docutils literal">Vector.t</tt>, where the constructors refine some of the type
arguments. These arguments are called indices, and must appear between
<tt class="docutils literal">:</tt> and <tt class="docutils literal">:=</tt> in the type signature:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Vector</span> (<span class="nv">A</span> : <span class="kt">Type</span>) : nat <span class="c">(* &lt;- index *)</span> -&gt; <span class="kt">Type</span> :=
| nil : Vector A <span class="mi">0</span>
| cons : A -&gt; <span class="kr">forall</span> <span class="nv">n</span>, Vector A n -&gt; Vector A (S n).</span></span></pre><p>Indexed inductive types are very useful to define propositions, where
the terms don't matter. But for actual data, the short story here is:
don't do it. It's technically possible, but it's a very deep rabbit
hole, and overall quite a pain to work with, in large part because
dependent pattern-matching in Coq is such an unintuitive construct.
For example, see this blogpost:
<a class="reference external" href="https://homes.cs.washington.edu/~jrw12/dep-destruct.html">https://homes.cs.washington.edu/~jrw12/dep-destruct.html</a></p>
<p>A less extreme solution is to give up on other &quot;dependently-typed&quot;
aspects of this program. The next candidate on the chopping block here
is <tt class="docutils literal">sumbool ({ _ } + { _ })</tt>. If the functions (and parameters)
return bool instead, this makes them reasonably easy to define (<em>cough</em>, see next section). Proving their correctness is still a
problem but at least you have something to compute with.</p>
<p>Two general alternatives to inductive indexed types are:</p>
<ul>
<li><p class="first">Just use the flat version (<tt class="docutils literal">list</tt> instead of <tt class="docutils literal">vec</tt>), giving up
some &quot;by construction&quot; guarantees.</p>
</li>
<li><p class="first">Make the type a function of the indices as a <tt class="docutils literal">Definition</tt> (or
<tt class="docutils literal">Fixpoint</tt>), instead of <tt class="docutils literal">Inductive</tt>. Here we use <tt class="docutils literal">unit</tt> and
<tt class="docutils literal">prod</tt> as building blocks for such types, but you may have to make
up your own for more elaborate types. A lot of dependent
pattern-matching will be necessary.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">vec</span> (<span class="nv">A</span> : <span class="kt">Set</span>) (<span class="nv">n</span> : nat) :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | O =&gt; unit | S n =&gt; (A * vec A n)%type
  <span class="kr">end</span>.</span></span></pre></li>
</ul>
<p>You might also want to reconsider the representation of the language
you want to implement. For example, do you really want to represent
arities as explicitly as a function on symbols? (That could certainly
be the case.) For example, could you not restrict this to symbols of
arities 0, 1, 2?</p>
</div>
<div class="section" id="nested-recursive-types">
<h2>Nested recursive types</h2>
<p>These are recursive types whose recursive occurrences are inside other
data types (which may be recursive). To simplify the discussion, to
unclutter the code, and because of the aforementioned issues with
dependent types in Coq, consider the following type using <tt class="docutils literal">list</tt>
instead of <tt class="docutils literal">vec</tt> and with one fewer constructor:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">LTree</span> : <span class="kt">Type</span> :=
| funTerm : list LTree -&gt; LTree.</span></span></pre><p>You can define recursive functions on such a type with <tt class="docutils literal">Fixpoint</tt>,
but you have to be particularly careful about how recursive calls are
nested. Of course, this actually matters with any recursive type, but
the pattern is much more natural when the recursion is not nested, so
the problem is less noticeable.</p>
<p>Below is how we can decide equality for <tt class="docutils literal">LTree</tt>. We give up the
dependent <tt class="docutils literal">sumbool</tt>, returning a <tt class="docutils literal">bool</tt> instead. The definition of
<tt class="docutils literal">dec_list</tt> is standard and generic.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">List</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">decA</span> : A -&gt; A -&gt; bool).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">dec_list</span> (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A) : bool :=
  <span class="kr">match</span> l, l&#39; <span class="kr">with</span>
  | [], [] =&gt; true
  | a :: l0, a&#39; :: l0&#39; =&gt;
    decA a a&#39; &amp;&amp; dec_list l0 l0&#39;
  | _, _ =&gt; false
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">List</span>.</span></span></pre><p>Then equality of <tt class="docutils literal">LTree</tt> looks innocent...</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">decLTree</span> (<span class="nv">x</span> <span class="nv">y</span> : LTree) : bool :=
  <span class="kr">match</span> x, y <span class="kr">with</span>
  | funTerm lx, funTerm ly =&gt;
    dec_list decLTree lx ly
  <span class="kr">end</span>.</span></span></pre><p>... but there are very subtle details that one needs to be aware of to convince Coq that the recursion is structurally decreasing.</p>
<p>The well-formedness of <tt class="docutils literal">decLTree</tt> specifically depends in a very
delicate way on how <tt class="docutils literal">dec_list</tt> uses its argument <tt class="docutils literal">decA</tt>, so
<tt class="docutils literal">dec_list</tt> must be a transparent definition:</p>
<ol class="arabic simple">
<li>It is only being applied to a subterm of the first list (you could
make it the second if you want, with some <tt class="docutils literal">struct</tt> annotations).</li>
<li><tt class="docutils literal">decA</tt> is bound <em>outside</em> of <tt class="docutils literal">Fixpoint dec_list</tt>. The function
<tt class="docutils literal">decLTree</tt> would not be well-formed if that line instead read
<tt class="docutils literal">Fixpoint dec_list {A : Type} (decA : A <span class="pre">-&gt;</span> A <span class="pre">-&gt;</span> bool)</tt>.</li>
</ol>
<p>It's also possible to package these tricks up by writing some general
recursion/induction schemes for <tt class="docutils literal">LTree</tt>/<tt class="docutils literal">VTree</tt>.</p>
</div>
</div>
<div class="section" id="answer-rupert-swarbrick">
<h1>Answer (Rupert Swarbrick)</h1>
<p>While Li-yao made some useful points, the dependent types aren't that
bad! It turns out that the reason my previous script didn't work is
that I'd used <tt class="docutils literal">Qed</tt> rather than <tt class="docutils literal">Defined</tt> to finish my
decidability proof for vectors.</p>
<p>Here's a complete working proof:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require</span> Vectors.VectorDef.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Logic.Eqdep_dec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> PeanoNat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">vec</span> := VectorDef.t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">dec_vec</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">A</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hypothesis</span> <span class="nv">decA</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk1"><span class="kn">Definition</span> <span class="nf">dec_vec</span> {<span class="nv">n</span>} (<span class="nv">v</span> <span class="nv">v&#39;</span> : vec A n) : {v = v&#39;} + {v &lt;&gt; v&#39;}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{v = v&#39;} + {v &lt;&gt; v&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk2"><span class="nb">refine</span> (VectorDef.rect2 (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; {x = y} + {x &lt;&gt; y})
                            (<span class="nb">left</span> (eq_refl))
                            (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">v</span> <span class="nv">v&#39;</span> <span class="nv">veq</span> <span class="nv">a</span> <span class="nv">a&#39;</span> =&gt; _)
                            v v&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>veq</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> <span class="nv">y</span> : VectorDef.t A n) =&gt;
 {x = y} + {x &lt;&gt; y}) n v v&#39;</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{VectorDef.cons A a n v = VectorDef.cons A a&#39; n v&#39;} +
{VectorDef.cons A a n v &lt;&gt; VectorDef.cons A a&#39; n v&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>veq</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> <span class="nv">y</span> : VectorDef.t A n) =&gt;
 {x = y} + {x &lt;&gt; y}) n v v&#39;</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{VectorDef.cons A a n v = VectorDef.cons A a&#39; n v&#39;} +
{VectorDef.cons A a n v &lt;&gt; VectorDef.cons A a&#39; n v&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk4"><span class="nb">destruct</span> (decA a a&#39;) <span class="kr">as</span> [ eqaH | neaH ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>veq</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> <span class="nv">y</span> : VectorDef.t A n) =&gt;
 {x = y} + {x &lt;&gt; y}) n v v&#39;</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>eqaH</var><span class="hyp-type"><b>: </b><span>a = a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{VectorDef.cons A a n v = VectorDef.cons A a&#39; n v&#39;} +
{VectorDef.cons A a n v &lt;&gt; VectorDef.cons A a&#39; n v&#39;}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>veq</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> <span class="nv">y</span> : VectorDef.t A n) =&gt;
 {x = y} + {x &lt;&gt; y}) n v v&#39;</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>neaH</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; a&#39;</span></span></span><br></div><label class="goal-separator" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk5"><hr></label><div class="goal-conclusion">{VectorDef.cons A a n v = VectorDef.cons A a&#39; n v&#39;} +
{VectorDef.cons A a n v &lt;&gt; VectorDef.cons A a&#39; n v&#39;}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk6">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>veq</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> <span class="nv">y</span> : VectorDef.t A n) =&gt;
 {x = y} + {x &lt;&gt; y}) n v v&#39;</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>eqaH</var><span class="hyp-type"><b>: </b><span>a = a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{VectorDef.cons A a n v = VectorDef.cons A a&#39; n v&#39;} +
{VectorDef.cons A a n v &lt;&gt; VectorDef.cons A a&#39; n v&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk7"><span class="nb">rewrite</span> &lt;- eqaH; <span class="nb">clear</span> eqaH a&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>veq</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> <span class="nv">y</span> : VectorDef.t A n) =&gt;
 {x = y} + {x &lt;&gt; y}) n v v&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{VectorDef.cons A a n v = VectorDef.cons A a n v&#39;} +
{VectorDef.cons A a n v &lt;&gt; VectorDef.cons A a n v&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk8"><span class="nb">destruct</span> veq <span class="kr">as</span> [ eqvH | nevH ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>eqvH</var><span class="hyp-type"><b>: </b><span>v = v&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{VectorDef.cons A a n v = VectorDef.cons A a n v&#39;} +
{VectorDef.cons A a n v &lt;&gt; VectorDef.cons A a n v&#39;}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>nevH</var><span class="hyp-type"><b>: </b><span>v &lt;&gt; v&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk9"><hr></label><div class="goal-conclusion">{VectorDef.cons A a n v = VectorDef.cons A a n v&#39;} +
{VectorDef.cons A a n v &lt;&gt; VectorDef.cons A a n v&#39;}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chka">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>eqvH</var><span class="hyp-type"><b>: </b><span>v = v&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{VectorDef.cons A a n v = VectorDef.cons A a n v&#39;} +
{VectorDef.cons A a n v &lt;&gt; VectorDef.cons A a n v&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chkb"><span class="nb">rewrite</span> &lt;- eqvH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>eqvH</var><span class="hyp-type"><b>: </b><span>v = v&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{VectorDef.cons A a n v = VectorDef.cons A a n v} +
{VectorDef.cons A a n v &lt;&gt; VectorDef.cons A a n v}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chkc"><span class="nb">apply</span> <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>eqvH</var><span class="hyp-type"><b>: </b><span>v = v&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">VectorDef.cons A a n v = VectorDef.cons A a n v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> eq_refl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chkd">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>nevH</var><span class="hyp-type"><b>: </b><span>v &lt;&gt; v&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{VectorDef.cons A a n v = VectorDef.cons A a n v&#39;} +
{VectorDef.cons A a n v &lt;&gt; VectorDef.cons A a n v&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chke"><span class="nb">apply</span> <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>nevH</var><span class="hyp-type"><b>: </b><span>v &lt;&gt; v&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">VectorDef.cons A a n v &lt;&gt; VectorDef.cons A a n v&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chkf"><span class="nb">intro</span> consH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>nevH</var><span class="hyp-type"><b>: </b><span>v &lt;&gt; v&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>consH</var><span class="hyp-type"><b>: </b><span>VectorDef.cons A a n v =
VectorDef.cons A a n v&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk10"><span class="nb">inversion</span> consH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>nevH</var><span class="hyp-type"><b>: </b><span>v &lt;&gt; v&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>consH</var><span class="hyp-type"><b>: </b><span>VectorDef.cons A a n v =
VectorDef.cons A a n v&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>existT (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; VectorDef.t A n) n v =
existT (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; VectorDef.t A n) n v&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (nevH (inj_pair2_eq_dec nat Nat.eq_dec (vec A) n v v&#39; H0)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk11">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>veq</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> <span class="nv">y</span> : VectorDef.t A n) =&gt;
 {x = y} + {x &lt;&gt; y}) n v v&#39;</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>neaH</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{VectorDef.cons A a n v = VectorDef.cons A a&#39; n v&#39;} +
{VectorDef.cons A a n v &lt;&gt; VectorDef.cons A a&#39; n v&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk12"><span class="nb">apply</span> <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>veq</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> <span class="nv">y</span> : VectorDef.t A n) =&gt;
 {x = y} + {x &lt;&gt; y}) n v v&#39;</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>neaH</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">VectorDef.cons A a n v &lt;&gt; VectorDef.cons A a&#39; n v&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk13"><span class="nb">intro</span> consH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>veq</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> <span class="nv">y</span> : VectorDef.t A n) =&gt;
 {x = y} + {x &lt;&gt; y}) n v v&#39;</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>neaH</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; a&#39;</span></span></span><br><span><var>consH</var><span class="hyp-type"><b>: </b><span>VectorDef.cons A a n v =
VectorDef.cons A a&#39; n v&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk14"><span class="nb">inversion</span> consH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>decA</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v0, v'0</var><span class="hyp-type"><b>: </b><span>vec A n0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>VectorDef.t A n</span></span></span><br><span><var>veq</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> <span class="nv">y</span> : VectorDef.t A n) =&gt;
 {x = y} + {x &lt;&gt; y}) n v v&#39;</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>neaH</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; a&#39;</span></span></span><br><span><var>consH</var><span class="hyp-type"><b>: </b><span>VectorDef.cons A a n v =
VectorDef.cons A a&#39; n v&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a = a&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>existT (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; VectorDef.t A n) n v =
existT (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; VectorDef.t A n) n v&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">contradiction</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">dec_vec</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">VTree</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">V</span> : <span class="kt">Set</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">F</span> : <span class="kt">Set</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">a</span> : F -&gt; nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">VTree</span> : <span class="kt">Type</span> :=
  | varTerm : V -&gt; VTree
  | funTerm (f : F) (ts : vec VTree (a f)) : VTree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">DecVTree</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hypothesis</span> <span class="nv">decV</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hypothesis</span> <span class="nv">decF</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk15"><span class="kn">Lemma</span> <span class="nf">varTerm_ne_funTerm</span> <span class="nv">v</span> <span class="nv">f</span> <span class="nv">ts</span> : varTerm v &lt;&gt; funTerm f ts.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">varTerm v &lt;&gt; funTerm f ts</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">varTerm v &lt;&gt; funTerm f ts</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk17"><span class="nb">intros</span> eqH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>eqH</var><span class="hyp-type"><b>: </b><span>varTerm v = funTerm f ts</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> eqH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk18"><span class="kn">Fixpoint</span> <span class="nf">decVTree</span> (<span class="nv">x</span> <span class="nv">y</span> : VTree) : {x = y} + {x &lt;&gt; y}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x = y} + {x &lt;&gt; y}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk19"><span class="nb">refine</span> (<span class="kr">match</span> x, y <span class="kr">with</span>
              | varTerm v, varTerm v&#39; =&gt; _
              | varTerm v, funTerm f ts =&gt; _
              | funTerm f ts, varTerm v =&gt; _
              | funTerm f ts, funTerm f&#39; ts&#39; =&gt; _
              <span class="kr">end</span>
             ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{varTerm v = varTerm v&#39;} + {varTerm v &lt;&gt; varTerm v&#39;}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk1a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br></div><label class="goal-separator" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk1a"><hr></label><div class="goal-conclusion">{varTerm v = funTerm f ts} +
{varTerm v &lt;&gt; funTerm f ts}</div></blockquote><input class="alectryon-extra-goal-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk1b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br></div><label class="goal-separator" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk1b"><hr></label><div class="goal-conclusion">{funTerm f ts = varTerm v} +
{funTerm f ts &lt;&gt; varTerm v}</div></blockquote><input class="alectryon-extra-goal-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>vec VTree (a f&#39;)</span></span></span><br></div><label class="goal-separator" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk1c"><hr></label><div class="goal-conclusion">{funTerm f ts = funTerm f&#39; ts&#39;} +
{funTerm f ts &lt;&gt; funTerm f&#39; ts&#39;}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk1d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{varTerm v = varTerm v&#39;} + {varTerm v &lt;&gt; varTerm v&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk1e"><span class="nb">destruct</span> (decV v v&#39;) <span class="kr">as</span> [ eqH | neH ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br><span><var>eqH</var><span class="hyp-type"><b>: </b><span>v = v&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{varTerm v = varTerm v&#39;} + {varTerm v &lt;&gt; varTerm v&#39;}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk1f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br><span><var>neH</var><span class="hyp-type"><b>: </b><span>v &lt;&gt; v&#39;</span></span></span><br></div><label class="goal-separator" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk1f"><hr></label><div class="goal-conclusion">{varTerm v = varTerm v&#39;} + {varTerm v &lt;&gt; varTerm v&#39;}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk20">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br><span><var>eqH</var><span class="hyp-type"><b>: </b><span>v = v&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{varTerm v = varTerm v&#39;} + {varTerm v &lt;&gt; varTerm v&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="nb">left</span> (<span class="nb">f_equal</span> varTerm eqH)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk21">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br><span><var>neH</var><span class="hyp-type"><b>: </b><span>v &lt;&gt; v&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{varTerm v = varTerm v&#39;} + {varTerm v &lt;&gt; varTerm v&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk22"><span class="nb">enough</span> (H: varTerm v &lt;&gt; varTerm v&#39;);
            <span class="kp">try</span> (<span class="bp">exact</span> (<span class="nb">right</span> H)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>v, v'</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br><span><var>neH</var><span class="hyp-type"><b>: </b><span>v &lt;&gt; v&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">varTerm v &lt;&gt; varTerm v&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">injection</span>; <span class="bp">tauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk23">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{varTerm v = funTerm f ts} +
{varTerm v &lt;&gt; funTerm f ts}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="nb">right</span> (varTerm_ne_funTerm v f ts)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk24">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{funTerm f ts = varTerm v} +
{funTerm f ts &lt;&gt; varTerm v}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="nb">right</span> (not_eq_sym (varTerm_ne_funTerm v f ts))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk25">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>vec VTree (a f&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{funTerm f ts = funTerm f&#39; ts&#39;} +
{funTerm f ts &lt;&gt; funTerm f&#39; ts&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk26"><span class="nb">destruct</span> (decF f f&#39;) <span class="kr">as</span> [ feqH | fneH ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>vec VTree (a f&#39;)</span></span></span><br><span><var>feqH</var><span class="hyp-type"><b>: </b><span>f = f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{funTerm f ts = funTerm f&#39; ts&#39;} +
{funTerm f ts &lt;&gt; funTerm f&#39; ts&#39;}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk27" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>vec VTree (a f&#39;)</span></span></span><br><span><var>fneH</var><span class="hyp-type"><b>: </b><span>f &lt;&gt; f&#39;</span></span></span><br></div><label class="goal-separator" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk27"><hr></label><div class="goal-conclusion">{funTerm f ts = funTerm f&#39; ts&#39;} +
{funTerm f ts &lt;&gt; funTerm f&#39; ts&#39;}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk28">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>vec VTree (a f&#39;)</span></span></span><br><span><var>feqH</var><span class="hyp-type"><b>: </b><span>f = f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{funTerm f ts = funTerm f&#39; ts&#39;} +
{funTerm f ts &lt;&gt; funTerm f&#39; ts&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk29"><span class="nb">revert</span> ts&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>feqH</var><span class="hyp-type"><b>: </b><span>f = f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ts&#39;</span> : vec VTree (a f&#39;),
{funTerm f ts = funTerm f&#39; ts&#39;} +
{funTerm f ts &lt;&gt; funTerm f&#39; ts&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk2a"><span class="nb">rewrite</span> &lt;- feqH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>feqH</var><span class="hyp-type"><b>: </b><span>f = f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ts&#39;</span> : vec VTree (a f),
{funTerm f ts = funTerm f ts&#39;} +
{funTerm f ts &lt;&gt; funTerm f ts&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk2b"><span class="nb">clear</span> feqH; <span class="nb">intro</span> ts&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{funTerm f ts = funTerm f ts&#39;} +
{funTerm f ts &lt;&gt; funTerm f ts&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk2c"><span class="nb">destruct</span> (dec_vec VTree decVTree ts ts&#39;) <span class="kr">as</span> [ tseqH | tsneH ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>tseqH</var><span class="hyp-type"><b>: </b><span>ts = ts&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{funTerm f ts = funTerm f ts&#39;} +
{funTerm f ts &lt;&gt; funTerm f ts&#39;}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>tsneH</var><span class="hyp-type"><b>: </b><span>ts &lt;&gt; ts&#39;</span></span></span><br></div><label class="goal-separator" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk2d"><hr></label><div class="goal-conclusion">{funTerm f ts = funTerm f ts&#39;} +
{funTerm f ts &lt;&gt; funTerm f ts&#39;}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk2e">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>tseqH</var><span class="hyp-type"><b>: </b><span>ts = ts&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{funTerm f ts = funTerm f ts&#39;} +
{funTerm f ts &lt;&gt; funTerm f ts&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk2f"><span class="nb">apply</span> <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>tseqH</var><span class="hyp-type"><b>: </b><span>ts = ts&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">funTerm f ts = funTerm f ts&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk30"><span class="nb">apply</span> <span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>tseqH</var><span class="hyp-type"><b>: </b><span>ts = ts&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ts = ts&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> tseqH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk31">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>tsneH</var><span class="hyp-type"><b>: </b><span>ts &lt;&gt; ts&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{funTerm f ts = funTerm f ts&#39;} +
{funTerm f ts &lt;&gt; funTerm f ts&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk32"><span class="nb">apply</span> <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>tsneH</var><span class="hyp-type"><b>: </b><span>ts &lt;&gt; ts&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">funTerm f ts &lt;&gt; funTerm f ts&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk33"><span class="nb">intro</span> funH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>tsneH</var><span class="hyp-type"><b>: </b><span>ts &lt;&gt; ts&#39;</span></span></span><br><span><var>funH</var><span class="hyp-type"><b>: </b><span>funTerm f ts = funTerm f ts&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk34"><span class="nb">inversion</span> funH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>tsneH</var><span class="hyp-type"><b>: </b><span>ts &lt;&gt; ts&#39;</span></span></span><br><span><var>funH</var><span class="hyp-type"><b>: </b><span>funTerm f ts = funTerm f ts&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>existT (<span class="kr">fun</span> <span class="nv">f</span> : F =&gt; vec VTree (a f)) f ts =
existT (<span class="kr">fun</span> <span class="nv">f</span> : F =&gt; vec VTree (a f)) f ts&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (tsneH (inj_pair2_eq_dec
                            F decF (<span class="kr">fun</span> <span class="nv">f</span> =&gt; vec VTree (a f)) f ts ts&#39; H0)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk35">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>vec VTree (a f&#39;)</span></span></span><br><span><var>fneH</var><span class="hyp-type"><b>: </b><span>f &lt;&gt; f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{funTerm f ts = funTerm f&#39; ts&#39;} +
{funTerm f ts &lt;&gt; funTerm f&#39; ts&#39;}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-decidability-for-a-datatype-that-includes-a-vector-v-chk36"><span class="nb">enough</span> (H: funTerm f ts &lt;&gt; funTerm f&#39; ts&#39;);
            <span class="kp">try</span> (<span class="bp">exact</span> (<span class="nb">right</span> H)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>V, F</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>F -&gt; nat</span></span></span><br><span><var>decV</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : V, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : F, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>decVTree</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : VTree, {x = y} + {x &lt;&gt; y}</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>VTree</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>vec VTree (a f)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>F</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>vec VTree (a f&#39;)</span></span></span><br><span><var>fneH</var><span class="hyp-type"><b>: </b><span>f &lt;&gt; f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">funTerm f ts &lt;&gt; funTerm f&#39; ts&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">injection</span>; <span class="bp">tauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">DecVTree</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">VTree</span>.</span></span></pre></div>
</div>
</div>
</div></body>
</html>
