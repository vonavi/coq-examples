<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Coq path implementation</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="coq-path-implementation">
<h1 class="title">Coq <span class="docutils literal">path</span> implementation</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/47948452">https://stackoverflow.com/q/47948452</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>This is a follow up to <a class="reference external" href="https://stackoverflow.com/questions/47764368/coq-equality-implementation">Coq equality implementation</a>
(though this question is self-contained).</p>
<p>I have a simple inductive type of trees (<span class="docutils literal">t</span>) with a fixed set of
tags (<span class="docutils literal">arityCode</span>), each with a fixed number of children. I have a
type (<span class="docutils literal">path</span>) of paths into a tree. I'm trying to implement some
manipulations. In particular, I want to be able to move a cursor
around in a few directions. This seems pretty straightforward, but I'm
running into a roadblock.</p>
<p>This is all in the code, but a quick explanation of where I'm stuck:
To construct a <span class="docutils literal">there</span> path, I need to produce a <span class="docutils literal">path (Vector.nth v i)</span> (a path in one of the children). But the only <span class="docutils literal">path</span>
constructors (<span class="docutils literal">here</span> and <span class="docutils literal">there</span>) produce a <span class="docutils literal">path (Node c v)</span>.
So in some sense I need to show the compiler that a path
simultaneously has type <span class="docutils literal">path (Node c v)</span> and <span class="docutils literal">path (Vector.nth v i)</span>, but Coq is not clever enough to compute <span class="docutils literal">(Vector.nth children fin_n)</span> -&gt; <span class="docutils literal">Node c v</span>. How can I convince it that this is okay?</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require</span> Coq.Bool.Bool.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> bool.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require</span> Coq.Strings.String.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require</span> Coq.Arith.EqNat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require</span> Coq.Arith.PeanoNat.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> nat_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require</span> Coq.Arith.Peano_dec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require</span> Coq.Lists.List.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> list_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require</span> Coq.Vectors.Vector.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> vector_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require</span> Fin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Export</span> LocalVectorNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot; [ ] &quot;</span> := (Vector.nil _) (<span class="kn">format</span> <span class="s2">&quot;[ ]&quot;</span>) : vector_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot; [ x ; .. ; y ] &quot;</span> :=
  (Vector.cons _ x _ .. (Vector.cons _ y _ (Vector.nil _)) ..) : vector_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot; [ x ; y ; .. ; z ] &quot;</span> :=
  (Vector.cons _ x _
               (Vector.cons _ y _ .. (Vector.cons _ z _ (Vector.nil _)) ..))
  : vector_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">LocalVectorNotations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Core</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Typ</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">arityCode</span> : nat -&gt; <span class="kt">Type</span> :=
    | Num   : arityCode <span class="mi">0</span>
    | Hole  : arityCode <span class="mi">0</span>
    | Arrow : arityCode <span class="mi">2</span>
    | Sum   : arityCode <span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">codeEq</span> (<span class="nv">n1</span> <span class="nv">n2</span> : nat) (<span class="nv">l</span>: arityCode n1) (<span class="nv">r</span>: arityCode n2)
      : bool :=
      <span class="kr">match</span> l, r <span class="kr">with</span>
      | Num, Num     =&gt; true
      | Hole, Hole   =&gt; true
      | Arrow, Arrow =&gt; true
      | Sum, Sum     =&gt; true
      | _, _         =&gt; false
      <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">t</span> : <span class="kt">Type</span> :=
    | Node : <span class="kr">forall</span> <span class="nv">n</span>, arityCode n -&gt; Vector.t t n -&gt; t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">path</span> : t -&gt; <span class="kt">Type</span> :=
    | Here  : <span class="kr">forall</span> <span class="nv">n</span> (<span class="nv">c</span> : arityCode n) (<span class="nv">v</span> : Vector.t t n), path (Node c v)
    | There : <span class="kr">forall</span> <span class="nv">n</span> (<span class="nv">c</span> : arityCode n) (<span class="nv">v</span> : Vector.t t n) (<span class="nv">i</span> : Fin.t n),
        path (Vector.nth v i) -&gt; path (Node c v).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">node1</span> := Node Num [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">children</span> : Vector.t t <span class="mi">2</span> := [node1; Node Hole []].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">node2</span> := Node Arrow children.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* This example can also be typed simply as `path node`, but we</span>
<span class="c">       type it this way to use it as a subpath in the next example.</span>
<span class="c">     *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">here</span>  : path <span class="c">(*node1*)</span> (Vector.nth children Fin.F1) := Here _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">there</span> : path node2 := There _ children Fin.F1 here.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">direction</span> : <span class="kt">Type</span> :=
    | Child : nat -&gt; direction
    | PrevSibling : direction
    | NextSibling : direction
    | Parent : direction.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="coq-path-implementation-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="coq-path-implementation-v-chk0"><span class="kn">Fixpoint</span> <span class="nf">move_in_path</span>
             (<span class="nv">node</span> : t)
             (<span class="nv">dir</span> : direction)
             (<span class="nv">the_path</span> : path node)
      : option (path node) :=
      <span class="kr">match</span> node <span class="kr">with</span>
        | @Node num_children code children =&gt;
          <span class="kr">match</span> the_path <span class="kr">with</span>
          | There _ _ i sub_path =&gt;
            move_in_path (Vector.nth children i) dir sub_path
          | Here _ _ =&gt;
            <span class="kr">match</span> dir <span class="kr">with</span>
            | Child n =&gt;
              <span class="kr">match</span> Fin.of_nat n num_children <span class="kr">with</span>
              | inleft fin_n =&gt;
                <span class="kr">let</span> <span class="nv">here</span> : path (Vector.nth children fin_n) := Here _ _ <span class="kr">in</span>
                <span class="kr">let</span> <span class="nv">there</span> : path node := There _ children fin_n here <span class="kr">in</span>
                Some there
              | inright _ =&gt; None
              <span class="kr">end</span>
            | _ =&gt; None <span class="c">(* TODO handle other directions *)</span>
            <span class="kr">end</span>
          <span class="kr">end</span>
      <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">In environment
move_in_path : <span class="kr">forall</span> <span class="nv">node</span> : Typ.t,
               direction -&gt;
               path node -&gt; option (path node)
node : t
dir : direction
the_path : path node
num_children : nat
code : arityCode num_children
children : Vector.t t num_children
n : nat
a : arityCode n
t : Vector.t t n
n0 : nat
fin_n : Fin.t num_children
The term <span class="s2">&quot;Here ?c@{n0:=n; n:=n0} ?v@{n0:=n; n:=n0}&quot;</span>
has type
 <span class="s2">&quot;path (Node ?c@{n0:=n; n:=n0} ?v@{n0:=n; n:=n0})&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type
 <span class="s2">&quot;path (Vector.nth children fin_n)&quot;</span>.</blockquote></div></div></small></span></pre></section>
<section id="answer">
<h2>Answer</h2>
<p>You could define a smart constructor for <span class="docutils literal">Here</span> which does not have
any constraint on the shape of the <span class="docutils literal">t</span> value it is applied to:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Here&#39;</span> (<span class="nv">v</span> : t) : path v := <span class="kr">match</span> v <span class="kr">return</span> path v <span class="kr">with</span>
                                         | Node c vs =&gt; Here c vs
                                         <span class="kr">end</span>.</span></span></pre><p>You can then write:</p>
<pre class="code coq literal-block"><code><span class="kr">let</span> <span class="nv">here</span> <span class="o">:</span> <span class="n">path</span> <span class="o">(</span><span class="n">Vector</span><span class="o">.</span><span class="n">nth</span> <span class="n">children</span> <span class="n">fin_n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Here'</span> <span class="n">_</span> <span class="kr">in</span></code></pre>
</section>
</div>
</main>
</div></body>
</html>
