<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Using dependent types in Coq (safe nth function)</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="using-dependent-types-in-coq-safe-nth-function">
<h1 class="title">Using dependent types in Coq (safe <span class="docutils literal">nth</span> function)</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/27637949">https://stackoverflow.com/q/27637949</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>I'm trying to learn Coq, but I find it hard to make the leap from what
I read in <em>Software Foundations and Certified Programming with
Dependent Types</em> to my own use cases.</p>
<p>In particular, I thought I'd try to make a verified version of the
<span class="docutils literal">nth</span> function on lists. I managed to write this:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Arith.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-types-in-coq-safe-nth-function-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-types-in-coq-safe-nth-function-v-chk0"><span class="kn">Lemma</span> <span class="nf">zltz</span> : <span class="mi">0</span> &lt; <span class="mi">0</span> -&gt; <span class="kt">False</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; <span class="mi">0</span> -&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-types-in-coq-safe-nth-function-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-types-in-coq-safe-nth-function-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; <span class="mi">0</span> -&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-types-in-coq-safe-nth-function-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-types-in-coq-safe-nth-function-v-chk2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-types-in-coq-safe-nth-function-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-types-in-coq-safe-nth-function-v-chk3"><span class="bp">contradict</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">~ <span class="mi">0</span> &lt; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Lt.lt_irrefl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-types-in-coq-safe-nth-function-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-types-in-coq-safe-nth-function-v-chk4"><span class="kn">Lemma</span> <span class="nf">nltz</span> : <span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; <span class="mi">0</span> -&gt; <span class="kt">False</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; <span class="mi">0</span> -&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-types-in-coq-safe-nth-function-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-types-in-coq-safe-nth-function-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; <span class="mi">0</span> -&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-types-in-coq-safe-nth-function-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-types-in-coq-safe-nth-function-v-chk6"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-types-in-coq-safe-nth-function-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-types-in-coq-safe-nth-function-v-chk7"><span class="bp">contradict</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ n &lt; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Lt.lt_n_0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-types-in-coq-safe-nth-function-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-types-in-coq-safe-nth-function-v-chk8"><span class="kn">Lemma</span> <span class="nf">predecessor_proof</span> : <span class="kr">forall</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) (<span class="nv">x</span> : X) (<span class="nv">xs</span> : list X),
    S n &lt; length (x :: xs) -&gt; n &lt; length xs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">x</span> : X) (<span class="nv">xs</span> : list X),
S n &lt; length (x :: xs) -&gt; n &lt; length xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-types-in-coq-safe-nth-function-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-types-in-coq-safe-nth-function-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">x</span> : X) (<span class="nv">xs</span> : list X),
S n &lt; length (x :: xs) -&gt; n &lt; length xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-types-in-coq-safe-nth-function-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-types-in-coq-safe-nth-function-v-chka"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>S n &lt; length (x :: xs)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; length xs</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-types-in-coq-safe-nth-function-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-types-in-coq-safe-nth-function-v-chkb"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>S n &lt; S (length xs)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; length xs</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-types-in-coq-safe-nth-function-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-types-in-coq-safe-nth-function-v-chkc"><span class="nb">apply</span> Lt.lt_S_n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>S n &lt; S (length xs)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n &lt; S (length xs)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">safe_nth</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) (<span class="nv">xs</span> : list X) : n &lt; length xs -&gt; X :=
  <span class="kr">match</span> n, xs <span class="kr">with</span>
  | <span class="mi">0</span>, [] =&gt; <span class="kr">fun</span> <span class="nv">pf</span> : <span class="mi">0</span> &lt; length [] =&gt; <span class="kr">match</span> zltz pf <span class="kr">with</span> <span class="kr">end</span>
  | S n&#39;, [] =&gt; <span class="kr">fun</span> <span class="nv">pf</span> : S n&#39; &lt; length [] =&gt; <span class="kr">match</span> nltz (S n&#39;) pf <span class="kr">with</span> <span class="kr">end</span>
  | <span class="mi">0</span>, x :: _ =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; x
  | S n&#39;, x :: xs&#39; =&gt; <span class="kr">fun</span> <span class="nv">pf</span> : S n&#39; &lt; length (x :: xs&#39;) =&gt;
                        safe_nth n&#39; xs&#39; (predecessor_proof n&#39; x xs&#39; pf)
  <span class="kr">end</span>.</span></span></pre><p>This works, but it raises two questions:</p>
<ol class="arabic simple">
<li><p>How would experienced Coq users write this? Are the three lemmas
really necessary? Is this a use case for <span class="docutils literal">{ | }</span> types?</p></li>
<li><p>How do I call this function from other code, i.e., how do I supply
the required proofs?</p></li>
</ol>
<p>I tried this:</p>
<pre class="code coq literal-block"><code><span class="kn">Require Import</span> <span class="n">NPeano</span><span class="o">.</span>
<span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span>
  <span class="kr">if</span> <span class="n">ltb</span> <span class="mi">2</span> <span class="o">(</span><span class="n">length</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">])</span> <span class="kr">then</span> <span class="n">safe_nth</span> <span class="mi">2</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span> <span class="o">???</span> <span class="kr">else</span> <span class="mi">0</span><span class="o">.</span></code></pre>
<p>But of course this won't work until I figure out what to write for the
<span class="docutils literal"><span class="pre">???</span></span> part. I tried putting <span class="docutils literal">2 &lt; length [1; 2; 3]</span> there but that
has type <span class="docutils literal">Prop</span> rather than type <span class="docutils literal">2 &lt; length [1; 2; 3]</span>. I could
write and prove a lemma of that specific type, and that works. But
what's the general solution?</p>
</section>
<section id="answer-arthur-azevedo-de-amorim">
<h2>Answer (Arthur Azevedo De Amorim)</h2>
<p>I don't think there is a consensus on what the best way for doing this
sort of thing is.</p>
<p>I believe that usually Coq developments tend to favor indexed
inductive types for writing code like that. This is the solution
followed by the <a class="reference external" href="https://coq.inria.fr/distrib/current/stdlib/Coq.Vectors.Vector.html">vector library</a>
in the Coq distribution. There, you would define an indexed inductive
type for vectors and another one for bounded integers (called
<span class="docutils literal">Vector.t</span> and <span class="docutils literal">Fin.t</span> in the standard library, respectively).
Some functions, such as <span class="docutils literal">nth</span>, are much simpler to write in this
style, since pattern matching on vectors and indices ends up doing a
little bit of reasoning for you when getting rid of contradictory
cases and doing recursive calls, for instance. The disadvantage is
that dependent pattern matching in Coq is not very intuitive, and
sometimes you have to write your functions in a weird way to get them
to work. Another problem with this approach is that one needs to
redefine many functions that work on lists to work on vectors.</p>
<p>Another solution is to define bounded integers as a dependent pair of
a <span class="docutils literal">nat</span> and a proof that that index is bounded, which is essentially
what you going for when you mentioned <span class="docutils literal">{ | }</span> types. This is the
approach followed by the <a class="reference external" href="http://ssr.msr-inria.inria.fr/~jenkins/current/Ssreflect.fintype.html">ssreflect</a>
library, for instance (look fot the <span class="docutils literal">ordinal</span> type). To define a
safe <span class="docutils literal">nth</span> function, what they do is to define a simple version that
takes a default element to return when the index is out of bounds, and
use the proof that <span class="docutils literal">n &lt; length l</span> to supply that default element
(have a look for instance at <a class="reference external" href="http://ssr.msr-inria.inria.fr/~jenkins/current/Ssreflect.tuple.html">tuple</a>
library of ssreflect, where they define length-indexed lists, and see
how they define <span class="docutils literal">tnth</span>). The advantage is that it is easier to
relate the more informative types and functions to the simpler
variants. The disadvantage is that some things become harder to
express directly: for instance, you can't do pattern-matching directly
on an ssreflect tuple.</p>
<p>Another point worth noting is that very often it is easier to work
with boolean properties instead of inductively defined ones, because
computation and simplification obviate the need for some lemmas. Thus,
when using a boolean version of <span class="docutils literal">&lt;</span>, Coq doesn't make a difference
between a proof of <span class="docutils literal">0 &lt; 0 = true</span> and <span class="docutils literal">false = true</span>, or between a
proof of <span class="docutils literal">S n &lt; length (x :: l) = true</span> and a proof of <span class="docutils literal">n &lt; length l = true</span>, which means that you would be able to use those proofs
directly in your definition of <span class="docutils literal">nth</span> without having to massage them
with auxiliary lemmas. The Coq standard library, unfortunately, tends
to favor inductively defined types over boolean computations in many
cases where they are not useful, such as for defining <span class="docutils literal">&lt;</span>. The
<a class="reference external" href="http://ssr.msr-inria.inria.fr/">ssreflect</a> library, on the other
hand, makes much more use of boolean computations for defining
properties, making it more appropriate for this style of programming.</p>
</section>
<section id="answer-perce-strop">
<h2>Answer (Perce Strop)</h2>
<p><span class="docutils literal">zltz</span> has the same type as <span class="docutils literal">nltz 0</span>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-types-in-coq-safe-nth-function-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-types-in-coq-safe-nth-function-v-chkd"><span class="kn">Check</span> zltz.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">zltz
     : <span class="mi">0</span> &lt; <span class="mi">0</span> -&gt; <span class="kt">False</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-types-in-coq-safe-nth-function-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-types-in-coq-safe-nth-function-v-chke"><span class="kn">Check</span> nltz <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">nltz <span class="mi">0</span>
     : <span class="mi">0</span> &lt; <span class="mi">0</span> -&gt; <span class="kt">False</span></blockquote></div></div></small></span></pre><p>To use your function with <span class="docutils literal">2</span> and <span class="docutils literal">[1; 2; 3]</span> from within another
function, you can use <span class="docutils literal">lt_dec</span>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-types-in-coq-safe-nth-function-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-types-in-coq-safe-nth-function-v-chkf"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> <span class="kr">match</span> lt_dec <span class="mi">2</span> (length [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>]) <span class="kr">with</span>
                | <span class="nb">left</span> pf =&gt; safe_nth <span class="mi">2</span> [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] pf
                | <span class="nb">right</span> _ =&gt; <span class="mi">0</span>
                <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="mi">3</span>
: nat</blockquote></div></div></small></span></pre><p>If you extract <span class="docutils literal">lt_dec</span>, you'll find it's very similar to <span class="docutils literal">ltb</span>
after the proofs are erased. You don't need to use <span class="docutils literal">lt_dec</span> if you
can build your proof from within the function where <span class="docutils literal">safe_nth</span> is
called.</p>
<p>You can shorten your function a bit like this.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">safe_nth&#39;</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">xs</span> : list X) (<span class="nv">n</span> : nat) : n &lt; length xs -&gt; X :=
  <span class="kr">match</span> xs, n <span class="kr">with</span>
  | [], _ =&gt; <span class="kr">fun</span> <span class="nv">pf</span> =&gt; <span class="kr">match</span> nltz n pf <span class="kr">with</span> <span class="kr">end</span>
  | x :: _, <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; x
  | x :: xs&#39;, S n&#39; =&gt; <span class="kr">fun</span> <span class="nv">pf</span> =&gt; safe_nth&#39; xs&#39; n&#39; (predecessor_proof n&#39; x xs&#39; pf)
  <span class="kr">end</span>.</span></span></pre><p>I'm not sure what best practices are, but you get tidier extracted
code if you use <span class="docutils literal">sig</span>.</p>
<hr class="docutils" />
<p><strong>Q:</strong> Thanks for the explanation using <span class="docutils literal">lt_dec</span>, that was the piece
I was missing! And yes, I had seen the similarity between <span class="docutils literal">zltz</span> and
<span class="docutils literal">nltz</span> but missed the equivalence...</p>
</section>
</div>
</main>
</div></body>
</html>
