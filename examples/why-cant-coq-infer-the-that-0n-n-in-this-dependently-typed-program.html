<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Why can't Coq infer the that 0 + n = n in this dependently typed program?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="why-can-t-coq-infer-the-that-0-n-n-in-this-dependently-typed-program">
<h1 class="title">Why can't Coq infer the that <span class="docutils literal">0 + n = n</span> in this dependently typed program?</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/35989122">https://stackoverflow.com/q/35989122</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>I'm starting to use Coq and I'd like to define some dependently typed
programs. Consider the following:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">natlist</span> : nat -&gt; <span class="kt">Type</span> :=
| natnil : natlist <span class="mi">0</span>
| natcons : <span class="kr">forall</span> <span class="nv">k</span>, nat -&gt; natlist k -&gt; natlist (S k).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-cant-coq-infer-the-that-0n-n-in-this-dependently-typed-program-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="why-cant-coq-infer-the-that-0n-n-in-this-dependently-typed-program-v-chk0"><span class="kn">Fixpoint</span> <span class="nf">natappend</span> (<span class="nv">n</span> : nat) (<span class="nv">l1</span> : natlist n) (<span class="nv">m</span> : nat) (<span class="nv">l2</span> : natlist m) :
  natlist (n + m) :=
  <span class="kr">match</span> l1 <span class="kr">with</span>
  | natnil =&gt; l2
  | natcons _ x rest =&gt; natcons (n + m) x (natappend rest l2)
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">In environment
natappend : <span class="kr">forall</span> <span class="nv">n</span> : nat,
            natlist n -&gt;
            <span class="kr">forall</span> <span class="nv">m</span> : nat,
            natlist m -&gt; natlist (n + m)
n : nat
l1 : natlist n
m : nat
l2 : natlist m
The term <span class="s2">&quot;l2&quot;</span> has type <span class="s2">&quot;natlist m&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type
 <span class="s2">&quot;natlist (?n@{n1:=0} + m)&quot;</span>.</blockquote></div></div></small></span></pre><p>So <span class="docutils literal">natlist k</span> would be a list of <span class="docutils literal">nat</span>s of length <span class="docutils literal">k</span>. The
problem with the definition of concatenation as <span class="docutils literal">natappend</span> is the
following error:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="why-cant-coq-infer-the-that-0n-n-in-this-dependently-typed-program-v-chk1" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
In environment
natappend : <span class="kr">forall</span> <span class="nv">n</span> : nat,
            natlist n -&gt;
            <span class="kr">forall</span> <span class="nv">m</span> : nat,
            natlist m -&gt; natlist (n + m)
n : nat
l1 : natlist n
m : nat
l2 : natlist m
The term <span class="s2">&quot;l2&quot;</span> has type <span class="s2">&quot;natlist m&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type
 <span class="s2">&quot;natlist (?n@{n1:=0} + m)&quot;</span>.</blockquote></div></div></small></span></pre><p>As you can see it has a problem with the clause:</p>
<pre class="code literal-block"><code>| natnil =&gt; l2</code></pre>
<p>because it claims that the type of <span class="docutils literal">l2</span> is <span class="docutils literal">natlist m</span> while the
result type must be <span class="docutils literal">natlist (n + m) = natlist (0 + m)</span>.</p>
<p>I know that Coq cannot resolve arbitrary expressions at the type level
to avoid non-terminating computations, but I find strange that even
this simple case isn't handled.</p>
</section>
<section id="answer-arthur-azevedo-de-amorim">
<h2>Answer (Arthur Azevedo De Amorim)</h2>
<p>The problem is that you had a type error in your second branch. Here
is a version that works:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">natappend</span> {<span class="nv">n</span> <span class="nv">m</span> : nat} (<span class="nv">l1</span> : natlist n) (<span class="nv">l2</span> : natlist m) :
  natlist (n + m) :=
  <span class="kr">match</span> l1 <span class="kr">with</span>
  | natnil =&gt; l2
  | natcons n&#39; x rest =&gt; natcons (n&#39; + m) x (natappend rest l2)
  <span class="kr">end</span>.</span></span></pre><p>The crucial difference between this version and the original one is
the parameter passed to <span class="docutils literal">natcons</span>: here, it is <span class="docutils literal">n' + m</span>, whereas
before it was <span class="docutils literal">n + m</span>.</p>
<p>This example illustrates very well a general issue with non-locality
of error messages in Coq, in particular when writing dependently typed
programs. Even though Coq complained about the first branch, the
problem was actually in the second branch. Adding annotations in your
<span class="docutils literal">match</span> statement, as suggested by &#64;jbapple, can be useful when
trying to diagnose what is going wrong.</p>
</section>
<section id="answer-jbapple">
<h2>Answer (jbapple)</h2>
<p>You need <span class="docutils literal">match ... as ... in ... return ...</span> to do more
sophisticated type annotations. See <a class="reference external" href="http://adam.chlipala.net/cpdt/html/MoreDep.html">Adam Chlipala's chapter &quot;Library
MoreDep&quot; in his Book &quot;Certified Programming with Dependent Types&quot;</a> or <a class="reference external" href="https://coq.inria.fr/refman/Reference-Manual020.html">&quot;Chapter 17:
Extended pattern-matching&quot; in the Coq manual</a>. Both have
the <span class="docutils literal">concat</span> example you are working on.</p>
<p>You could also just delay the dependent type bit until the end:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">natlist</span> <span class="nv">n</span> := { x : list nat &amp; n = length x }.</span></span></pre><p>Then prove that non-dependently-typed <span class="docutils literal">concat</span> preserves length
sums.</p>
<hr class="docutils" />
<p><strong>A:</strong> I much support &#64;jbapple's definition of <span class="docutils literal">natlist</span> as a
dependent record instead of the original one, however I'd suggest
using</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">natlist</span> <span class="nv">n</span> := { x : list nat &amp; Is_true (n =? length x) }.</span></span></pre><p>where <span class="docutils literal">=?</span> is the boolean equality on <span class="docutils literal">nat</span>, for reasons of proof
irrelevance.</p>
<p><strong>A:</strong> In general using a <span class="docutils literal">bool</span> makes it easier to prove
injectivity of the first projection, see:
<a class="reference external" href="http://stackoverflow.com/questions/35290012/inductive-subset-of-an-inductive-set-in-coq/35300521#35300521">http://stackoverflow.com/questions/35290012/inductive-subset-of-an-inductive-set-in-coq/35300521#35300521</a></p>
<p><strong>A:</strong> By the way, I learned about this by reading the <span class="docutils literal">tuple.v</span>, a
very good example of a complete sized list library is
<a class="reference external" href="http://ssr.msr-inria.inria.fr/~jenkins/current/mathcomp.ssreflect.tuple.html">http://ssr.msr-inria.inria.fr/~jenkins/current/mathcomp.ssreflect.tuple.html</a>,
I really learned a lot from trying to understand it.</p>
</section>
</div>
</main>
</div></body>
</html>
