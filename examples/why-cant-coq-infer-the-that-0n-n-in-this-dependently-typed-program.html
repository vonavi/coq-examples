<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>Why can't Coq infer the that 0 + n = n in this dependently typed program?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="why-can-t-coq-infer-the-that-0-n-n-in-this-dependently-typed-program">
<h1 class="title">Why can't Coq infer the that <tt class="docutils literal">0 + n = n</tt> in this dependently typed program?</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/35989122">https://stackoverflow.com/q/35989122</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>I'm starting to use Coq and I'd like to define some dependently typed
programs. Consider the following:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">natlist</span> : nat -&gt; <span class="kt">Type</span> :=
| natnil : natlist <span class="mi">0</span>
| natcons : <span class="kr">forall</span> <span class="nv">k</span>, nat -&gt; natlist k -&gt; natlist (S k).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-cant-coq-infer-the-that-0n-n-in-this-dependently-typed-program-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="why-cant-coq-infer-the-that-0n-n-in-this-dependently-typed-program-v-chk0"><span class="kn">Fixpoint</span> <span class="nf">natappend</span> (<span class="nv">n</span> : nat) (<span class="nv">l1</span> : natlist n) (<span class="nv">m</span> : nat) (<span class="nv">l2</span> : natlist m) :
  natlist (n + m) :=
  <span class="kr">match</span> l1 <span class="kr">with</span>
  | natnil =&gt; l2
  | natcons _ x rest =&gt; natcons (n + m) x (natappend rest l2)
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">In environment
natappend : <span class="kr">forall</span> <span class="nv">n</span> : nat,
            natlist n -&gt;
            <span class="kr">forall</span> <span class="nv">m</span> : nat,
            natlist m -&gt; natlist (n + m)
n : nat
l1 : natlist n
m : nat
l2 : natlist m
The term <span class="s2">&quot;l2&quot;</span> has type <span class="s2">&quot;natlist m&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type
 <span class="s2">&quot;natlist (?n@{n1:=0} + m)&quot;</span>.</blockquote></div></div></small></span></pre><p>So <tt class="docutils literal">natlist k</tt> would be a list of <tt class="docutils literal">nat</tt>s of length <tt class="docutils literal">k</tt>. The
problem with the definition of concatenation as <tt class="docutils literal">natappend</tt> is the
following error:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="why-cant-coq-infer-the-that-0n-n-in-this-dependently-typed-program-v-chk1" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
In environment
natappend : <span class="kr">forall</span> <span class="nv">n</span> : nat,
            natlist n -&gt;
            <span class="kr">forall</span> <span class="nv">m</span> : nat,
            natlist m -&gt; natlist (n + m)
n : nat
l1 : natlist n
m : nat
l2 : natlist m
The term <span class="s2">&quot;l2&quot;</span> has type <span class="s2">&quot;natlist m&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type
 <span class="s2">&quot;natlist (?n@{n1:=0} + m)&quot;</span>.</blockquote></div></div></small></span></pre><p>As you can see it has a problem with the clause:</p>
<pre class="code literal-block">
| natnil =&gt; l2
</pre>
<p>because it claims that the type of <tt class="docutils literal">l2</tt> is <tt class="docutils literal">natlist m</tt> while the
result type must be <tt class="docutils literal">natlist (n + m) = natlist (0 + m)</tt>.</p>
<p>I know that Coq cannot resolve arbitrary expressions at the type level
to avoid non-terminating computations, but I find strange that even
this simple case isn't handled.</p>
</div>
<div class="section" id="answer-arthur-azevedo-de-amorim">
<h1>Answer (Arthur Azevedo De Amorim)</h1>
<p>The problem is that you had a type error in your second branch. Here
is a version that works:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">natappend</span> {<span class="nv">n</span> <span class="nv">m</span> : nat} (<span class="nv">l1</span> : natlist n) (<span class="nv">l2</span> : natlist m) :
  natlist (n + m) :=
  <span class="kr">match</span> l1 <span class="kr">with</span>
  | natnil =&gt; l2
  | natcons n&#39; x rest =&gt; natcons (n&#39; + m) x (natappend rest l2)
  <span class="kr">end</span>.</span></span></pre><p>The crucial difference between this version and the original one is
the parameter passed to <tt class="docutils literal">natcons</tt>: here, it is <tt class="docutils literal">n' + m</tt>, whereas
before it was <tt class="docutils literal">n + m</tt>.</p>
<p>This example illustrates very well a general issue with non-locality
of error messages in Coq, in particular when writing dependently typed
programs. Even though Coq complained about the first branch, the
problem was actually in the second branch. Adding annotations in your
<tt class="docutils literal">match</tt> statement, as suggested by &#64;jbapple, can be useful when
trying to diagnose what is going wrong.</p>
</div>
<div class="section" id="answer-jbapple">
<h1>Answer (jbapple)</h1>
<p>You need <tt class="docutils literal">match ... as ... in ... return ...</tt> to do more
sophisticated type annotations. See <a class="reference external" href="http://adam.chlipala.net/cpdt/html/MoreDep.html">Adam Chlipala's chapter &quot;Library
MoreDep&quot; in his Book &quot;Certified Programming with Dependent Types&quot;</a> or <a class="reference external" href="https://coq.inria.fr/refman/Reference-Manual020.html">&quot;Chapter 17:
Extended pattern-matching&quot; in the Coq manual</a>. Both have
the <tt class="docutils literal">concat</tt> example you are working on.</p>
<p>You could also just delay the dependent type bit until the end:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">natlist</span> <span class="nv">n</span> := { x : list nat &amp; n = length x }.</span></span></pre><p>Then prove that non-dependently-typed <tt class="docutils literal">concat</tt> preserves length
sums.</p>
<hr class="docutils" />
<p><strong>A:</strong>
I much support &#64;jbapple's definition of natlist as a dependent record
instead of the original one, however I'd suggest using</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">natlist</span> <span class="nv">n</span> := { x : list nat &amp; Is_true (n =? length x) }.</span></span></pre><p>where <tt class="docutils literal">=?</tt> is the boolean equality on <tt class="docutils literal">nat</tt>, for reasons of proof
irrelevance.</p>
<p><strong>A:</strong> In general using a <tt class="docutils literal">bool</tt> makes it easier to prove
injectivity of the first projection, see:
<a class="reference external" href="http://stackoverflow.com/questions/35290012/inductive-subset-of-an-inductive-set-in-coq/35300521#35300521">http://stackoverflow.com/questions/35290012/inductive-subset-of-an-inductive-set-in-coq/35300521#35300521</a></p>
<p><strong>A:</strong> By the way, I learned about this by reading the <tt class="docutils literal">tuple.v</tt>, a
very good example of a complete sized list library is
<a class="reference external" href="http://ssr.msr-inria.inria.fr/~jenkins/current/mathcomp.ssreflect.tuple.html">http://ssr.msr-inria.inria.fr/~jenkins/current/mathcomp.ssreflect.tuple.html</a>,
I really learned a lot from trying to understand it.</p>
</div>
</div>
</div>
</div></body>
</html>
