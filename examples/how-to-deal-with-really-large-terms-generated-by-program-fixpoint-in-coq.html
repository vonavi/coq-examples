<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>How to deal with really large terms generated by Program Fixpoint in Coq?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="how-to-deal-with-really-large-terms-generated-by-program-fixpoint-in-coq">
<h1 class="title">How to deal with really large terms generated by <tt class="docutils literal">Program Fixpoint</tt> in Coq?</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/44612214">https://stackoverflow.com/q/44612214</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>I'm attempting to define and prove correct in Coq a function that
efficiently diffs two sorted lists. As it does not always recurse on a
structurally smaller term (either the first or second list is
smaller), Fixpoint won't accept it, so I'm attempting to use <tt class="docutils literal">Program
Fixpoint</tt> instead.</p>
<p>When attempting to prove a property of the function using the tactic
<tt class="docutils literal">simpl</tt> or <tt class="docutils literal">program_simpl</tt>, Coq spends minutes computing and then
produces a giant term, hundreds of lines long. I was wondering if I'm
using <tt class="docutils literal">Program Fixpoint</tt> the wrong way, or alternatively if there
are other tactics that should be used instead of simplification when
reasoning about it?</p>
<p>I also wondered if it's good practice to include the required
properties for correctness in params like this, or would it be better
to have a separate wrapper function that takes the correctness
properties as params, and make this function just take the two lists
to be diffed?</p>
<p>Note that I did try defining a simpler version of <tt class="docutils literal">make_diff</tt>, which
only took <tt class="docutils literal">l1</tt> and <tt class="docutils literal">l2</tt> as parameters and fixed the type <tt class="docutils literal">A</tt> and
relation <tt class="docutils literal">R</tt>, but this still produced a gigantic term when the
<tt class="docutils literal">program_simpl</tt> or <tt class="docutils literal">simpl</tt> tactics were applied.</p>
<p>Edit: my includes are (although they may not all be required here):</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Sorting.Sorted.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Lists.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Relations.Relation_Definitions.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Recdef.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Program.Wf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Program.Tactics.</span></span></pre><p>The code:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">is_decidable</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : relation A) :=
  <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, {R x y} + {~ R x y}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eq_decidable</span> (<span class="nv">A</span> : <span class="kt">Type</span>) := <span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A), {x = y} + {~ x = y}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">diff</span> (<span class="nv">X</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
| add : X -&gt; diff X
| remove : X -&gt; diff X
| update : X -&gt; X -&gt; diff X.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Fixpoint</span> <span class="nf">make_diff</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
        (<span class="nv">R</span> : relation A)
        (<span class="nv">dec</span> : is_decidable A R)
        (<span class="nv">eq_dec</span> : eq_decidable A)
        (<span class="nv">trans</span> : transitive A R)
        (<span class="nv">lt_neq</span> : (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, R x y -&gt; x &lt;&gt; y))
        (<span class="nv">l1</span> <span class="nv">l2</span> : list A)
        {<span class="nv">measure</span>(length l1 + length l2)} : list (diff A) :=
  <span class="kr">match</span> l1, l2 <span class="kr">with</span>
  | nil, nil =&gt; nil
  | nil, new_h :: new_t =&gt;
      add A new_h :: make_diff A R dec eq_dec trans lt_neq nil new_t
  | old_h :: old_t, nil =&gt;
      remove A old_h :: make_diff A R dec eq_dec trans lt_neq old_t nil
  | old_h :: old_t <span class="kr">as</span> old_l, new_h::new_t <span class="kr">as</span> new_l =&gt;
      <span class="kr">if</span> dec old_h new_h
      <span class="kr">then</span> remove A old_h :: make_diff A R dec eq_dec trans lt_neq old_t new_l
      <span class="kr">else</span> <span class="kr">if</span> eq_dec old_h new_h
           <span class="kr">then</span> update A old_h new_h ::
                       make_diff A R dec  eq_dec trans lt_neq old_t new_t
           <span class="kr">else</span> add A new_h :: make_diff A R dec eq_dec trans lt_neq old_l new_t
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-deal-with-really-large-terms-generated-by-program-fixpoint-in-coq-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-deal-with-really-large-terms-generated-by-program-fixpoint-in-coq-v-chk0"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span>is_decidable A R</span></span></span><br><span><var>eq_dec</var><span class="hyp-type"><b>: </b><span>eq_decidable A</span></span></span><br><span><var>trans</var><span class="hyp-type"><b>: </b><span>transitive A R</span></span></span><br><span><var>lt_neq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y -&gt; x &lt;&gt; y</span></span></span><br><span><var>new_h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>new_l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>old_h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>old_l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>make_diff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A0</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : relation A0),
is_decidable A0 R -&gt;
eq_decidable A0 -&gt;
transitive A0 R -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A0, R x y -&gt; x &lt;&gt; y) -&gt;
<span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A0,
length l1 + length l2 &lt;
length (old_h :: old_l) +
length (new_h :: new_l) -&gt; 
list (diff A0)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>R old_h new_h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length old_l + length new_l &lt;
length (old_h :: old_l) + length (new_h :: new_l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-deal-with-really-large-terms-generated-by-program-fixpoint-in-coq-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-deal-with-really-large-terms-generated-by-program-fixpoint-in-coq-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span>is_decidable A R</span></span></span><br><span><var>eq_dec</var><span class="hyp-type"><b>: </b><span>eq_decidable A</span></span></span><br><span><var>trans</var><span class="hyp-type"><b>: </b><span>transitive A R</span></span></span><br><span><var>lt_neq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y -&gt; x &lt;&gt; y</span></span></span><br><span><var>new_h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>new_l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>old_h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>old_l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>make_diff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A0</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : relation A0),
is_decidable A0 R -&gt;
eq_decidable A0 -&gt;
transitive A0 R -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A0, R x y -&gt; x &lt;&gt; y) -&gt;
<span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A0,
length l1 + length l2 &lt;
length (old_h :: old_l) +
length (new_h :: new_l) -&gt; 
list (diff A0)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>R old_h new_h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length old_l + length new_l &lt;
length (old_h :: old_l) + length (new_h :: new_l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-deal-with-really-large-terms-generated-by-program-fixpoint-in-coq-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-deal-with-really-large-terms-generated-by-program-fixpoint-in-coq-v-chk2"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span>is_decidable A R</span></span></span><br><span><var>eq_dec</var><span class="hyp-type"><b>: </b><span>eq_decidable A</span></span></span><br><span><var>trans</var><span class="hyp-type"><b>: </b><span>transitive A R</span></span></span><br><span><var>lt_neq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y -&gt; x &lt;&gt; y</span></span></span><br><span><var>new_h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>new_l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>old_h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>old_l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>make_diff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A0</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : relation A0),
is_decidable A0 R -&gt;
eq_decidable A0 -&gt;
transitive A0 R -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A0, R x y -&gt; x &lt;&gt; y) -&gt;
<span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A0,
length l1 + length l2 &lt;
length (old_h :: old_l) +
length (new_h :: new_l) -&gt; 
list (diff A0)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>R old_h new_h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length old_l + length new_l &lt;
S (length old_l + S (length new_l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-deal-with-really-large-terms-generated-by-program-fixpoint-in-coq-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-deal-with-really-large-terms-generated-by-program-fixpoint-in-coq-v-chk3"><span class="nb">generalize dependent</span> (length new_l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span>is_decidable A R</span></span></span><br><span><var>eq_dec</var><span class="hyp-type"><b>: </b><span>eq_decidable A</span></span></span><br><span><var>trans</var><span class="hyp-type"><b>: </b><span>transitive A R</span></span></span><br><span><var>lt_neq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y -&gt; x &lt;&gt; y</span></span></span><br><span><var>new_h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>new_l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>old_h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>old_l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>make_diff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A0</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : relation A0),
is_decidable A0 R -&gt;
eq_decidable A0 -&gt;
transitive A0 R -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A0, R x y -&gt; x &lt;&gt; y) -&gt;
<span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A0,
length l1 + length l2 &lt;
length (old_h :: old_l) +
length (new_h :: new_l) -&gt; 
list (diff A0)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>R old_h new_h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
length old_l + n &lt; S (length old_l + S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-deal-with-really-large-terms-generated-by-program-fixpoint-in-coq-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-deal-with-really-large-terms-generated-by-program-fixpoint-in-coq-v-chk4"><span class="nb">generalize dependent</span> (length old_l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span>is_decidable A R</span></span></span><br><span><var>eq_dec</var><span class="hyp-type"><b>: </b><span>eq_decidable A</span></span></span><br><span><var>trans</var><span class="hyp-type"><b>: </b><span>transitive A R</span></span></span><br><span><var>lt_neq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y -&gt; x &lt;&gt; y</span></span></span><br><span><var>new_h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>new_l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>old_h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>old_l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>make_diff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A0</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : relation A0),
is_decidable A0 R -&gt;
eq_decidable A0 -&gt;
transitive A0 R -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A0, R x y -&gt; x &lt;&gt; y) -&gt;
<span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A0,
length l1 + length l2 &lt;
length (old_h :: old_l) +
length (new_h :: new_l) -&gt; 
list (diff A0)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>R old_h new_h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">n0</span> : nat, n + n0 &lt; S (n + S n0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto with</span> arith.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre></div>
<div class="section" id="answer">
<h1>Answer</h1>
<p>In this particular case we can get rid of <tt class="docutils literal">Program Fixpoint</tt> and use
plain simple <tt class="docutils literal">Fixpoint</tt>. Since at each recursive call we invoke
<tt class="docutils literal">make_diff</tt> either on the tail of the first list or on the tail of
the second list, we can nest two fixed-point functions as follows. (I
have used the <tt class="docutils literal">Section</tt> mechanism here to avoid passing too many
identical arguments)</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Lists.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Relations.Relations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Make_diff</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">A</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">R</span> : relation A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">dec</span> : is_decidable A R.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">eq_dec</span> : eq_decidable A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">trans</span> : transitive A R.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">lt_neq</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, R x y -&gt; x &lt;&gt; y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">diff</span> (<span class="nv">X</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
  | add : X -&gt; diff X
  | remove : X -&gt; diff X
  | update : X -&gt; X -&gt; diff X.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">make_diff</span> (<span class="nv">l1</span> <span class="nv">l2</span> : list A) : list (diff A) :=
    <span class="kr">let fix</span> <span class="nv">make_diff2</span> <span class="nv">l2</span> :=
      <span class="kr">match</span> l1, l2 <span class="kr">with</span>
      | nil, nil =&gt; nil
      | nil, new_h :: new_t =&gt; add A new_h :: make_diff2 new_t
      | old_h :: old_t, nil =&gt; remove A old_h :: make_diff old_t nil
      | old_h :: old_t, new_h :: new_t =&gt;
          <span class="kr">if</span> dec old_h new_h
          <span class="kr">then</span> remove A old_h :: make_diff old_t l2
          <span class="kr">else</span> <span class="kr">if</span> eq_dec old_h new_h
               <span class="kr">then</span> update A old_h new_h :: make_diff old_t new_t
               <span class="kr">else</span> add A new_h :: make_diff2 new_t
      <span class="kr">end</span>
    <span class="kr">in</span> make_diff2 l2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Make_diff</span>.</span></span></pre><p>Observe that the <tt class="docutils literal">Section</tt> mechanism won't include unused parameters
in the resulting signature. Here is a naive test:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* make the first 2 arguments implicit *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> make_diff [A R] _ _ _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Arith.Arith.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-to-deal-with-really-large-terms-generated-by-program-fixpoint-in-coq-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-deal-with-really-large-terms-generated-by-program-fixpoint-in-coq-v-chk5"><span class="kn">Compute</span> make_diff lt_dec Nat.eq_dec [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>] [<span class="mi">4</span>;<span class="mi">5</span>;<span class="mi">6</span>].</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= [remove nat <span class="mi">1</span>; remove nat <span class="mi">2</span>; remove nat <span class="mi">3</span>;
  add nat <span class="mi">4</span>; add nat <span class="mi">5</span>; add nat <span class="mi">6</span>]
: list (diff nat)</blockquote></div></div></small></span></pre></div>
</div>
</div>
</div></body>
</html>
