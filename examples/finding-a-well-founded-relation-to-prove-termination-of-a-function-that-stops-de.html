<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Finding a well founded relation to prove termination of a function that stops decreasing at some point</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-decreasing-at-some-point">
<h1 class="title">Finding a well founded relation to prove termination of a function that stops decreasing at some point</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/48121413">https://stackoverflow.com/q/48121413</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>Suppose we have:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> ZArith Program.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> Z_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Fixpoint</span> <span class="nf">range</span> (<span class="nv">from</span> <span class="nv">to</span> : Z) {<span class="nv">measure</span> <span class="nv">f</span> <span class="nv">R</span>} : list Z :=
  <span class="kr">if</span> <span class="kn">from</span> &lt;? to
  <span class="kr">then</span> <span class="kn">from</span> :: range (<span class="kn">from</span> + <span class="mi">1</span>) to
  <span class="kr">else</span> [].</span></span></pre><p>I'd like to convince Coq that this terminates - I tried by measuring
the size of the range as <span class="docutils literal">abs (to - from)</span>. However, this doesn't
quite work because once the range is empty (that is, <span class="docutils literal">from &gt;= to</span>),
it simply starts increasing once again.</p>
<p>Using my custom:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">preceeds_eq</span> (<span class="nv">l</span> <span class="nv">r</span> : option nat) : <span class="kt">Prop</span> :=
  <span class="kr">match</span> l, r <span class="kr">with</span>
  | None, None     =&gt; <span class="kt">False</span>
  | None, Some _   =&gt; <span class="kt">True</span>
  | Some _, None   =&gt; <span class="kt">False</span>
  | Some x, Some y =&gt; (x &lt; y)%nat
  <span class="kr">end</span>.</span></span></pre><p>and the cast:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk0"><span class="kn">Definition</span> <span class="nf">Z_to_nat</span> (<span class="nv">z</span> : Z) (<span class="nv">p</span> : <span class="mi">0</span> &lt;= z) : nat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>z</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>z</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk2"><span class="nb">dependent destruction</span> z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= Z.pos p</span></span></span><br></div><label class="goal-separator" for="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk3"><hr></label><div class="goal-conclusion">nat</div></blockquote><input class="alectryon-extra-goal-toggle" id="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= Z.neg p</span></span></span><br></div><label class="goal-separator" for="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk4"><hr></label><div class="goal-conclusion">nat</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> <span class="mi">0</span>%nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= Z.pos p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Pos.to_nat p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= Z.neg p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk8"><span class="nb">assert</span> (Z.neg p &lt; <span class="mi">0</span>) <span class="bp">by</span> <span class="nb">apply</span> Zlt_neg_0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= Z.neg p</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Z.neg p &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">contradiction</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>I've also tried measuring with:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">get_range</span> (<span class="nv">from</span> <span class="nv">to</span> : Z) : option nat :=
  <span class="kr">let</span> <span class="nv">range</span> := (to - <span class="kn">from</span>) <span class="kr">in</span>
  <span class="kr">if</span> (range &lt;? <span class="mi">0</span>)
  <span class="kr">then</span> None
  <span class="kr">else</span> Some (Z_to_nat (Z.abs range) (Z.abs_nonneg range)).</span></span></pre><p>But it runs into the issue that I cannot show that <span class="docutils literal">None &lt; None</span> and
using reflexive <span class="docutils literal">preceeds_eq</span> makes the relation not well founded,
which brings me back to the same problem.</p>
<p>Is there a way to convince Coq that <span class="docutils literal">range</span> terminates? Is my
approach completely broken?</p>
</section>
<section id="answer">
<h2>Answer</h2>
<p>If you map the length of you interval to <span class="docutils literal">nat</span> using <span class="docutils literal">Z.abs_nat</span>
or <span class="docutils literal">Z.to_nat</span> functions, and use a function deciding if the range is
not-empty with a more informative result type (<span class="docutils literal">Z_lt_dec</span>) then the
solution becomes very simple:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> ZArith Program.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Fixpoint</span> <span class="nf">range</span> (<span class="nv">from</span> <span class="nv">to</span> : Z)
        {<span class="nv">measure</span> (Z.abs_nat (to - from))} : list Z :=
  <span class="kr">if</span> Z_lt_dec <span class="kn">from</span> to
  <span class="kr">then</span> <span class="kn">from</span> :: range (<span class="kn">from</span> + <span class="mi">1</span>) to
  <span class="kr">else</span> [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chk9"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>range</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">from0</span> <span class="nv">to0</span> : Z,
Z.abs_nat (to0 - from0) &lt;
Z.abs_nat (to - <span class="kn">from</span>) -&gt; 
list Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kn">from</span> &lt; to)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs_nat (to - (<span class="kn">from</span> + <span class="mi">1</span>)) &lt; Z.abs_nat (to - <span class="kn">from</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de-v-chka"><span class="nb">apply</span> Zabs_nat_lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>range</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">from0</span> <span class="nv">to0</span> : Z,
Z.abs_nat (to0 - from0) &lt;
Z.abs_nat (to - <span class="kn">from</span>) -&gt; 
list Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kn">from</span> &lt; to)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">0</span> &lt;= to - (<span class="kn">from</span> + <span class="mi">1</span>) &lt; to - <span class="kn">from</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto with</span> zarith.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Using <span class="docutils literal">Z_lt_dec</span> instead of its boolean counter-part gives you the
benefit of propagating the proof of <span class="docutils literal">from &lt; to</span> into the context,
which gives you the ability to deal with the proof obligation easily.</p>
<hr class="docutils" />
<p><strong>A:</strong> <span class="docutils literal">Z_lt_dec</span> is a decision procedure too, but in addition to
marking the result as true or false (which are called <span class="docutils literal">left</span> and
<span class="docutils literal">right</span> respectively) it also attaches a proof to the result. It's
quite suggestively called <span class="docutils literal">sumbool</span> -- once I tried to explain its
usage in <a class="reference external" href="https://stackoverflow.com/a/42313822/2747511">this answer</a> (in its second
half).</p>
</section>
</div>
</main>
</div></body>
</html>
