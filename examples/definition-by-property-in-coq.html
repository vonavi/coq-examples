<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Definition by property in Coq</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="definition-by-property-in-coq">
<h1 class="title">Definition by property in Coq</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/30171995">https://stackoverflow.com/q/30171995</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>I am having trouble with formalizing definitions of the following
form: define an integer such that some property holds.</p>
<p>Let's say that I formalized the definition of the property:</p>
<pre class="code coq literal-block"><code><span class="kn">Definition</span> <span class="nf">IsGood</span> <span class="o">(</span><span class="nv">x</span> <span class="o">:</span> <span class="n">Z</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">...</span></code></pre>
<p>Now I need a definition of the form:</p>
<pre class="code coq literal-block"><code><span class="kn">Definition</span> <span class="nf">Good</span> <span class="o">:</span> <span class="n">Z</span> <span class="o">:=</span> <span class="o">...</span></code></pre>
<p>assuming that I proved that an integer with the property exists and is
unique:</p>
<pre class="code coq literal-block"><code><span class="kn">Lemma</span> <span class="nf">Lemma_GoodExistsUnique</span> <span class="o">:</span> <span class="kr">exists</span><span class="o">!</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Z</span><span class="o">),</span> <span class="n">IsGood</span> <span class="n">x</span><span class="o">.</span></code></pre>
<p>Is there an easy way of defining <span class="docutils literal">Good</span> using <span class="docutils literal">IsGood</span> and
<span class="docutils literal">Lemma_GoodExistsUnique</span>?</p>
<p>Since, the property is defined on integer numbers, it seems that no
additional axioms should be necessary. In any event, I don't see how
adding something like the axiom of choice can help with the
definition.</p>
<p>Also, I am having trouble with formalizing definitions of the
following form (I suspect this is related to the problem I described
above, but please indicate if that is not the case): for every <span class="docutils literal">x</span>,
there exists <span class="docutils literal">y</span>, and these <span class="docutils literal">y</span> are different for different <span class="docutils literal">x</span>.
Like, for example, how to define that there are <span class="docutils literal">N</span> distinct good
integer numbers using <span class="docutils literal">IsGood</span>:</p>
<pre class="code coq literal-block"><code><span class="kn">Definition</span> <span class="nf">ThereAreNGoodIntegers</span> <span class="o">(</span><span class="nv">N</span> <span class="o">:</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="nv">IsGood</span> <span class="o">:</span> <span class="n">Z</span> <span class="o">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="o">...?</span></code></pre>
<p>In real-world mathematics, definitions like that occur every now and
again, so this should not be difficult to formalize if Coq is intended
to be suitable for practical mathematics.</p>
</section>
<section id="answer">
<h2>Answer</h2>
<p>The short answer to your first question is: in general, it is not
possible, but in your particular case, yes.</p>
<p>In Coq's theory, propositions (i.e., <span class="docutils literal">Prop</span>s) and their proofs
have a very special status. In particular, it is in general not
possible to write a choice operator that extracts the witness of an
existence proof. This is done to make the theory compatible with
certain axioms and principles, such as proof irrelevance, which says
that all proofs of a given proposition are equal to each other. If you
want to be able to do this, you need to add this choice operator as an
additional axiom to your theory, as in the <a class="reference external" href="https://coq.inria.fr/distrib/current/stdlib/Coq.Logic.Epsilon.html">standard library</a>.</p>
<p>However, in certain particular cases, it <em>is</em> possible to extract a
witness out of an abstract existence proof without recurring to any
additional axioms. In particular, it is possible to do this for
countable types (such as <span class="docutils literal">Z</span>) when the property in question is
decidable. You can for instance use the <span class="docutils literal">choiceType</span> interface in
the <a class="reference external" href="http://ssr.msr-inria.inria.fr/~jenkins/current/mathcomp.ssreflect.choice.html">Ssreflect</a>
library to get exactly what you want (look for the <span class="docutils literal">xchoose</span>
function).</p>
<p>That being said, I would usually advice <em>against</em> doing things in this
style, because it leads to unnecessary complexity. It is probably
easier to define <span class="docutils literal">Good</span> directly, without resorting to the existence
proof, and then prove separately that <span class="docutils literal">Good</span> has the sought
property.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="definition-by-property-in-coq-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="definition-by-property-in-coq-v-chk0"><span class="kn">Definition</span> <span class="nf">Good</span> : Z. <span class="c">(* ... *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="definition-by-property-in-coq-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="definition-by-property-in-coq-v-chk1"><span class="kn">Definition</span> <span class="nf">IsGood</span> (<span class="nv">z</span> : Z) : <span class="kt">Prop</span>. <span class="c">(* ... *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>z</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="definition-by-property-in-coq-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="definition-by-property-in-coq-v-chk2"><span class="kn">Lemma</span> <span class="nf">GoodIsGood</span> : IsGood Good.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsGood Good</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="definition-by-property-in-coq-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="definition-by-property-in-coq-v-chk3"><span class="kn">Proof</span>. <span class="c">(* ... *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsGood Good</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="definition-by-property-in-coq-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="definition-by-property-in-coq-v-chk4"><span class="kn">Lemma</span> <span class="nf">GoodUnique</span> : <span class="kr">forall</span> <span class="nv">z</span> : Z, IsGood z -&gt; z = Good.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">z</span> : Z, IsGood z -&gt; z = Good</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="definition-by-property-in-coq-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="definition-by-property-in-coq-v-chk5"><span class="kn">Proof</span>. <span class="c">(* ... *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">z</span> : Z, IsGood z -&gt; z = Good</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span></span></pre><p>If you absolutely want to define <span class="docutils literal">Good</span> with an existence proof, you
can also change the proof of <span class="docutils literal">Lemma_GoodExistsUnique</span> to use a
connective in <span class="docutils literal">Type</span> instead of <span class="docutils literal">Prop</span>, since it allows you to
extract the witness directly using the <span class="docutils literal">proj1_sig</span> function:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="definition-by-property-in-coq-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="definition-by-property-in-coq-v-chk6"><span class="kn">Lemma</span> <span class="nf">Lemma_GoodExistsUnique</span> :
  {z : Z | IsGood z /\ <span class="kr">forall</span> <span class="nv">z&#39;</span>, IsGood z&#39; -&gt; z&#39; = z}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">{z : Z
| IsGood z /\ (<span class="kr">forall</span> <span class="nv">z&#39;</span> : Z, IsGood z&#39; -&gt; z&#39; = z)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="definition-by-property-in-coq-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="definition-by-property-in-coq-v-chk7"><span class="kn">Proof</span>. <span class="c">(* ... *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">{z : Z
| IsGood z /\ (<span class="kr">forall</span> <span class="nv">z&#39;</span> : Z, IsGood z&#39; -&gt; z&#39; = z)}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span></span></pre><p>As for your second question, yes, it is a bit related to the first
point. Once again, I would recommend that you write down a function
<span class="docutils literal">y_from_x</span> with type <span class="docutils literal">Z <span class="pre">-&gt;</span> Z</span> that will compute <span class="docutils literal">y</span> given <span class="docutils literal">x</span>,
and then prove separately that this function relates inputs and
outputs in a particular way. Then, you can say that the <span class="docutils literal">y</span>s are
different for different <span class="docutils literal">x</span>s by proving that <span class="docutils literal">y_from_x</span> is
injective.</p>
<p>On the other hand, I'm not sure how your last example relates to this
second question. If I understand what you want to do correctly, you
can write something like</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ThereAreNGoodIntegers</span> (<span class="nv">N</span> : Z) (<span class="nv">IsGood</span> : Z -&gt; <span class="kt">Prop</span>) :=
  <span class="kr">exists</span> <span class="nv">zs</span> : list Z,
    Z.of_nat (length zs) = N
    /\ NoDup zs
    /\ Forall IsGood zs.</span></span></pre><p>Here, <span class="docutils literal">Z.of_nat : nat <span class="pre">-&gt;</span> Z</span> is the canonical injection from naturals
to integers, <span class="docutils literal">NoDup</span> is a predicate asserting that a list doesn't
contain repeated elements, and <span class="docutils literal">Forall</span> is a higher-order predicate
asserting that a given predicate (in this case, <span class="docutils literal">IsGood</span>) holds of
all elements of a list.</p>
<p>As a final note, I would advice against using <span class="docutils literal">Z</span> for things that
can only involve natural numbers. In your example, your using an
integer to talk about the cardinality of a set, and this number is
always a natural number.</p>
</section>
</div>
</main>
</div></body>
</html>
