<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Structural recursion on two arguments</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="structural-recursion-on-two-arguments">
<h1 class="title">Structural recursion on two arguments</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/55704472">https://stackoverflow.com/q/55704472</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>I have tried to make a function in Coq which has a pretty complex
termination argument. To make it easier, I am able to write the
function so that it has a natural number as first argument, so that
either the number or the argument after it is structurally smaller.</p>
<p>When trying the nested fix approach to recursion on two arguments, Coq
complains that a proof argument that contains the semantics of the
decreasing number is not an inductive type.</p>
<p>I could probably do well-founded recursion manually, but I would like
to use <span class="docutils literal">Program Fixpoint</span> or <span class="docutils literal">Equations</span>. With <span class="docutils literal">Program Fixpoint</span> I get a very ugly version of the well-foundedness proof.
Below is a minimal code example that demonstrates the ugliness.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Program.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">tuple_lt</span> : (nat * nat) -&gt; (nat * nat) -&gt; <span class="kt">Prop</span> :=
  fst_lt : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span>, a &lt; c -&gt; tuple_lt (a, b) (c, d).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Fixpoint</span> <span class="nf">f</span> (<span class="nv">a</span> : nat) (<span class="nv">b</span> : nat) {<span class="nv">measure</span> (a, b) tuple_lt} :=
  <span class="kr">match</span> a <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; <span class="mi">0</span>
  | S n =&gt; f n b
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="structural-recursion-on-two-arguments-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="structural-recursion-on-two-arguments-v-chk0"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b0</span> : nat,
tuple_lt (a, b0) (S n, b) -&gt; nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tuple_lt (n, b) (S n, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="structural-recursion-on-two-arguments-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="structural-recursion-on-two-arguments-v-chk1"><span class="nb">apply</span> fst_lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b0</span> : nat,
tuple_lt (a, b0) (S n, b) -&gt; nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; S n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="structural-recursion-on-two-arguments-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="structural-recursion-on-two-arguments-v-chk2"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded
  (MR tuple_lt
     (<span class="kr">fun</span> <span class="nv">recarg</span> : {_ : nat &amp; nat} =&gt;
      (projT1 recarg, projT2 recarg)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="structural-recursion-on-two-arguments-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="structural-recursion-on-two-arguments-v-chk3"><span class="nb">unfold</span> well_founded.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : {_ : nat &amp; nat},
Acc
  (MR tuple_lt
     (<span class="kr">fun</span> <span class="nv">recarg</span> : {_ : nat &amp; nat} =&gt;
      (projT1 recarg, projT2 recarg))) a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="structural-recursion-on-two-arguments-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="structural-recursion-on-two-arguments-v-chk4"><span class="nb">unfold</span> MR.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : {_ : nat &amp; nat},
Acc
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : {_ : nat &amp; nat} =&gt;
   tuple_lt (projT1 x, projT2 x) (projT1 y, projT2 y))
  a</div></blockquote></div></div></small></span></pre><p>The obligation looks like this:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="structural-recursion-on-two-arguments-v-chk5" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">1</span> subgoal

  ============================
  <span class="kr">forall</span> <span class="nv">a</span> : {_ : nat &amp; nat},
  Acc
    (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : {_ : nat &amp; nat} =&gt;
     tuple_lt (projT1 x, projT2 x)
       (projT1 y, projT2 y)) a</blockquote></div></div></small></span></pre><p>Can I somehow transform a proof of <span class="docutils literal">Acc tuple_lt</span> into that ugly
proof or avoid generating it?</p>
<p>Is there a proof in the standard library for structural recursion on
two arguments?</p>
<p>How do I even write a manual WF proof using <span class="docutils literal">Equations</span>? The manual
does not mention that.</p>
</section>
<section id="answer">
<h2>Answer</h2>
<p>In simple cases like this one, you shouldn't have to unfold
definitions such as <span class="docutils literal">well_founded</span> and <span class="docutils literal">MR</span>, but rather use
appropriate lemmas.</p>
<p>To deal with <span class="docutils literal">MR</span>, you can use lemma <span class="docutils literal">measure_wf</span> in
<span class="docutils literal">Program.Wf</span>.</p>
<p>To prove the well-foundedness of <span class="docutils literal">tuple_lt</span>, you can rely on lemmas
showing the well-foundedness of a relation based on the
well-foundedness of another relation. Here, we can use
<span class="docutils literal">well_founded_lt_compat</span>. In other cases, you may find other lemmas
useful, such as <span class="docutils literal">wf_inverse_image</span>, <span class="docutils literal">well_founded_ltof</span> or
<span class="docutils literal">well_founded_gtof</span>.</p>
<p>The proof of the well-foundedness of <span class="docutils literal">tuple_lt</span> becomes simple.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="structural-recursion-on-two-arguments-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="structural-recursion-on-two-arguments-v-chk6"><span class="kn">Lemma</span> <span class="nf">tuple_lt_wf</span> : well_founded tuple_lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded tuple_lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="structural-recursion-on-two-arguments-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="structural-recursion-on-two-arguments-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded tuple_lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="structural-recursion-on-two-arguments-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="structural-recursion-on-two-arguments-v-chk8"><span class="nb">apply</span> well_founded_lt_compat <span class="kr">with</span> fst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : nat * nat, tuple_lt x y -&gt; fst x &lt; fst y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? ? []; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>And so does the proof of the second obligation.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="structural-recursion-on-two-arguments-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="structural-recursion-on-two-arguments-v-chk9"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded
  (MR tuple_lt
     (<span class="kr">fun</span> <span class="nv">recarg</span> : {_ : nat &amp; nat} =&gt;
      (projT1 recarg, projT2 recarg)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="structural-recursion-on-two-arguments-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="structural-recursion-on-two-arguments-v-chka"><span class="nb">apply</span> measure_wf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded tuple_lt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> tuple_lt_wf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>(Note that in both cases, you should end the proofs with <span class="docutils literal">Defined</span>
instead of <span class="docutils literal">Qed</span>, if you want your function defined by <span class="docutils literal">Program Fixpoint</span> to compute inside Coq (otherwise it gets stuck on opaque
proofs); it seems that you can end the proof of the first obligation
with <span class="docutils literal">Qed</span>, though).</p>
<p>You could also use the following simpler definition for <span class="docutils literal">tuple_lt</span>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">tuple_lt</span> (<span class="nv">p1</span> <span class="nv">p2</span> : nat * nat) := fst p1 &lt; fst p2.</span></span></pre><p>In that case, the proof of well-foundedness is trivial.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="structural-recursion-on-two-arguments-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="structural-recursion-on-two-arguments-v-chkb"><span class="kn">Lemma</span> <span class="nf">tuple_lt_wf</span> : well_founded tuple_lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded tuple_lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="structural-recursion-on-two-arguments-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="structural-recursion-on-two-arguments-v-chkc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded tuple_lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> well_founded_ltof.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre></section>
</div>
</main>
</div></body>
</html>
