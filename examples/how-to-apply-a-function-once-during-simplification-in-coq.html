<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>How to apply a function once during simplification in Coq?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="how-to-apply-a-function-once-during-simplification-in-coq">
<h1 class="title">How to apply a function once during simplification in Coq?</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/33060802">https://stackoverflow.com/q/33060802</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>From what I understand, function calls in Coq are opaque. Sometimes, I
need to use <span class="docutils literal">unfold</span> to apply it and then <span class="docutils literal">fold</span> to turn the
function definition/body back to its name. This is often tedious. My
question is, is there an easier way to let apply a specific instance
of a function call?</p>
<p>As a minimal example, for a list <span class="docutils literal">l</span>, to prove right-appending
<span class="docutils literal">[]</span> does not change <span class="docutils literal">l</span>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-apply-a-function-once-during-simplification-in-coq-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-apply-a-function-once-during-simplification-in-coq-v-chk0"><span class="kn">Theorem</span> <span class="nf">nil_right_app</span> : <span class="kr">forall</span> {<span class="nv">Y</span>} (<span class="nv">l</span> : list Y), l ++ [] = l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list Y), l ++ [] = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-apply-a-function-once-during-simplification-in-coq-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-apply-a-function-once-during-simplification-in-coq-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list Y), l ++ [] = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-apply-a-function-once-during-simplification-in-coq-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-apply-a-function-once-during-simplification-in-coq-v-chk2"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] ++ [] = []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-apply-a-function-once-during-simplification-in-coq-v-chk3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Y</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>l ++ [] = l</span></span></span><br></div><label class="goal-separator" for="how-to-apply-a-function-once-during-simplification-in-coq-v-chk3"><hr></label><div class="goal-conclusion">(a :: l) ++ [] = a :: l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-apply-a-function-once-during-simplification-in-coq-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-apply-a-function-once-during-simplification-in-coq-v-chk4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] ++ [] = []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span></span></pre><p>This leaves:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-apply-a-function-once-during-simplification-in-coq-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-apply-a-function-once-during-simplification-in-coq-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Y</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>l ++ [] = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a :: l) ++ [] = a :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-to-apply-a-function-once-during-simplification-in-coq-v-chk6" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">1</span> subgoal

  Y : <span class="kt">Type</span>
  a : Y
  l : list Y
  IHl : l ++ [] = l
  ============================
  (a :: l) ++ [] = a :: l</blockquote></div></div></small></span></pre><p>Now, I need to apply the definition of <span class="docutils literal">++</span> (i.e. <span class="docutils literal">app</span>) once
(pretending there are other <span class="docutils literal">++</span> in the goal which I don't want to
apply/expand). Currently, the only way I know to implement this one
time application is to first unfold <span class="docutils literal">++</span> and then fold it:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-apply-a-function-once-during-simplification-in-coq-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-apply-a-function-once-during-simplification-in-coq-v-chk7"><span class="nb">unfold</span> app <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Y</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>l ++ [] = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a
:: (<span class="kr">fix</span> app (l m : list Y) {<span class="kr">struct</span> l} : list Y :=
      <span class="kr">match</span> l <span class="kr">with</span>
      | [] =&gt; m
      | a :: l1 =&gt; a :: app l1 m
      <span class="kr">end</span>) l [] = a :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-apply-a-function-once-during-simplification-in-coq-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-apply-a-function-once-during-simplification-in-coq-v-chk8"><span class="nb">fold</span> (app l []).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Y</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>l ++ [] = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: l ++ [] = a :: l</div></blockquote></div></div></small></span></pre><p>giving:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-to-apply-a-function-once-during-simplification-in-coq-v-chk9" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">1</span> subgoal

  Y : <span class="kt">Type</span>
  a : Y
  l : list Y
  IHl : l ++ [] = l
  ============================
  a :: l ++ [] = a :: l</blockquote></div></div></small></span></pre><p>But this is inconvenient as I have to figure out the form of the term
to use in <span class="docutils literal">fold</span>. I did the computation, not Coq. My question boils
down to:</p>
<p>Is there a simpler way to implement this one-time function application
to the same effect?</p>
<hr class="docutils" />
<p><strong>A:</strong> All Coq's definition are not opaque, but there are ways to
prevent Coq from unfolding a definition automatically (e.g. using
<span class="docutils literal">Qed</span> instead of <span class="docutils literal">Defined</span> when defining a function using
tactics).</p>
</section>
<section id="answer">
<h2>Answer</h2>
<p>You can use <span class="docutils literal">simpl</span>, <span class="docutils literal">compute</span> or <span class="docutils literal">vm_compute</span> if you want to
ask Coq to perform some computation for you. If the definition of the
function is <span class="docutils literal">Opaque</span>, the above solution will fail, but you could
first prove a rewriting lemma such as:</p>
<pre class="code coq literal-block"><code><span class="kr">forall</span> <span class="o">(</span><span class="nv">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="nv">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="nv">l1</span> <span class="nv">l2</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">),</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">l1</span><span class="o">)</span> <span class="o">++</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">a</span> <span class="o">::</span> <span class="o">(</span><span class="n">l1</span> <span class="o">++</span> <span class="n">l2</span><span class="o">).</span></code></pre>
<p>using your technique, and then <span class="docutils literal">rewrite</span> with it when necessary.</p>
<p>Here is an example using <span class="docutils literal">simpl</span>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-apply-a-function-once-during-simplification-in-coq-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-apply-a-function-once-during-simplification-in-coq-v-chka"><span class="kn">Theorem</span> <span class="nf">nil_right_app</span> : <span class="kr">forall</span> {<span class="nv">Y</span>} (<span class="nv">l</span> : list Y), l ++ nil = l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list Y), l ++ [] = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-apply-a-function-once-during-simplification-in-coq-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-apply-a-function-once-during-simplification-in-coq-v-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list Y), l ++ [] = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* solve the first case directly *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-apply-a-function-once-during-simplification-in-coq-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-apply-a-function-once-during-simplification-in-coq-v-chkc"><span class="nb">intros</span> Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list Y, l ++ [] = l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-apply-a-function-once-during-simplification-in-coq-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-apply-a-function-once-during-simplification-in-coq-v-chkd"><span class="nb">induction</span> l <span class="kr">as</span> [| hd tl hi]; [<span class="bp">reflexivity</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>hd</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>tl</var><span class="hyp-type"><b>: </b><span>list Y</span></span></span><br><span><var>hi</var><span class="hyp-type"><b>: </b><span>tl ++ [] = tl</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(hd :: tl) ++ [] = hd :: tl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-apply-a-function-once-during-simplification-in-coq-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-apply-a-function-once-during-simplification-in-coq-v-chke"><span class="nb">simpl</span> app. <span class="c">(* or simply &quot;simpl.&quot; *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>hd</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>tl</var><span class="hyp-type"><b>: </b><span>list Y</span></span></span><br><span><var>hi</var><span class="hyp-type"><b>: </b><span>tl ++ [] = tl</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hd :: tl ++ [] = hd :: tl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-apply-a-function-once-during-simplification-in-coq-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-apply-a-function-once-during-simplification-in-coq-v-chkf"><span class="nb">rewrite</span> hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>hd</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>tl</var><span class="hyp-type"><b>: </b><span>list Y</span></span></span><br><span><var>hi</var><span class="hyp-type"><b>: </b><span>tl ++ [] = tl</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hd :: tl = hd :: tl</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>To answer your comment, I don't know how to tell <span class="docutils literal">cbv</span> or
<span class="docutils literal">compute</span> to only compute a certain symbol. Note that in your case,
they seem to compute too eagerly and <span class="docutils literal">simpl</span> works better.</p>
</section>
</div>
</main>
</div></body>
</html>
