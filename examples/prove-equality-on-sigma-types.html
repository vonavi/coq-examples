<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>Prove equality on Sigma-types</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="prove-equality-on-sigma-types">
<h1 class="title">Prove equality on Sigma-types</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/27079513">https://stackoverflow.com/q/27079513</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>I have defined a Sygma-Type that looks like:</p>
<pre class="code coq literal-block">
<span class="o">{</span> <span class="n">R</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">-&gt;</span> <span class="n">nat</span> <span class="o">-&gt;</span> <span class="n">bool</span> <span class="o">|</span> <span class="n">Reflexive</span> <span class="n">R</span> <span class="o">}</span>
</pre>
<p>I have two elements <tt class="docutils literal">r1 r2 : { R : nat <span class="pre">-&gt;</span> nat <span class="pre">-&gt;</span> bool | Reflexive R
}</tt> and I am to prove <tt class="docutils literal">r1 = r2</tt>. How can I do that?</p>
</div>
<div class="section" id="answer">
<h1>Answer</h1>
<p>If you want to show such an equality, you need to (1) show that the
underlying functions are equal (i.e., the <tt class="docutils literal">R</tt> component of your
sigma type), and (2) show that the corresponding proofs are equal.
There are two problems, however.</p>
<p>The first one is that equality of functions is too weak in Coq.
According to common mathematical practice, we expect two functions to
be equal if they yield equal results for any inputs. This principle is
known as <em>functional extensionality</em>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">functional_extensionality</span> :
  <span class="kr">forall</span> <span class="nv">A</span> (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span>, B a),
    (<span class="kr">forall</span> <span class="nv">x</span>, f x = g x) -&gt; f = g.</span></span></pre><p>As natural as it sounds, however, this principle is not provable in
Coq's logic! Roughly speaking, the only way two functions can be equal
is if they can be converted to a syntactically equal terms according
to the computation rules of the logic. For instance, we can show that
<tt class="docutils literal">fun n : nat =&gt; 0 + n</tt> and <tt class="docutils literal">fun n : nat =&gt; n</tt> are equal because
<tt class="docutils literal">+</tt> is defined in Coq by pattern-matching on the first argument, and
the first argument on the first term is <tt class="docutils literal">0</tt>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="prove-equality-on-sigma-types-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="prove-equality-on-sigma-types-v-chk0"><span class="kn">Goal</span> (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; <span class="mi">0</span> + n) = (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; <span class="mi">0</span> + n) = (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>We could expect to show that <tt class="docutils literal">fun n =&gt; n + 0</tt> and <tt class="docutils literal">fun n =&gt; n</tt> are
equal by similar means. However, Coq does not accept this, because
<tt class="docutils literal">+</tt> cannot be simplified when the first argument is a variable.</p>
<p>The other problem is that the notion of equality on proofs is not very
interesting as well. The only way one can show that two proofs are
equal is, again, syntactic equality. Intuitively, however, one would
like to argue by <em>proof irrelevance</em>, a principle that states that
proofs of the same thing are always equal:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">proof_irrelevance</span> :
  <span class="kr">forall</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> <span class="nv">q</span> : P), p = q.</span></span></pre><p>but, again, this principle is not provable in the logic. Fortunately,
Coq's logic was designed to allow one to add these principles as
axioms in a sound way. One then gets the following proof:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">functional_extensionality</span> :
  <span class="kr">forall</span> <span class="nv">A</span> (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span>, B a),
    (<span class="kr">forall</span> <span class="nv">a</span>, f a = g a) -&gt; f = g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">proof_irrelevance</span> :
  <span class="kr">forall</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> <span class="nv">q</span> : P), p = q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prove-equality-on-sigma-types-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="prove-equality-on-sigma-types-v-chk1"><span class="kn">Lemma</span> <span class="nf">l</span> (<span class="nv">r1</span> <span class="nv">r2</span> : { R : nat -&gt; nat -&gt; bool | <span class="kr">forall</span> <span class="nv">n</span>, R n n = true }) :
  (<span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span>, proj1_sig r1 n1 n2 = proj1_sig r2 n1 n2) -&gt;
  r1 = r2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>{R : nat -&gt; nat -&gt; bool
| <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat,
 proj1_sig r1 n1 n2 = proj1_sig r2 n1 n2) -&gt; r1 = r2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prove-equality-on-sigma-types-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="prove-equality-on-sigma-types-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>{R : nat -&gt; nat -&gt; bool
| <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat,
 proj1_sig r1 n1 n2 = proj1_sig r2 n1 n2) -&gt; r1 = r2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prove-equality-on-sigma-types-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="prove-equality-on-sigma-types-v-chk3"><span class="nb">destruct</span> r1 <span class="kr">as</span> [r1 H1], r2 <span class="kr">as</span> [r2 H2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r1 n n = true</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r2 n n = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat,
 proj1_sig
   (exist
      (<span class="kr">fun</span> <span class="nv">R</span> : nat -&gt; nat -&gt; bool =&gt;
       <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true) r1 H1) n1 n2 =
 proj1_sig
   (exist
      (<span class="kr">fun</span> <span class="nv">R</span> : nat -&gt; nat -&gt; bool =&gt;
       <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true) r2 H2) n1 n2) -&gt;
exist
  (<span class="kr">fun</span> <span class="nv">R</span> : nat -&gt; nat -&gt; bool =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true) r1 H1 =
exist
  (<span class="kr">fun</span> <span class="nv">R</span> : nat -&gt; nat -&gt; bool =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true) r2 H2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prove-equality-on-sigma-types-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="prove-equality-on-sigma-types-v-chk4"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r1 n n = true</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r2 n n = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat, r1 n1 n2 = r2 n1 n2) -&gt;
exist
  (<span class="kr">fun</span> <span class="nv">R</span> : nat -&gt; nat -&gt; bool =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true) r1 H1 =
exist
  (<span class="kr">fun</span> <span class="nv">R</span> : nat -&gt; nat -&gt; bool =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true) r2 H2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prove-equality-on-sigma-types-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="prove-equality-on-sigma-types-v-chk5"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r1 n n = true</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r2 n n = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat, r1 n1 n2 = r2 n1 n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">exist
  (<span class="kr">fun</span> <span class="nv">R</span> : nat -&gt; nat -&gt; bool =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true) r1 H1 =
exist
  (<span class="kr">fun</span> <span class="nv">R</span> : nat -&gt; nat -&gt; bool =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true) r2 H2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prove-equality-on-sigma-types-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="prove-equality-on-sigma-types-v-chk6"><span class="nb">assert</span> (H&#39; : r1 = r2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r1 n n = true</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r2 n n = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat, r1 n1 n2 = r2 n1 n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r1 = r2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="prove-equality-on-sigma-types-v-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r1 n n = true</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r2 n n = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat, r1 n1 n2 = r2 n1 n2</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>r1 = r2</span></span></span><br></div><label class="goal-separator" for="prove-equality-on-sigma-types-v-chk7"><hr></label><div class="goal-conclusion">exist
  (<span class="kr">fun</span> <span class="nv">R</span> : nat -&gt; nat -&gt; bool =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true) r1 H1 =
exist
  (<span class="kr">fun</span> <span class="nv">R</span> : nat -&gt; nat -&gt; bool =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true) r2 H2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prove-equality-on-sigma-types-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="prove-equality-on-sigma-types-v-chk8">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r1 n n = true</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r2 n n = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat, r1 n1 n2 = r2 n1 n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r1 = r2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prove-equality-on-sigma-types-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="prove-equality-on-sigma-types-v-chk9"><span class="nb">apply</span> functional_extensionality.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r1 n n = true</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r2 n n = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat, r1 n1 n2 = r2 n1 n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : nat, r1 a = r2 a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prove-equality-on-sigma-types-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="prove-equality-on-sigma-types-v-chka"><span class="nb">intros</span> n1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r1 n n = true</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r2 n n = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat, r1 n1 n2 = r2 n1 n2</span></span></span><br><span><var>n1</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r1 n1 = r2 n1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prove-equality-on-sigma-types-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="prove-equality-on-sigma-types-v-chkb"><span class="nb">apply</span> functional_extensionality.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r1 n n = true</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r2 n n = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat, r1 n1 n2 = r2 n1 n2</span></span></span><br><span><var>n1</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : nat, r1 n1 a = r2 n1 a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prove-equality-on-sigma-types-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="prove-equality-on-sigma-types-v-chkc"><span class="nb">intros</span> n2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r1 n n = true</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r2 n n = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat, r1 n1 n2 = r2 n1 n2</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r1 n1 n2 = r2 n1 n2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prove-equality-on-sigma-types-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="prove-equality-on-sigma-types-v-chkd">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r1 n n = true</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r2 n n = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat, r1 n1 n2 = r2 n1 n2</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>r1 = r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">exist
  (<span class="kr">fun</span> <span class="nv">R</span> : nat -&gt; nat -&gt; bool =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true) r1 H1 =
exist
  (<span class="kr">fun</span> <span class="nv">R</span> : nat -&gt; nat -&gt; bool =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true) r2 H2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prove-equality-on-sigma-types-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="prove-equality-on-sigma-types-v-chke">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r1 n n = true</span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r2 n n = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat, r1 n1 n2 = r2 n1 n2</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>r1 = r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">exist
  (<span class="kr">fun</span> <span class="nv">R</span> : nat -&gt; nat -&gt; bool =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true) r1 H1 =
exist
  (<span class="kr">fun</span> <span class="nv">R</span> : nat -&gt; nat -&gt; bool =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true) r2 H2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prove-equality-on-sigma-types-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="prove-equality-on-sigma-types-v-chkf"><span class="nb">subst</span> r2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r1 n n = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat, r1 n1 n2 = r1 n1 n2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r1 n n = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">exist
  (<span class="kr">fun</span> <span class="nv">R</span> : nat -&gt; nat -&gt; bool =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true) r1 H1 =
exist
  (<span class="kr">fun</span> <span class="nv">R</span> : nat -&gt; nat -&gt; bool =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true) r1 H2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prove-equality-on-sigma-types-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="prove-equality-on-sigma-types-v-chk10"><span class="nb">rename</span> r1 <span class="nb">into</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r n n = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat, r n1 n2 = r n1 n2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r n n = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">exist
  (<span class="kr">fun</span> <span class="nv">R</span> : nat -&gt; nat -&gt; bool =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true) r H1 =
exist
  (<span class="kr">fun</span> <span class="nv">R</span> : nat -&gt; nat -&gt; bool =&gt;
   <span class="kr">forall</span> <span class="nv">n</span> : nat, R n n = true) r H2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="prove-equality-on-sigma-types-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="prove-equality-on-sigma-types-v-chk11"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; bool</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r n n = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat, r n1 n2 = r n1 n2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r n n = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H1 = H2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> proof_irrelevance.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Even though axioms can be useful, one might like to avoid them. In
this case, it is actually possible to prove this lemma just with
functional extensionality, but you do need at least that. If you want
to avoid using axioms, and <tt class="docutils literal">r1</tt> and <tt class="docutils literal">r2</tt> are <em>not</em> equal up to
computation, you'll have to use a difference equivalence relation on
your type, and do your formalization using that relation instead, e.g.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rel_equiv</span>
           (<span class="nv">r1</span> <span class="nv">r2</span> : { R : nat -&gt; nat -&gt; bool | <span class="kr">forall</span> <span class="nv">n</span>, R n n = true }) : <span class="kt">Prop</span>
  := <span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span>, proj1_sig r1 n1 n2 = proj1_sig r2 n1 n2.</span></span></pre><p>The <a class="reference external" href="http://coq.inria.fr/">standard library</a> has good support for
rewriting with equivalence relations; cf. for instance <a class="reference external" href="https://coq.inria.fr/distrib/current/stdlib/Coq.Classes.SetoidClass.html">this</a>.</p>
<hr class="docutils" />
<p><strong>A:</strong> I wouldn't say, e.g., <tt class="docutils literal">(fun x : nat =&gt; x)</tt> and <tt class="docutils literal">(fun f =&gt; f)
(fun x : nat =&gt; x)</tt> are <em>syntactically</em> equal, but in Coq they are
equal. Perhaps it'd be better to replace &quot;syntactically&quot; with
&quot;definitionally&quot; or &quot;up to computation&quot;?</p>
<p><strong>A:</strong> The <tt class="docutils literal">l</tt> lemma can also be proved using the unicity of
equality proofs (UIP) axiom, which is <em>weaker</em> than the proof
irrelevance axiom. The modification is simple: we need to introduce</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">UIP</span> : <span class="kr">forall</span> <span class="nv">A</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">p1</span> <span class="nv">p2</span> : x = y), p1 = p2.</span></span></pre><p>and change <tt class="docutils literal">apply proof_irrelevance.</tt> at the end of the proof into
<tt class="docutils literal">apply functional_extensionality; intros; apply UIP.</tt></p>
<p><strong>A:</strong> On the first reading I missed your comment on the possibility
of proving this special case without proof irrelevance (or UIP). Since
<tt class="docutils literal">bool</tt> is a type with decidable equality, we can use
<tt class="docutils literal">UIP_refl_bool</tt> from <tt class="docutils literal">Eqdep_dec</tt> module to finish the proof:
<tt class="docutils literal">apply functional_extensionality; intro. destruct (H2 _). apply
UIP_refl_bool.</tt></p>
</div>
</div>
</div>
</div></body>
</html>
