<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Compute with a recursive function defined by well-defined induction</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="compute-with-a-recursive-function-defined-by-well-defined-induction">
<h1 class="title">Compute with a recursive function defined by well-defined induction</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/32354286">https://stackoverflow.com/q/32354286</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>When I use <span class="docutils literal">Function</span> to define a non-structurally recursive
function in Coq, the resulting object behaves strangely when a
specific computation is asked. Indeed, instead of giving directly the
result, the <span class="docutils literal">Eval compute in ...</span> directive return a rather long
(typically 170 000 lines) expression. It seems that Coq cannot
evaluate everything, and therefore returns a simplified (but long)
expression instead of just a value.</p>
<p>The problem seems to come from the way I prove the obligations
generated by <span class="docutils literal">Function</span>. First, I thought the problem came from the
opaque terms I used, and I converted all the lemmas to transparent
constants. By the way, is there a way to list the opaque terms
appearing in a term? Or any other way to turn opaque lemmas into
transparent ones?</p>
<p>I then remarked that the problem came more precisely from the proof
that the order used is well-founded. But I got strange results.</p>
<p>For example, I define <span class="docutils literal">log2</span> on the natural numbers by repeatedly
applying <span class="docutils literal">div2</span>. Here is the definition:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk0"><span class="kn">Function</span> <span class="nf">log2</span> n {<span class="kn">wf</span> lt n} :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; <span class="mi">0</span>
  | <span class="mi">1</span> =&gt; <span class="mi">0</span>
  | n =&gt; S (log2 (Nat.div2 n))
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">n0</span> <span class="nv">n1</span> : nat,
n0 = S n1 -&gt;
n = S (S n1) -&gt; Nat.div2 (S (S n1)) &lt; S (S n1)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></div></small></span></pre><p>I get two proof obligations. The first one checks that <span class="docutils literal">n</span> respects
the relation <span class="docutils literal">lt</span> in the recursive calls and can be proved easily.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">n0</span> <span class="nv">n1</span> : nat,
n0 = S n1 -&gt;
n = S (S n1) -&gt; Nat.div2 (S (S n1)) &lt; S (S n1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">1</span> subgoal

  ============================
  <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">n0</span> <span class="nv">n1</span> : nat,
  n0 = S n1 -&gt;
  n = S (S n1) -&gt; Nat.div2 (S (S n1)) &lt; S (S n1)</blockquote></div></div></small></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, n0, n1</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>teq0</var><span class="hyp-type"><b>: </b><span>n0 = S n1</span></span></span><br><span><var>teq</var><span class="hyp-type"><b>: </b><span>n = S (S n1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.div2 (S (S n1)) &lt; S (S n1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Nat.lt_div2, le_n_S, le_0_n.</span></span></pre><p>The second one checks that <span class="docutils literal">lt</span> is a well-founded order. This is
already proved in the standard library. The corresponding lemma is
<span class="docutils literal">Coq.Arith.Wf_nat.lt_wf</span>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Wf_nat.lt_wf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>If I use this proof, the resulting function behaves normally.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk5"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> log2 <span class="mi">10</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="mi">3</span>
: nat</blockquote></div></div></small></span></pre><p>But if I want to do the proof myself, I do not always get this
behaviour. First, if I end the proof with <span class="docutils literal">Qed</span> instead of
<span class="docutils literal">Defined</span>, the result of the computation (even on small numbers) is
a complex expression and not a single number. So I use <span class="docutils literal">Defined</span> and
try to use only transparent lemmas.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk6"><span class="kn">Lemma</span> <span class="nf">lt_wf2</span> : well_founded lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk8"><span class="nb">unfold</span> well_founded.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : nat, Acc lt a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk9"><span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chka"><span class="nb">apply</span> (lemma1 n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; Acc lt p) -&gt; Acc lt n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chkb"><span class="nb">clear</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; Acc lt p) -&gt; Acc lt n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chkc"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; Acc lt p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chkd"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; Acc lt p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : nat, y &lt; n -&gt; Acc lt y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>Here, <span class="docutils literal">lemma1</span> is a proof of the well-founded induction on the
natural numbers. Here again, I can use already existing lemmas, such
as <span class="docutils literal">lt_wf_ind</span>, <span class="docutils literal">lt_wf_rec</span>, <span class="docutils literal">lt_wf_rec1</span> located in
<span class="docutils literal">Coq.Arith.Wf_nat</span>, or even <span class="docutils literal">well_founded_ind lt_wf</span>. The first
one does not work, it seems this is because it is opaque. The three
others work.</p>
<p>I tried to prove it directly using the standard induction on the
natural numbers, <span class="docutils literal">nat_ind</span>. This gives:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chke"><span class="kn">Lemma</span> <span class="nf">lemma1</span> : <span class="kr">forall</span> <span class="nv">n</span> (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>),
    (<span class="kr">forall</span> <span class="nv">n</span>, (<span class="kr">forall</span> <span class="nv">p</span>, p &lt; n -&gt; P p) -&gt; P n) -&gt; P n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>),
(<span class="kr">forall</span> <span class="nv">n0</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p) -&gt; P n0) -&gt; P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chkf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>),
(<span class="kr">forall</span> <span class="nv">n0</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p) -&gt; P n0) -&gt; P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk10"><span class="nb">intros</span> n P H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk11"><span class="nb">pose proof</span> (nat_ind (<span class="kr">fun</span> <span class="nv">n</span> =&gt; <span class="kr">forall</span> <span class="nv">p</span>, p &lt; n -&gt; P p)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) <span class="mi">0</span> -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p)
   n -&gt;
 (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p)
   (S n)) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk12"><span class="nb">simpl</span> <span class="kr">in</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk13"><span class="nb">apply</span> H0 <span class="kr">with</span> (n:=S n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk14"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p</div></blockquote><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk15" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk15"><hr></label><div class="goal-conclusion">n &lt; S n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk16">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk17"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>p &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> H1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk18">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk19"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; S n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1a"><span class="nb">inversion</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; S n0</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>p = n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; S n0</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>S p &lt;= n0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>m = n0</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1b"><hr></label><div class="goal-conclusion">P p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; S n0</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>p = n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1d"><span class="nb">apply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; S n0</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>p = n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; S n0</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>S p &lt;= n0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>m = n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1f"><span class="nb">apply</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; S n0</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>S p &lt;= n0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>m = n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p &lt; n0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk20">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; S n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> le_n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>With this proof (and some variants of it), <span class="docutils literal">log2</span> has the same
strange behaviour. And this proof seems to use only transparent
objects, so maybe the problem is not there.</p>
<p>How can I define a <span class="docutils literal">Function</span> that returns understandable results on
specific values?</p>
<hr class="docutils" />
<p><strong>A:</strong> <span class="docutils literal">Print Opaque Dependencies log2</span> can be used to list the
opaque terms used in <span class="docutils literal">log2</span>.</p>
</section>
<section id="answer-anton-trunov">
<h2>Answer (Anton Trunov)</h2>
<p>I've managed to pin-point the place that causes troubles: it's
<span class="docutils literal">inversion H2.</span> in <span class="docutils literal">lemma1</span>. It turns out we don't need that
case-analysis and <span class="docutils literal">intuition</span> can finish the proof (it doesn't
pattern-match on <span class="docutils literal">H2</span>):</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk21"><span class="kn">Lemma</span> <span class="nf">lemma1</span> : <span class="kr">forall</span> <span class="nv">n</span> (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>),
    (<span class="kr">forall</span> <span class="nv">n</span>, (<span class="kr">forall</span> <span class="nv">p</span>, p &lt; n -&gt; P p) -&gt; P n) -&gt; P n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>),
(<span class="kr">forall</span> <span class="nv">n0</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p) -&gt; P n0) -&gt; P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>),
(<span class="kr">forall</span> <span class="nv">n0</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p) -&gt; P n0) -&gt; P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk23"><span class="nb">intros</span> n P H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk24"><span class="nb">pose proof</span> (nat_ind (<span class="kr">fun</span> <span class="nv">n</span> =&gt; <span class="kr">forall</span> <span class="nv">p</span>, p &lt; n -&gt; P p)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) <span class="mi">0</span> -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p)
   n -&gt;
 (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p)
   (S n)) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk25"><span class="nb">simpl</span> <span class="kr">in</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk26"><span class="nb">apply</span> H0 <span class="kr">with</span> (n:=S n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk27" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk27"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p</div></blockquote><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk28"><hr></label><div class="goal-conclusion">n &lt; S n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk29">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>p &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> H1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; S n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2d"><span class="nb">apply</span> Lt.lt_n_Sm_le, Nat.lt_eq_cases <span class="kr">in</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; n0 \/ p = n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2e"><span class="nb">destruct</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p = n0</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2f"><hr></label><div class="goal-conclusion">P p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk30">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> H1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk31">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p = n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk32"><span class="nb">subst</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk33">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; S n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> le_n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>If we use <span class="docutils literal">lemma1</span> with this proof, the computation of <span class="docutils literal">log2 10</span>
results in <span class="docutils literal">3</span>.</p>
<p>By the way, here is my version of <span class="docutils literal">lt_wf2</span> (it lets us compute as
well):</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk34"><span class="kn">Lemma</span> <span class="nf">lt_wf2</span> : well_founded lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk35"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk36"><span class="nb">unfold</span> well_founded.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : nat, Acc lt a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk37"><span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk38"><span class="nb">induction</span> n; <span class="nb">constructor</span>; <span class="nb">intros</span> k Hk.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk39" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S n</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk39"><hr></label><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> Hk.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3c"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : nat, y &lt; k -&gt; Acc lt y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3d"><span class="nb">intros</span> m Hm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S n</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hm</var><span class="hyp-type"><b>: </b><span>m &lt; k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3e"><span class="nb">apply</span> IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S n</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hm</var><span class="hyp-type"><b>: </b><span>m &lt; k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m &lt; n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* OR: apply IHn, Nat.lt_le_trans with (m := k); auto with arith. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>I believe the <a class="reference external" href="http://gallium.inria.fr/blog/coq-eval/">Using Coq's evaluation mechanisms in anger</a> blog post by Xavier Leroy
explains this kind of behavior.</p>
<blockquote>
<p>it eliminates the proof of equality between the heads before
recursing over the tails and finally deciding whether to produce a
left or a right. This makes the left/right data part of the final
result dependent on a proof term, which in general does not
reduce!</p>
</blockquote>
<p>In our case we eliminate the proof of inequality (<span class="docutils literal">inversion H2.</span>)
in the proof of <span class="docutils literal">lemma1</span> and the <span class="docutils literal">Function</span> mechanism makes our
computations depend on a proof term. Hence, the evaluator can't
proceed when <span class="docutils literal">n &gt; 1</span>.</p>
<p>And the reason <span class="docutils literal">inversion H1.</span> in the body of the lemma doesn't
influence computations is that for <span class="docutils literal">n = 0</span> and <span class="docutils literal">n = 1</span>, <span class="docutils literal">log2 n</span>
is defined within the <span class="docutils literal">match</span> expression as base cases.</p>
<p>To illustrate this point, let me show an example when we can prevent
evaluation of <span class="docutils literal">log2 n</span> on any values <span class="docutils literal">n</span> and <span class="docutils literal">n + 1</span> of our
choice, where <span class="docutils literal">n &gt; 1</span> and <em>nowhere else</em>!</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3f"><span class="kn">Lemma</span> <span class="nf">lt_wf2&#39;</span> : well_founded lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk40"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk41"><span class="nb">unfold</span> well_founded.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : nat, Acc lt a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk42"><span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk43"><span class="nb">induction</span> n; <span class="nb">constructor</span>; <span class="nb">intros</span> k Hk.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk44" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S n</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk44"><hr></label><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk45">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> Hk.          <span class="c">(* n = 0 *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk46">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk47"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt <span class="mi">0</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk48" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt (S n)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S (S n)</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk48"><hr></label><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk49"><span class="nb">intuition</span>. <span class="c">(* n = 1 *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt (S n)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S (S n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4a"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt <span class="mi">1</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; <span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt (S (S n))</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S (S (S n))</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4b"><hr></label><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4c"><span class="nb">intuition</span>. <span class="c">(* n = 2 *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt (S (S n))</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S (S (S n))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4d"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt <span class="mi">2</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; <span class="mi">3</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt (S (S (S n)))</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S (S (S (S n)))</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4e"><hr></label><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4f"><span class="nb">intuition</span>. <span class="c">(* n = 3 *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt (S (S (S n)))</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S (S (S (S n)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk50"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt <span class="mi">3</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; <span class="mi">4</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk51" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt (S (S (S (S n))))</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S (S (S (S (S n))))</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk51"><hr></label><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk52"><span class="nb">inversion</span> Hk; <span class="nb">intuition</span>. <span class="c">(* n = 4 and n = 5 - won&#39;t evaluate *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt (S (S (S (S n))))</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S (S (S (S (S n))))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* n &gt; 5 *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>; <span class="nb">intros</span> m Hm; <span class="nb">apply</span> IHn; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>If you use this modified lemma in the definition of <span class="docutils literal">log2</span> you'll
see that it computes everywhere except <span class="docutils literal">n = 4</span> and <span class="docutils literal">n = 5</span>. Well,
almost everywhere -- computations with large <span class="docutils literal">nat</span>s can result in
<em>stack overflow</em> or segmentation fault, as Coq warns us:</p>
<blockquote>
<p>Warning: Stack overflow or segmentation fault happens when working
with large numbers in nat (observed threshold may vary from 5000
to 70000 depending on your system limits and on the command
executed).</p>
</blockquote>
<p>And to make <span class="docutils literal">log2</span> work for <span class="docutils literal">n = 4</span> and <span class="docutils literal">n = 5</span> even for the
above &quot;flawed&quot; proof, we could amend <span class="docutils literal">log2</span> like this</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk53"><span class="kn">Function</span> <span class="nf">log2</span> n {<span class="kn">wf</span> lt n} :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; <span class="mi">0</span>
  | <span class="mi">1</span> =&gt; <span class="mi">0</span>
  | <span class="mi">4</span> =&gt; <span class="mi">2</span>
  | <span class="mi">5</span> =&gt; <span class="mi">2</span>
  | n =&gt; S (log2 (Nat.div2 n))
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">n0</span> <span class="nv">n1</span> : nat,
n1 = <span class="mi">0</span> -&gt; n0 = <span class="mi">1</span> -&gt; n = <span class="mi">2</span> -&gt; Nat.div2 <span class="mi">2</span> &lt; <span class="mi">2</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">n0</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat,
n2 = <span class="mi">0</span> -&gt; n1 = <span class="mi">1</span> -&gt; n0 = <span class="mi">2</span> -&gt; n = <span class="mi">3</span> -&gt; Nat.div2 <span class="mi">3</span> &lt; <span class="mi">3</span></div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">n0</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">n3</span> <span class="nv">n4</span> <span class="nv">n5</span> : nat,
n4 = S n5 -&gt;
n3 = S (S n5) -&gt;
n2 = S (S (S n5)) -&gt;
n1 = S (S (S (S n5))) -&gt;
n0 = S (S (S (S (S n5)))) -&gt;
n = S (S (S (S (S (S n5))))) -&gt;
Nat.div2 (S (S (S (S (S (S n5)))))) &lt;
S (S (S (S (S (S n5)))))</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></div></small></span></pre><p>adding the necessary proofs at the end.</p>
<hr class="docutils" />
<p>The &quot;well-founded&quot; proof must be transparent and can't rely on
pattern-matching on proof objects because the <span class="docutils literal">Function</span> mechanism
actually uses the <span class="docutils literal">lt_wf</span> lemma to compute the decreasing
termination guard. If we look at the term produced by <span class="docutils literal">Eval</span> (in a
case where evaluation fails to produce a <span class="docutils literal">nat</span>), we'll see something
along these lines:</p>
<pre class="code coq literal-block"><code><span class="kr">fix</span> <span class="n">Ffix</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">x0</span> <span class="o">:</span> <span class="n">Acc</span> <span class="o">(</span><span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">x1</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">=&gt;</span> <span class="n">S</span> <span class="n">x0</span> <span class="o">&lt;=</span> <span class="n">x1</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span><span class="kr">struct</span> <span class="n">x0</span><span class="o">}</span></code></pre>
<p>It's easy to see that <span class="docutils literal">x0 : Prop</span>, so it gets erased when extracting
the functional program <span class="docutils literal">log2</span> into, say OCaml, but Coq's internal
evaluation mechanism have to use it to ensure termination.</p>
<hr class="docutils" />
<p><strong>Q:</strong> Is this behaviour due to the way <span class="docutils literal">Function</span> is implemented or
will it be present in every implementation?</p>
<p><strong>A:</strong> I think it's a major design decision for <span class="docutils literal">Function</span> to make
extraction eligible. Basically, <span class="docutils literal">Function</span> adds one dummy argument
and turns (under the hood) your unary function into a binary one. But
this dummy argument doesn't necessarily have to live in <span class="docutils literal">Prop</span>.
<a class="reference external" href="https://gist.github.com/anton-trunov/c3144d1a6e11ac023b65be6d36bf3253">Here</a>
is an example how we could've achieved almost the same thing with
<span class="docutils literal">Fixpoint</span>, except for the fact that the extracted function does
some excessive amount of work. Sorry, if I headed the wrong way --
it's a bit unclear to me what you meant.</p>
<p><strong>A:</strong> Notice that not all opaque terms prevent evaluation. I've made
an <a class="reference external" href="https://gist.github.com/anton-trunov/c9e6bd31d26b24e63349a9e217a1f9f4">explicit version</a>
of what <span class="docutils literal">Function</span> does (I've tried to preserve the spirit, not to
provide the real implementation). The opaque terms created with
<span class="docutils literal">Nat.lt_div2</span> and <span class="docutils literal">Nat.lt_0_succ</span> do not prevent evaluation. If
our usage of opaque terms prevents evaluation to the weak head normal
form for the termination guard, then we'll get stuck. And that would
happen if we destructed some proof term like <span class="docutils literal">(y &lt; n)</span>.</p>
</section>
<section id="answer-arthur-azevedo-de-amorim">
<h2>Answer (Arthur Azevedo De Amorim)</h2>
<p>The reduction behavior of functions defined by well-founded recursion
in Coq is generally not very good, even when you declare your proofs
to be transparent. The reason for this is that arguments of
well-foundedness usually need to be done with complicated proof terms.
Since these proofs terms end up appearing in well-founded recursive
definitions, &quot;simplifying&quot; your function will make all of those proof
terms appear, as you noticed.</p>
<p>It is easier to rely on custom tactics and lemmas to reduce functions
defined this way. First, I would recommend favoring <span class="docutils literal">Program Fixpoint</span> over <span class="docutils literal">Function</span>, because the latter is much older and (I
think) less well maintained. Thus, you would end up with a definition
like this:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Numbers.Natural.Peano.NPeano.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Program.Wf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Program.Tactics.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Fixpoint</span> <span class="nf">log2</span> <span class="nv">n</span> {<span class="nv">wf</span> <span class="nv">lt</span> <span class="nv">n</span>} :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; <span class="mi">0</span>
  | <span class="mi">1</span> =&gt; <span class="mi">0</span>
  | n =&gt; S (log2 (Nat.div2 n))
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk54"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>log2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; n0 -&gt; nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;&gt; n0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;&gt; n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.div2 n0 &lt; n0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span></span></pre><p>Now, you just need to use the <span class="docutils literal">program_simpl</span> tactic to simplify
calls to <span class="docutils literal">log2</span>. Here's an example:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk55"><span class="kn">Lemma</span> <span class="nf">foo</span> : log2 <span class="mi">4</span> = <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.log2 <span class="mi">4</span> = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk56"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.log2 <span class="mi">4</span> = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">program_simpl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><hr class="docutils" />
<p><strong>Q:</strong> Ok, this is an alternative. But I would have liked to
understand what is going on with this <span class="docutils literal">Function</span> stuff. Moreover, I
do not know how to reason with <span class="docutils literal">Program Fixpoint</span>. How can I get the
functional recursion and equation lemmas that I can get with
<span class="docutils literal">Function</span> using <span class="docutils literal">Functional Scheme</span>?</p>
<p><strong>A:</strong> I think it should be possible to prove them directly using
well-founded induction and the <span class="docutils literal">program_simpl</span> tactic.</p>
<p><strong>Q:</strong> I managed to prove both <span class="docutils literal">log25_equation</span> and <span class="docutils literal">log25_ind</span>
using <span class="docutils literal">fix_sub_eq</span> and <span class="docutils literal">Fix_sub_rect</span> respectively (in
<span class="docutils literal">Coq.Program.Wf</span>). I do not know if it is the best solution. And one
error in my previous comment: <span class="docutils literal">Function</span> automatically generates the
equation and functional induction lemmas. <span class="docutils literal">Functional Scheme</span> is
useful for classic <span class="docutils literal">Fixpoint</span>.</p>
</section>
</div>
</main>
</div></body>
</html>
