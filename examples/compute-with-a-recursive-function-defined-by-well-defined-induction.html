<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>Compute with a recursive function defined by well-defined induction</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="compute-with-a-recursive-function-defined-by-well-defined-induction">
<h1 class="title">Compute with a recursive function defined by well-defined induction</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/32354286">https://stackoverflow.com/q/32354286</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>When I use <tt class="docutils literal">Function</tt> to define a non-structurally recursive
function in Coq, the resulting object behaves strangely when a
specific computation is asked. Indeed, instead of giving directly the
result, the <tt class="docutils literal">Eval compute in ...</tt> directive return a rather long
(typically 170 000 lines) expression. It seems that Coq cannot
evaluate everything, and therefore returns a simplified (but long)
expression instead of just a value.</p>
<p>The problem seems to come from the way I prove the obligations
generated by <tt class="docutils literal">Function</tt>. First, I thought the problem came from the
opaque terms I used, and I converted all the lemmas to transparent
constants. By the way, is there a way to list the opaque terms
appearing in a term? Or any other way to turn opaque lemmas into
transparent ones?</p>
<p>I then remarked that the problem came more precisely from the proof
that the order used is well-founded. But I got strange results.</p>
<p>For example, I define <tt class="docutils literal">log2</tt> on the natural numbers by repeatedly
applying <tt class="docutils literal">div2</tt>. Here is the definition:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk0"><span class="kn">Function</span> <span class="nf">log2</span> n {<span class="kn">wf</span> lt n} :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; <span class="mi">0</span>
  | <span class="mi">1</span> =&gt; <span class="mi">0</span>
  | n =&gt; S (log2 (Nat.div2 n))
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">n0</span> <span class="nv">n1</span> : nat,
n0 = S n1 -&gt;
n = S (S n1) -&gt; Nat.div2 (S (S n1)) &lt; S (S n1)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></div></small></span></pre><p>I get two proof obligations. The first one checks that <tt class="docutils literal">n</tt> respects
the relation <tt class="docutils literal">lt</tt> in the recursive calls and can be proved easily.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">n0</span> <span class="nv">n1</span> : nat,
n0 = S n1 -&gt;
n = S (S n1) -&gt; Nat.div2 (S (S n1)) &lt; S (S n1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">1</span> subgoal

  ============================
  <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">n0</span> <span class="nv">n1</span> : nat,
  n0 = S n1 -&gt;
  n = S (S n1) -&gt; Nat.div2 (S (S n1)) &lt; S (S n1)</blockquote></div></div></small></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, n0, n1</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>teq0</var><span class="hyp-type"><b>: </b><span>n0 = S n1</span></span></span><br><span><var>teq</var><span class="hyp-type"><b>: </b><span>n = S (S n1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.div2 (S (S n1)) &lt; S (S n1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Nat.lt_div2, le_n_S, le_0_n.</span></span></pre><p>The second one checks that <tt class="docutils literal">lt</tt> is a well-founded order. This is
already proved in the standard library. The corresponding lemma is
<tt class="docutils literal">Coq.Arith.Wf_nat.lt_wf</tt>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Wf_nat.lt_wf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>If I use this proof, the resulting function behaves normally.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk5"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> log2 <span class="mi">10</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="mi">3</span>
: nat</blockquote></div></div></small></span></pre><p>But if I want to do the proof myself, I do not always get this
behaviour. First, if I end the proof with <tt class="docutils literal">Qed</tt> instead of
<tt class="docutils literal">Defined</tt>, the result of the computation (even on small numbers) is
a complex expression and not a single number. So I use <tt class="docutils literal">Defined</tt> and
try to use only transparent lemmas.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk6"><span class="kn">Lemma</span> <span class="nf">lt_wf2</span> : well_founded lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk8"><span class="nb">unfold</span> well_founded.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : nat, Acc lt a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk9"><span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chka"><span class="nb">apply</span> (lemma1 n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; Acc lt p) -&gt; Acc lt n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chkb"><span class="nb">clear</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; Acc lt p) -&gt; Acc lt n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chkc"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; Acc lt p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chkd"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; Acc lt p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : nat, y &lt; n -&gt; Acc lt y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>Here, <tt class="docutils literal">lemma1</tt> is a proof of the well-founded induction on the
natural numbers. Here again, I can use already existing lemmas, such
as <tt class="docutils literal">lt_wf_ind</tt>, <tt class="docutils literal">lt_wf_rec</tt>, <tt class="docutils literal">lt_wf_rec1</tt> located in
<tt class="docutils literal">Coq.Arith.Wf_nat</tt>, or even <tt class="docutils literal">well_founded_ind lt_wf</tt>. The first
one does not work, it seems this is because it is opaque. The three
others work.</p>
<p>I tried to prove it directly using the standard induction on the
natural numbers, <tt class="docutils literal">nat_ind</tt>. This gives:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chke"><span class="kn">Lemma</span> <span class="nf">lemma1</span> : <span class="kr">forall</span> <span class="nv">n</span> (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>),
    (<span class="kr">forall</span> <span class="nv">n</span>, (<span class="kr">forall</span> <span class="nv">p</span>, p &lt; n -&gt; P p) -&gt; P n) -&gt; P n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>),
(<span class="kr">forall</span> <span class="nv">n0</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p) -&gt; P n0) -&gt; P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chkf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>),
(<span class="kr">forall</span> <span class="nv">n0</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p) -&gt; P n0) -&gt; P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk10"><span class="nb">intros</span> n P H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk11"><span class="nb">pose proof</span> (nat_ind (<span class="kr">fun</span> <span class="nv">n</span> =&gt; <span class="kr">forall</span> <span class="nv">p</span>, p &lt; n -&gt; P p)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) <span class="mi">0</span> -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p)
   n -&gt;
 (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p)
   (S n)) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk12"><span class="nb">simpl</span> <span class="kr">in</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk13"><span class="nb">apply</span> H0 <span class="kr">with</span> (n:=S n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk14"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p</div></blockquote><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk15" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk15"><hr></label><div class="goal-conclusion">n &lt; S n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk16">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk17"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>p &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> H1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk18">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk19"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; S n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1a"><span class="nb">inversion</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; S n0</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>p = n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; S n0</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>S p &lt;= n0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>m = n0</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1b"><hr></label><div class="goal-conclusion">P p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; S n0</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>p = n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1d"><span class="nb">apply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; S n0</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>p = n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; S n0</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>S p &lt;= n0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>m = n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk1f"><span class="nb">apply</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; S n0</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>S p &lt;= n0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>m = n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p &lt; n0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk20">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; S n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> le_n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>With this proof (and some variants of it), <tt class="docutils literal">log2</tt> has the same
strange behaviour. And this proof seems to use only transparent
objects, so maybe the problem is not there.</p>
<p>How can I define a <tt class="docutils literal">Function</tt> that returns understandable results on
specific values?</p>
<hr class="docutils" />
<p><strong>A:</strong> <tt class="docutils literal">Print Opaque Dependencies log2</tt> can be used to list the
opaque terms used in <tt class="docutils literal">log2</tt>.</p>
</div>
<div class="section" id="answer-anton-trunov">
<h1>Answer (Anton Trunov)</h1>
<p>I've managed to pin-point the place that causes troubles: it's
<tt class="docutils literal">inversion H2.</tt> in <tt class="docutils literal">lemma1</tt>. It turns out we don't need that
case-analysis and <tt class="docutils literal">intuition</tt> can finish the proof (it doesn't
pattern-match on <tt class="docutils literal">H2</tt>):</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk21"><span class="kn">Lemma</span> <span class="nf">lemma1</span> : <span class="kr">forall</span> <span class="nv">n</span> (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>),
    (<span class="kr">forall</span> <span class="nv">n</span>, (<span class="kr">forall</span> <span class="nv">p</span>, p &lt; n -&gt; P p) -&gt; P n) -&gt; P n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>),
(<span class="kr">forall</span> <span class="nv">n0</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p) -&gt; P n0) -&gt; P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>),
(<span class="kr">forall</span> <span class="nv">n0</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p) -&gt; P n0) -&gt; P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk23"><span class="nb">intros</span> n P H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk24"><span class="nb">pose proof</span> (nat_ind (<span class="kr">fun</span> <span class="nv">n</span> =&gt; <span class="kr">forall</span> <span class="nv">p</span>, p &lt; n -&gt; P p)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) <span class="mi">0</span> -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p)
   n -&gt;
 (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p)
   (S n)) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk25"><span class="nb">simpl</span> <span class="kr">in</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk26"><span class="nb">apply</span> H0 <span class="kr">with</span> (n:=S n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk27" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk27"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p</div></blockquote><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk28"><hr></label><div class="goal-conclusion">n &lt; S n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk29">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>p &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> H1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; S n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2d"><span class="nb">apply</span> Lt.lt_n_Sm_le, Nat.lt_eq_cases <span class="kr">in</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; n0 \/ p = n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2e"><span class="nb">destruct</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p = n0</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk2f"><hr></label><div class="goal-conclusion">P p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk30">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p &lt; n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> H1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk31">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p = n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk32"><span class="nb">subst</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n0 -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk33">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt; P n</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; <span class="mi">0</span> -&gt; P p) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p) -&gt;
 <span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; S n -&gt; P p) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat, p &lt; n -&gt; P p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; S n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> le_n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>If we use <tt class="docutils literal">lemma1</tt> with this proof, the computation of <tt class="docutils literal">log2 10</tt>
results in <tt class="docutils literal">3</tt>.</p>
<p>By the way, here is my version of <tt class="docutils literal">lt_wf2</tt> (it lets us compute as
well):</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk34"><span class="kn">Lemma</span> <span class="nf">lt_wf2</span> : well_founded lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk35"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk36"><span class="nb">unfold</span> well_founded.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : nat, Acc lt a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk37"><span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk38"><span class="nb">induction</span> n; <span class="nb">constructor</span>; <span class="nb">intros</span> k Hk.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk39" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S n</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk39"><hr></label><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> Hk.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3c"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : nat, y &lt; k -&gt; Acc lt y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3d"><span class="nb">intros</span> m Hm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S n</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hm</var><span class="hyp-type"><b>: </b><span>m &lt; k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3e"><span class="nb">apply</span> IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S n</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hm</var><span class="hyp-type"><b>: </b><span>m &lt; k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m &lt; n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* OR: apply IHn, Nat.lt_le_trans with (m := k); auto with arith. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>I believe the <a class="reference external" href="http://gallium.inria.fr/blog/coq-eval/">Using Coq's evaluation mechanisms in anger</a> blog post by Xavier Leroy
explains this kind of behavior.</p>
<blockquote>
it eliminates the proof of equality between the heads before
recursing over the tails and finally deciding whether to produce a
left or a right. This makes the left/right data part of the final
result dependent on a proof term, which in general does not
reduce!</blockquote>
<p>In our case we eliminate the proof of inequality (<tt class="docutils literal">inversion H2.</tt>)
in the proof of <tt class="docutils literal">lemma1</tt> and the <tt class="docutils literal">Function</tt> mechanism makes our
computations depend on a proof term. Hence, the evaluator can't
proceed when <tt class="docutils literal">n &gt; 1</tt>.</p>
<p>And the reason <tt class="docutils literal">inversion H1.</tt> in the body of the lemma doesn't
influence computations is that for <tt class="docutils literal">n = 0</tt> and <tt class="docutils literal">n = 1</tt>, <tt class="docutils literal">log2 n</tt>
is defined within the <tt class="docutils literal">match</tt> expression as base cases.</p>
<p>To illustrate this point, let me show an example when we can prevent
evaluation of <tt class="docutils literal">log2 n</tt> on any values <tt class="docutils literal">n</tt> and <tt class="docutils literal">n + 1</tt> of our
choice, where <tt class="docutils literal">n &gt; 1</tt> and <em>nowhere else</em>!</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk3f"><span class="kn">Lemma</span> <span class="nf">lt_wf2&#39;</span> : well_founded lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk40"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk41"><span class="nb">unfold</span> well_founded.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : nat, Acc lt a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk42"><span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk43"><span class="nb">induction</span> n; <span class="nb">constructor</span>; <span class="nb">intros</span> k Hk.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk44" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S n</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk44"><hr></label><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk45">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> Hk.          <span class="c">(* n = 0 *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk46">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk47"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt <span class="mi">0</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk48" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt (S n)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S (S n)</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk48"><hr></label><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk49"><span class="nb">intuition</span>. <span class="c">(* n = 1 *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt (S n)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S (S n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4a"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt <span class="mi">1</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; <span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt (S (S n))</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S (S (S n))</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4b"><hr></label><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4c"><span class="nb">intuition</span>. <span class="c">(* n = 2 *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt (S (S n))</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S (S (S n))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4d"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt <span class="mi">2</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; <span class="mi">3</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt (S (S (S n)))</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S (S (S (S n)))</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4e"><hr></label><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk4f"><span class="nb">intuition</span>. <span class="c">(* n = 3 *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt (S (S (S n)))</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S (S (S (S n)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk50"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt <span class="mi">3</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; <span class="mi">4</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk51" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt (S (S (S (S n))))</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S (S (S (S (S n))))</span></span></span><br></div><label class="goal-separator" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk51"><hr></label><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk52"><span class="nb">inversion</span> Hk; <span class="nb">intuition</span>. <span class="c">(* n = 4 and n = 5 - won&#39;t evaluate *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Acc lt (S (S (S (S n))))</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>k &lt; S (S (S (S (S n))))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* n &gt; 5 *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>; <span class="nb">intros</span> m Hm; <span class="nb">apply</span> IHn; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>If you use this modified lemma in the definition of <tt class="docutils literal">log2</tt> you'll
see that it computes everywhere except <tt class="docutils literal">n = 4</tt> and <tt class="docutils literal">n = 5</tt>. Well,
almost everywhere -- computations with large <tt class="docutils literal">nat</tt>s can result in
<em>stack overflow</em> or segmentation fault, as Coq warns us:</p>
<blockquote>
Warning: Stack overflow or segmentation fault happens when working
with large numbers in nat (observed threshold may vary from 5000
to 70000 depending on your system limits and on the command
executed).</blockquote>
<p>And to make <tt class="docutils literal">log2</tt> work for <tt class="docutils literal">n = 4</tt> and <tt class="docutils literal">n = 5</tt> even for the
above &quot;flawed&quot; proof, we could amend <tt class="docutils literal">log2</tt> like this</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk53"><span class="kn">Function</span> <span class="nf">log2</span> n {<span class="kn">wf</span> lt n} :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; <span class="mi">0</span>
  | <span class="mi">1</span> =&gt; <span class="mi">0</span>
  | <span class="mi">4</span> =&gt; <span class="mi">2</span>
  | <span class="mi">5</span> =&gt; <span class="mi">2</span>
  | n =&gt; S (log2 (Nat.div2 n))
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">n0</span> <span class="nv">n1</span> : nat,
n1 = <span class="mi">0</span> -&gt; n0 = <span class="mi">1</span> -&gt; n = <span class="mi">2</span> -&gt; Nat.div2 <span class="mi">2</span> &lt; <span class="mi">2</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">n0</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat,
n2 = <span class="mi">0</span> -&gt; n1 = <span class="mi">1</span> -&gt; n0 = <span class="mi">2</span> -&gt; n = <span class="mi">3</span> -&gt; Nat.div2 <span class="mi">3</span> &lt; <span class="mi">3</span></div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">n0</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">n3</span> <span class="nv">n4</span> <span class="nv">n5</span> : nat,
n4 = S n5 -&gt;
n3 = S (S n5) -&gt;
n2 = S (S (S n5)) -&gt;
n1 = S (S (S (S n5))) -&gt;
n0 = S (S (S (S (S n5)))) -&gt;
n = S (S (S (S (S (S n5))))) -&gt;
Nat.div2 (S (S (S (S (S (S n5)))))) &lt;
S (S (S (S (S (S n5)))))</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></div></small></span></pre><p>adding the necessary proofs at the end.</p>
<hr class="docutils" />
<p>The &quot;well-founded&quot; proof must be transparent and can't rely on
pattern-matching on proof objects because the <tt class="docutils literal">Function</tt> mechanism
actually uses the <tt class="docutils literal">lt_wf</tt> lemma to compute the decreasing
termination guard. If we look at the term produced by <tt class="docutils literal">Eval</tt> (in a
case where evaluation fails to produce a <tt class="docutils literal">nat</tt>), we'll see something
along these lines:</p>
<pre class="code coq literal-block">
<span class="kr">fix</span> <span class="n">Ffix</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">x0</span> <span class="o">:</span> <span class="n">Acc</span> <span class="o">(</span><span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">x1</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">=&gt;</span> <span class="n">S</span> <span class="n">x0</span> <span class="o">&lt;=</span> <span class="n">x1</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span><span class="kr">struct</span> <span class="n">x0</span><span class="o">}</span>
</pre>
<p>It's easy to see that <tt class="docutils literal">x0 : Prop</tt>, so it gets erased when extracting
the functional program <tt class="docutils literal">log2</tt> into, say OCaml, but Coq's internal
evaluation mechanism have to use it to ensure termination.</p>
<hr class="docutils" />
<p><strong>Q:</strong> Is this behaviour due to the way <tt class="docutils literal">Function</tt> is implemented or
will it be present in every implementation?</p>
<p><strong>A:</strong> I think it's a major design decision for <tt class="docutils literal">Function</tt> to make
extraction eligible. Basically, <tt class="docutils literal">Function</tt> adds one dummy argument
and turns (under the hood) your unary function into a binary one. But
this dummy argument doesn't necessarily have to live in <tt class="docutils literal">Prop</tt>.
<a class="reference external" href="https://gist.github.com/anton-trunov/c3144d1a6e11ac023b65be6d36bf3253">Here</a>
is an example how we could've achieved almost the same thing with
<tt class="docutils literal">Fixpoint</tt>, except for the fact that the extracted function does
some excessive amount of work. Sorry, if I headed the wrong way --
it's a bit unclear to me what you meant.</p>
<p><strong>A:</strong> Notice that not all opaque terms prevent evaluation. I've made
an <a class="reference external" href="https://gist.github.com/anton-trunov/c9e6bd31d26b24e63349a9e217a1f9f4">explicit version</a>
of what <tt class="docutils literal">Function</tt> does (I've tried to preserve the spirit, not to
provide the real implementation). The opaque terms created with
<tt class="docutils literal">Nat.lt_div2</tt> and <tt class="docutils literal">Nat.lt_0_succ</tt> do not prevent evaluation. If
our usage of opaque terms prevents evaluation to the weak head normal
form for the termination guard, then we'll get stuck. And that would
happen if we destructed some proof term like <tt class="docutils literal">(y &lt; n)</tt>.</p>
</div>
<div class="section" id="answer-arthur-azevedo-de-amorim">
<h1>Answer (Arthur Azevedo De Amorim)</h1>
<p>The reduction behavior of functions defined by well-founded recursion
in Coq is generally not very good, even when you declare your proofs
to be transparent. The reason for this is that arguments of
well-foundedness usually need to be done with complicated proof terms.
Since these proofs terms end up appearing in well-founded recursive
definitions, &quot;simplifying&quot; your function will make all of those proof
terms appear, as you noticed.</p>
<p>It is easier to rely on custom tactics and lemmas to reduce functions
defined this way. First, I would recommend favoring <tt class="docutils literal">Program
Fixpoint</tt> over <tt class="docutils literal">Function</tt>, because the latter is much older and (I
think) less well maintained. Thus, you would end up with a definition
like this:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Numbers.Natural.Peano.NPeano.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Program.Wf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Program.Tactics.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Fixpoint</span> <span class="nf">log2</span> <span class="nv">n</span> {<span class="nv">wf</span> <span class="nv">lt</span> <span class="nv">n</span>} :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; <span class="mi">0</span>
  | <span class="mi">1</span> =&gt; <span class="mi">0</span>
  | n =&gt; S (log2 (Nat.div2 n))
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk54"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>log2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; n0 -&gt; nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;&gt; n0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;&gt; n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.div2 n0 &lt; n0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span></span></pre><p>Now, you just need to use the <tt class="docutils literal">program_simpl</tt> tactic to simplify
calls to <tt class="docutils literal">log2</tt>. Here's an example:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk55"><span class="kn">Lemma</span> <span class="nf">foo</span> : log2 <span class="mi">4</span> = <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.log2 <span class="mi">4</span> = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="compute-with-a-recursive-function-defined-by-well-defined-induction-v-chk56"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.log2 <span class="mi">4</span> = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">program_simpl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><hr class="docutils" />
<p><strong>Q:</strong> Ok, this is an alternative. But I would have liked to
understand what is going on with this <tt class="docutils literal">Function</tt> stuff. Moreover, I
do not know how to reason with <tt class="docutils literal">Program Fixpoint</tt>. How can I get the
functional recursion and equation lemmas that I can get with
<tt class="docutils literal">Function</tt> using <tt class="docutils literal">Functional Scheme</tt>?</p>
<p><strong>A:</strong> I think it should be possible to prove them directly using
well-founded induction and the <tt class="docutils literal">program_simpl</tt> tactic.</p>
<p><strong>Q:</strong> I managed to prove both <tt class="docutils literal">log25_equation</tt> and <tt class="docutils literal">log25_ind</tt>
using <tt class="docutils literal">fix_sub_eq</tt> and <tt class="docutils literal">Fix_sub_rect</tt> respectively (in
<tt class="docutils literal">Coq.Program.Wf</tt>). I do not know if it is the best solution. And one
error in my previous comment: <tt class="docutils literal">Function</tt> automatically generates the
equation and functional induction lemmas. <tt class="docutils literal">Functional Scheme</tt> is
useful for classic <tt class="docutils literal">Fixpoint</tt>.</p>
</div>
</div>
</div>
</div></body>
</html>
