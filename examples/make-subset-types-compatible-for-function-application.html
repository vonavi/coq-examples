<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>make subset types compatible for function application</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="make-subset-types-compatible-for-function-application">
<h1 class="title">make subset types compatible for function application</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/49620573">https://stackoverflow.com/q/49620573</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>I'm trying to get familiar with subset types in Coq and I've come
across a kind of use case where I don't know how to proceed. Consider
a function that expects a natural number greater than 2, and another
function that expects a natural number greater than 2 and less than
10. Inside the latter function I'd like to call the former, which
should be possible, but it seems I have to do something to make its
type suitable for function application. This is what I'm trying to do:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">add_one_if_gt_2</span> (<span class="nv">i</span> : {i1 : nat | i1 &gt; <span class="mi">2</span>}) := (proj1_sig i) + <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="make-subset-types-compatible-for-function-application-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="make-subset-types-compatible-for-function-application-v-chk0"><span class="kn">Definition</span> <span class="nf">add_one_if_gt_2_and_lt_10</span> (<span class="nv">i</span> : {i1 : nat | i1 &gt; <span class="mi">2</span> /\ i1 &lt; <span class="mi">10</span>}) :=
  add_one_if_gt_2 i.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">In environment
i : {i1 : nat | i1 &gt; <span class="mi">2</span> /\ i1 &lt; <span class="mi">10</span>}
The term <span class="s2">&quot;i&quot;</span> has type <span class="s2">&quot;{i1 : nat | i1 &gt; 2 /\ i1 &lt; 10}&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type
 <span class="s2">&quot;{i1 : nat | i1 &gt; 2}&quot;</span>.</blockquote></div></div></small></span></pre><p>What's missing in <span class="docutils literal">add_one_if_gt_2_and_lt_10</span> to make it typecheck?
In general, for more complicated subset types that might be
compatible, what's the usual way to proceed?</p>
<p>Also, I'm using <span class="docutils literal">i1</span> in the subset type specification just in case,
but it seems it also works if I use <span class="docutils literal">i</span>, although I don't know if
there's any potential issue there since the parameter name is also
<span class="docutils literal">i</span>. Would using <span class="docutils literal">i</span> for both variables be problematic?</p>
</section>
<section id="answer-daniel-schepler">
<h2>Answer (Daniel Schepler)</h2>
<p>One possibility would be to use the <span class="docutils literal">Program</span> functionality:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Program.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">add_one_if_gt_2</span> (<span class="nv">i</span> : {i1 : nat | i1 &gt; <span class="mi">2</span>}) :=
  i + <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">add_one_if_gt_2_and_lt_10</span>
  (<span class="nv">i</span> : {i1 : nat | i1 &gt; <span class="mi">2</span> /\ i1 &lt; <span class="mi">10</span>}) :=
  add_one_if_gt_2 i.</span></span></pre><p>If you step through this code, you'll notice that the system is
generating messages about &quot;obligations&quot; - but in this example, all the
obligations were simple enough that the system could automatically
resolve them on its own, and the definitions immediately completed.
(In this case, the obligation generated by the second definition is
that <span class="docutils literal">i &gt; 2 /\ i &lt; 10</span> implies <span class="docutils literal">i &gt; 2</span>.)</p>
<p>In other situations where it cannot solve the obligations so easily,
you might get pending obligations. In this case, you can use Gallina
directives such as <span class="docutils literal">Next Obligation.</span> to enter proof mode and prove
them yourself. (For more information, see the appropriate chapter of
the Coq documentation.)</p>
</section>
<section id="answer-anton-trunov">
<h2>Answer (Anton Trunov)</h2>
<p>You do this manually because it's not hard to destruct a term of type
<span class="docutils literal">{i1 : nat | i1 &gt; 2 /\ i1 &lt; 10}</span> which is basically a triple of a
<span class="docutils literal">nat</span> (<span class="docutils literal">i1</span>) and two proofs: <span class="docutils literal">i1 &gt; 2</span> and <span class="docutils literal">i2 &lt; 10</span>. What we
are going to do is to destruct this triple, throw away the third
component and repack it into a term of type <span class="docutils literal">{i1 : nat | i1 &gt; 2}</span>,
which is a pair:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">add_one_if_gt_2</span> (<span class="nv">i</span> : {i1 : nat | i1 &gt; <span class="mi">2</span>}) :=
  S (proj1_sig i).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">add_one_if_gt_2_and_lt_10</span> (<span class="nv">i</span> : {i1 : nat | i1 &gt; <span class="mi">2</span> /\ i1 &lt; <span class="mi">10</span>}) :=
  <span class="kr">let</span> &#39;(exist _ i1 (conj i1_gt2 _)) := i <span class="kr">in</span>
  add_one_if_gt_2 (exist _ i1 i1_gt2).</span></span></pre><p>We can do it with projections as well:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">add_one_if_gt_2_and_lt_10&#39;</span> (<span class="nv">i</span> : {i1 : nat | i1 &gt; <span class="mi">2</span> /\ i1 &lt; <span class="mi">10</span>}) :=
  add_one_if_gt_2 (exist _ (proj1_sig i)
                         (proj1 (proj2_sig i))).</span></span></pre><p>Another approach is to use <span class="docutils literal">sig2</span> type for your special case:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">add_one_if_gt_2_and_lt_10_sig2</span> (<span class="nv">i</span> : {i1 : nat | i1 &gt; <span class="mi">2</span> &amp; i1 &lt; <span class="mi">10</span>}) :=
  add_one_if_gt_2 (sig_of_sig2 i).</span></span></pre><p>And using the coercion mechanism you can simplify the above definition
into:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">sig_of_sig2</span> : sig2 &gt;-&gt; sig.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">add_one_if_gt_2_and_lt_10_sig2&#39;</span>
           (<span class="nv">i</span> : {i1 : nat | i1 &gt; <span class="mi">2</span> &amp; i1 &lt; <span class="mi">10</span>}) :=
  add_one_if_gt_2 i.</span></span></pre><p>Which is exactly the solution you were trying to apply!</p>
<p>In case you are not familiar with coercions: this mechanism inserts
<span class="docutils literal">sig_of_sig2</span> (or some other suitable coercion) automatically if it
encounters a type error which can be mended.</p>
</section>
</div>
</main>
</div></body>
</html>
