<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>How can I read Coq's definition of proj1_sig?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="how-can-i-read-coq-s-definition-of-proj1-sig">
<h1 class="title">How can I read Coq's definition of <span class="docutils literal">proj1_sig</span>?</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/41461247">https://stackoverflow.com/q/41461247</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>In Coq, <span class="docutils literal">sig</span> is defined as</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-can-i-read-coqs-definition-of-proj1-sig-v-chk0" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Inductive</span> <span class="nf">sig</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) : <span class="kt">Type</span> :=
    exist : <span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; {x : A | P x}

<span class="kn">Arguments</span> sig [A]%type_scope _%type_scope
<span class="kn">Arguments</span> exist [A]%type_scope _%function_scope _ _</blockquote></div></div></small></span></pre><p>Which I read as</p>
<blockquote>
<p><span class="docutils literal">A sig P</span> is a type, where <span class="docutils literal">P</span> is a function taking an <span class="docutils literal">A</span>
and returning a <span class="docutils literal">Prop</span>. The type is defined such that an element
<span class="docutils literal">x</span> of type <span class="docutils literal">A</span> is of type <span class="docutils literal">sig P</span> if <span class="docutils literal">P x</span> holds.</p>
</blockquote>
<p><span class="docutils literal">proj1_sig</span> is defined as</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-can-i-read-coqs-definition-of-proj1-sig-v-chk1" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">proj1_sig = 
<span class="kr">fun</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">e</span> : {x : A | P x}) =&gt;
<span class="kr">let</span> (<span class="nv">a</span>, _) := e <span class="kr">in</span> a
     : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>),
       {x : A | P x} -&gt; A

<span class="kn">Arguments</span> proj1_sig [A]%type_scope [P]%function_scope
  _</blockquote></div></div></small></span></pre><p>I'm not sure what to make of that. Could somebody provide a more
intuitive understanding?</p>
<hr class="docutils" />
<p><strong>A:</strong> This <a class="reference external" href="http://stackoverflow.com/questions/38777736/how-do-i-read-the-definition-of-ex-intro">question</a>
is somewhat related. And <a class="reference external" href="http://stackoverflow.com/questions/11593270/coq-extract-witness-from-proposition">this</a>
one and <a class="reference external" href="http://stackoverflow.com/questions/26493911/how-to-extract-z-from-subset-type-z-z-z-0">this</a>.
Also, <a class="reference external" href="http://stackoverflow.com/questions/27079513/prove-equality-on-sigma-types">this</a>
question on equality of sigma types can be of some interest too. I've
added these links because the automatic ones were not too close.</p>
</section>
<section id="answer">
<h2>Answer</h2>
<section id="non-dependent-pairs-vs-sig">
<h3>Non-dependent pairs vs. <span class="docutils literal">sig</span></h3>
<blockquote>
<p>The type is defined such that an element <span class="docutils literal">x</span> of type <span class="docutils literal">A</span> is of
type <span class="docutils literal">sig P</span> if <span class="docutils literal">P x</span> holds.</p>
</blockquote>
<p>That is not entirely correct: we can't say <span class="docutils literal">x : sig A P</span>. An
inhabitant <span class="docutils literal">e</span> of type <span class="docutils literal">sig A P</span> is essentially a <em>pair</em> of an
element <span class="docutils literal">x : A</span> and a proof that <span class="docutils literal">P x</span> holds (this is called a
<a class="reference external" href="https://en.wikipedia.org/wiki/Dependent_type#Dependent_pair_type">dependent pair</a>).
<span class="docutils literal">x</span> and <span class="docutils literal">P x</span> are &quot;wrapped&quot; together using the data constructor
<span class="docutils literal">exist</span>.</p>
<p>To see this let us first consider the non-dependent pair type
<span class="docutils literal">prod</span>, which is defined as follows:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-can-i-read-coqs-definition-of-proj1-sig-v-chk2" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Inductive</span> <span class="nf">prod</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
    pair : A -&gt; B -&gt; A * B

<span class="kn">Arguments</span> prod (_ _)%type_scope
<span class="kn">Arguments</span> pair {A B}%type_scope _ _</blockquote></div></div></small></span></pre><p><span class="docutils literal">prod</span>'s inhabitants are pairs, like <span class="docutils literal">pair 1 true</span> (or, using
notations, <span class="docutils literal">(1, true)</span>), where the <em>types</em> of both components are
<em>independent</em> of each other.</p>
<p>Since <span class="docutils literal">A <span class="pre">-&gt;</span> B</span> in Coq is just syntactic sugar for <span class="docutils literal">forall _ : A, B</span> (defined <a class="reference external" href="https://coq.inria.fr/library/Coq.Init.Logic.html">here</a>), the definition
of <span class="docutils literal">prod</span> can be desugared into</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">prod</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=  pair : <span class="kr">forall</span> <span class="nv">_</span> : A, B -&gt; prod A B.</span></span></pre><p>The above definition, perhaps, can help to see that elements of <span class="docutils literal">sig A P</span> are (dependent) pairs.</p>
</section>
<section id="what-we-can-derive-from-implementation-and-type-of-proj1-sig">
<h3>What we can derive from implementation and type of <span class="docutils literal">proj1_sig</span></h3>
<p>From the implementation we can see that <span class="docutils literal">proj1_sig e</span> unpacks the
pair and returns the <em>first</em> component, viz. <span class="docutils literal">x</span>, throwing away the
proof of <span class="docutils literal">P x</span>.</p>
<p>The <a class="reference external" href="https://coq.inria.fr/library/Coq.Init.Specif.html">Coq.Init.Specif</a> module contains
the following comment:</p>
<blockquote>
<p><span class="docutils literal">(sig A P)</span>, or more suggestively <span class="docutils literal">{x:A | P x}</span>, denotes the
subset of elements of the type <span class="docutils literal">A</span> which satisfy the predicate
<span class="docutils literal">P</span>.</p>
</blockquote>
<p>If we look at the type of <span class="docutils literal">proj1_sig</span></p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-can-i-read-coqs-definition-of-proj1-sig-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-read-coqs-definition-of-proj1-sig-v-chk3"><span class="kn">Check</span> proj1_sig.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">proj1_sig
     : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>),
       {x : A | P x} -&gt; A</blockquote></div></div></small></span></pre><p>we will see that <span class="docutils literal">proj1_sig</span> gives us a way of recovering an element
of a superset <span class="docutils literal">A</span> from its subset <span class="docutils literal">{x : A | P x}</span>.</p>
</section>
<section id="analogue-between-fst-and-proj1-sig">
<h3>Analogue between <span class="docutils literal">fst</span> and <span class="docutils literal">proj1_sig</span></h3>
<p>Also, we can say that in some sense <span class="docutils literal">proj1_sig</span> is analogous to the
<a class="reference external" href="https://coq.inria.fr/library/Coq.Init.Datatypes.html#fst">fst</a>
function, which returns the first component of a pair:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-can-i-read-coqs-definition-of-proj1-sig-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-read-coqs-definition-of-proj1-sig-v-chk4"><span class="kn">Check</span> @fst.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">@fst
     : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, A * B -&gt; A</blockquote></div></div></small></span></pre><p>There is a trivial property of <span class="docutils literal">fst</span>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-read-coqs-definition-of-proj1-sig-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-read-coqs-definition-of-proj1-sig-v-chk5"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
    fst (a, b) = a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), fst (a, b) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-read-coqs-definition-of-proj1-sig-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-read-coqs-definition-of-proj1-sig-v-chk6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), fst (a, b) = a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>We can formulate a similar statement for <span class="docutils literal">proj1_sig</span>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-read-coqs-definition-of-proj1-sig-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-read-coqs-definition-of-proj1-sig-v-chk7"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">A</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">x</span> : A) (<span class="nv">prf</span> : P x),
    proj1_sig (exist P x prf) = x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">x</span> : A) (<span class="nv">prf</span> : P x),
proj1_sig (exist P x prf) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-read-coqs-definition-of-proj1-sig-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-read-coqs-definition-of-proj1-sig-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">x</span> : A) (<span class="nv">prf</span> : P x),
proj1_sig (exist P x prf) = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><hr class="docutils" />
<p><strong>Q:</strong> Okay, so suppose I have an element <span class="docutils literal">x</span> of <span class="docutils literal">sig P</span>. Is
<span class="docutils literal">proj1_sig x</span> just <span class="docutils literal">x</span>?</p>
<p><strong>A:</strong> No, it's not. <span class="docutils literal">x</span> is a &quot;pair&quot;. You probably meant something
like this <span class="docutils literal">proj1_sig (exist P x prf) = x</span>, which is an analogue of
<span class="docutils literal">fst (a, b) = a</span>.</p>
</section>
</section>
</div>
</main>
</div></body>
</html>
