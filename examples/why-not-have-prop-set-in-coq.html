<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Why not have Prop : Set in Coq?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="why-not-have-prop-set-in-coq">
<h1 class="title">Why not have <span class="docutils literal">Prop : Set</span> in Coq?</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://proofassistants.stackexchange.com/q/1551">https://proofassistants.stackexchange.com/q/1551</a></p>
</dd>
</dl>
<section id="question">
<h2>Question</h2>
<p>My understanding of Coq is that <span class="docutils literal">Prop : Type_1</span>, <span class="docutils literal">Set : Type_1</span>,
and then <span class="docutils literal">Type_1 : Type_2</span>, <span class="docutils literal">Type_2 : Type_3</span>, etc.</p>
<p>So, at the bottom level, the world splits into two universes: <span class="docutils literal">Prop</span>
(impredicative) and <span class="docutils literal">Set</span> (predicative, like all the other
<span class="docutils literal">Type_i</span> universes). My question is: why not just have <span class="docutils literal">Prop : Type_0 : Type_1 : Type_2 : ...</span>, with <span class="docutils literal">Prop</span> being impredicative as
it is today, and all the other levels would be predicative, also as is
the case today? Wouldn't that be simpler? Would cumulatively still
work?</p>
</section>
<section id="answer">
<h2>Answer</h2>
<p>As it often happens with Coq, the answer is <em>historical reasons</em>.</p>
<p>In the original version dating back from 1984, Coq was based on the
Calculus of Constructions, a barebone dependent type theory. In
particular, it did not feature inductive types. Instead, following the
PTS tradition, it had impredicative universes.</p>
<p>The introduction of inductive types did not change this state of
affair, and for a long time Coq had <em>two</em> impredicative universes,
<span class="docutils literal">Prop</span> and <span class="docutils literal">Set</span>. The difference between both lied in the fact
that the former was erased by extraction, but not the latter. This
phase separation had been around for a long time already.</p>
<p>When dealing with several impredicative universes, one has to be
extremely careful because proofs of <span class="docutils literal">False</span> lurk around the corner.
In particular, <span class="docutils literal">Prop : Set</span> when both are impredicative is enough be
a variant of Girard's system U‚Åª and thus inconsistent. The Coq
developers of yore were well aware of this issue and relied on an
alternative hierarchy, so that <span class="docutils literal">Prop : Type</span> and <span class="docutils literal">Set : Type</span>.</p>
<p>Now, at some point it was decided to make <span class="docutils literal">Set</span> predicative by
default, for other somewhat related reasons. Indeed, impredicative
proof-relevant universes are very much inconsistent with many slightly
classical principles like excluded middle in <span class="docutils literal">Type</span> or some forms of
choice. In particular and ironically, with an impredicative <span class="docutils literal">Set</span>,
Coq has no set-theoretical model (as in <a class="reference external" href="https://hal.inria.fr/inria-00076261/document">Polymorphism is not
set-theoretic</a>).
Nowadays, <span class="docutils literal">Set</span> is thus predicative except if the user opts in
impredicativity with a specific flag.</p>
<p>Impredicative set is essentially not used as of today, and really not
tested so it has fallen to bitrot. It is extremely likely that it is
not usable anymore, and there is an <a class="reference external" href="https://github.com/coq/coq/issues/9458">evergreen discussion about its
removal</a>. Yet, since the
flag still exists Coq needs to at least pretend to avoid
inconsistencies when the user sets it, and therefore one cannot have
<span class="docutils literal">Prop : Set</span>.</p>
<p>If the flag ever gets removed, maybe we can consider adding this rule,
but then there might be weird backwards incompatibilities. Therefore,
it is not even clear we will ever perform this change even in a
situation where it is perfectly sound.</p>
</section>
</main>
</div></body>
</html>
