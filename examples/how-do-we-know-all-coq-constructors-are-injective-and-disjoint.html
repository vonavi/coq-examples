<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>How do we know all Coq constructors are injective and disjoint?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="how-do-we-know-all-coq-constructors-are-injective-and-disjoint">
<h1 class="title">How do we know all Coq constructors are injective and disjoint?</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/32662889">https://stackoverflow.com/q/32662889</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>According to <a class="reference external" href="http://www.cis.upenn.edu/~bcpierce/sf/current/MoreCoq.html">this course</a>, all
constructors (for inductive types) are injective and disjoint:</p>
<blockquote>
<p>...Similar principles apply to all inductively defined types: all
constructors are injective, and the values built from distinct
constructors are never equal. For lists, the <span class="docutils literal">cons</span> constructor
is injective and <span class="docutils literal">nil</span> is different from every non-empty list.
For booleans, <span class="docutils literal">true</span> and <span class="docutils literal">false</span> are unequal.</p>
</blockquote>
<p>(And the <span class="docutils literal">inversion</span> tactic based on this assumption)</p>
<p>I am just wondering how do we know this assumption holds?</p>
<p>How do we know that, e.g., we cannot define natural numbers based on</p>
<ol class="arabic">
<li><p>a &quot;Successor&quot; and maybe a &quot;Double&quot; constructor like this:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">num</span> : <span class="kt">Type</span> :=
| O : num
| S : num -&gt; num
| D : num -&gt; num.</span></span></pre><p>and</p>
</li>
<li><p>some <span class="docutils literal">plus</span> function so that one number <span class="docutils literal">2</span> can be reached via
two different sequences/routes of constructors, <span class="docutils literal">S (S O)</span> and <span class="docutils literal">D (S O)</span>?</p></li>
</ol>
<p>What's the mechanism in Coq that ensures the above will never happen?</p>
<p>P.S. I am not suggesting the above <span class="docutils literal">num</span> example is possible. I am
just wondering what makes it impossible.</p>
</section>
<section id="answer">
<h2>Answer</h2>
<p>When you define an inductive data type in Coq, you are essentially
defining a <em>tree</em> type. Each constructor gives a kind of node that is
allowed to occur in your tree, and its arguments determine the
children and elements that that node can have. Finally, functions
defined on inductive types (with the <span class="docutils literal">match</span> clause) can check the
constructors that were used to produce a value of that type in
<em>arbitrary</em> ways. This makes Coq constructors very different from
constructors you see in an OO language, for instance. An object
constructor is implemented as a regular function that initializes a
value of a given type; Coq constructors, on the other hand, are
enumerating the possible values that the <em>representation</em> of our type
allows. To understand this difference better, we can compare the
different functions we can define on an object in a traditional OO
language, and on an element of an inductive type in Coq. Let's use
your <span class="docutils literal">num</span> type as an example. Here's an object-oriented definition:</p>
<pre class="code java literal-block"><code><span class="kd">class</span> <span class="nc">Num</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">;</span><span class="w">

    </span><span class="kd">private</span><span class="w"> </span><span class="nf">Num</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">this</span><span class="p">.</span><span class="na">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="cm">/* These are the three &quot;constructors&quot;, even though they
       wouldn't correspond to what is called a &quot;constructor&quot; in
       Java, for instance */</span><span class="w">

    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="nf">zero</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Num</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="nf">succ</span><span class="p">(</span><span class="n">Num</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Num</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="na">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="nf">doub</span><span class="p">(</span><span class="n">Num</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Num</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">.</span><span class="na">val</span><span class="p">);</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span></code></pre>
<p>And here's a definition in Coq:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">num</span> : <span class="kt">Type</span> :=
| zero : num
| succ : num -&gt; num
| doub : num -&gt; num.</span></span></pre><p>In the OO example, when we write a function that takes a <span class="docutils literal">Num</span>
argument, there's no way of knowing which &quot;constructor&quot; was used to
produce that value, because this information is not stored in the
<span class="docutils literal">val</span> field. In particular <span class="docutils literal"><span class="pre">Num.doub(Num.succ(Num.zero()))</span></span> and
<span class="docutils literal"><span class="pre">Num.succ(Num.succ(Num.zero()))</span></span> would be equal values.</p>
<p>In the Coq example, on the other hand, things change, because we <em>can</em>
determine which constructor was used to form a <span class="docutils literal">num</span> value, thanks
to the <span class="docutils literal">match</span> statement. For instance, using Coq strings, we could
write a function like this:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Strings.String.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cons_name</span> (<span class="nv">n</span> : num) : string :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | zero   =&gt; <span class="s2">&quot;zero&quot;</span>
  | succ _ =&gt; <span class="s2">&quot;succ&quot;</span>
  | doub _ =&gt; <span class="s2">&quot;doub&quot;</span>
  <span class="kr">end</span>.</span></span></pre><p>In particular, even though your intended meaning for the constructors
implies that <span class="docutils literal">succ (succ zero)</span> and <span class="docutils literal">doub (succ zero)</span> should be
&quot;morally&quot; equal, we can distinguish them by applying the <span class="docutils literal">cons_name</span>
function to them:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-do-we-know-all-coq-constructors-are-injective-and-disjoint-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="how-do-we-know-all-coq-constructors-are-injective-and-disjoint-v-chk0"><span class="kn">Compute</span> cons_name (doub (succ zero)).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;doub&quot;</span>
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-do-we-know-all-coq-constructors-are-injective-and-disjoint-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="how-do-we-know-all-coq-constructors-are-injective-and-disjoint-v-chk1"><span class="kn">Compute</span> cons_name (succ (succ zero)).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;succ&quot;</span>
: string</blockquote></div></div></small></span></pre><p>As a matter of fact, we can use <span class="docutils literal">match</span> to distinguish between
<span class="docutils literal">succ</span> and <span class="docutils literal">doub</span> in <em>arbitrary</em> ways:</p>
<pre class="code coq literal-block"><code><span class="kr">match</span> <span class="n">n</span> <span class="kr">with</span>
<span class="o">|</span> <span class="n">zero</span>   <span class="o">=&gt;</span> <span class="n">false</span>
<span class="o">|</span> <span class="n">succ</span> <span class="n">_</span> <span class="o">=&gt;</span> <span class="n">false</span>
<span class="o">|</span> <span class="n">doub</span> <span class="n">_</span> <span class="o">=&gt;</span> <span class="n">true</span>
<span class="kr">end</span><span class="o">.</span></code></pre>
<p>Now, <span class="docutils literal">a = b</span> in Coq means that there is no possible way we can
distinguish between <span class="docutils literal">a</span> and <span class="docutils literal">b</span>. The above examples show why
<span class="docutils literal">doub (succ zero)</span> and <span class="docutils literal">succ (succ zero)</span> cannot be equal, because
we can write functions that don't respect the meaning that we had in
mind when we wrote that type.</p>
<p>This explains why constructors are disjoint. That they are injective
is actually also a consequence of pattern-matching. For instance,
suppose that we wanted to prove the following statement:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-do-we-know-all-coq-constructors-are-injective-and-disjoint-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="how-do-we-know-all-coq-constructors-are-injective-and-disjoint-v-chk2"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>, succ n = succ m -&gt; n = m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : num, succ n = succ m -&gt; n = m</div></blockquote></div></div></small></span></pre><p>We can begin the proof with</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-do-we-know-all-coq-constructors-are-injective-and-disjoint-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="how-do-we-know-all-coq-constructors-are-injective-and-disjoint-v-chk3"><span class="nb">intros</span> n m H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>num</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>succ n = succ m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = m</div></blockquote></div></div></small></span></pre><p>Leading us to</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-do-we-know-all-coq-constructors-are-injective-and-disjoint-v-chk4" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">1</span> subgoal

  n, m : num
  H : succ n = succ m
  ============================
  n = m</blockquote></div></div></small></span></pre><p>Notice that this goal is by simplification equivalent to</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-do-we-know-all-coq-constructors-are-injective-and-disjoint-v-chk5" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">1</span> subgoal

  n, m : num
  H : succ n = succ m
  ============================
  <span class="kr">match</span> succ n <span class="kr">with</span>
  | succ n&#39; =&gt; n&#39; = m
  | _ =&gt; <span class="kt">True</span>
  <span class="kr">end</span></blockquote></div></div></small></span></pre><p>If we do <span class="docutils literal">rewrite H</span>, we obtain</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-do-we-know-all-coq-constructors-are-injective-and-disjoint-v-chk6" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">1</span> subgoal

  n, m : num
  H : succ n = succ m
  ============================
  <span class="kr">match</span> succ m <span class="kr">with</span>
  | succ n&#39; =&gt; n&#39; = m
  | _ =&gt; <span class="kt">True</span>
  <span class="kr">end</span></blockquote></div></div></small></span></pre><p>which simplifies to</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-do-we-know-all-coq-constructors-are-injective-and-disjoint-v-chk7" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">1</span> subgoal

  n, m : num
  H : succ n = succ m
  ============================
  m = m</blockquote></div></div></small></span></pre><p>At this point, we can conclude with <span class="docutils literal">reflexivity</span>. This technique is
quite general, and is actually at the core of what <span class="docutils literal">inversion</span> does.</p>
</section>
</div>
</main>
</div></body>
</html>
