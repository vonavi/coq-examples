<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>Some help dealing with inject/unject and vector types</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="some-help-dealing-with-inject-unject-and-vector-types">
<h1 class="title">Some help dealing with inject/unject and vector types</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/questions/63017478/some-help-dealing-with-inject-unject-and-vector-types">https://stackoverflow.com/questions/63017478/some-help-dealing-with-inject-unject-and-vector-types</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>I'm reading through CPDT while doing the readings and exercises from
Pierce's course here:
<a class="reference external" href="https://www.cis.upenn.edu/~bcpierce/courses/670Fall12/">https://www.cis.upenn.edu/~bcpierce/courses/670Fall12/</a></p>
<p>This question relates to HW10 here:
<a class="reference external" href="https://www.cis.upenn.edu/~bcpierce/courses/670Fall12/HW10.v">https://www.cis.upenn.edu/~bcpierce/courses/670Fall12/HW10.v</a></p>
<p>Here's the code up to my question</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Arith Bool List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Length-Indexed Lists *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ilist</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">A</span> : <span class="kt">Set</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">ilist</span> : nat -&gt; <span class="kt">Set</span> :=
  | Nil : ilist O
  | Cons : <span class="kr">forall</span> <span class="nv">n</span>, A -&gt; ilist n -&gt; ilist (S n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ilength</span> <span class="nv">n</span> (<span class="nv">l</span> : ilist n) := n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">app</span> <span class="nv">n1</span> (<span class="nv">ls1</span> : ilist n1) <span class="nv">n2</span> (<span class="nv">ls2</span> : ilist n2) : ilist (n1 + n2) :=
    <span class="kr">match</span> ls1 <span class="kr">in</span> (ilist n1) <span class="kr">return</span> (ilist (n1 + n2))
    <span class="kr">with</span>
      | Nil =&gt; ls2
      | Cons x ls1&#39; =&gt; Cons x (app ls1&#39; ls2)
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">inject</span> (<span class="nv">ls</span> : list A) : ilist (length ls) :=
    <span class="kr">match</span> ls <span class="kr">with</span>
      | nil =&gt; Nil
      | h :: t =&gt; Cons h (inject t)
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">unject</span> <span class="nv">n</span> (<span class="nv">ls</span> : ilist n) : list A :=
    <span class="kr">match</span> ls <span class="kr">with</span>
      | Nil =&gt; nil
      | Cons h t =&gt; h :: unject t
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk0"><span class="kn">Theorem</span> <span class="nf">inject_inverse</span> : <span class="kr">forall</span> <span class="nv">ls</span>, unject (inject ls) = ls.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ls</span> : list A, unject (inject ls) = ls</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk1"><span class="nb">induction</span> ls.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">unject (inject nil) = nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHls</var><span class="hyp-type"><b>: </b><span>unject (inject ls) = ls</span></span></span><br></div><label class="goal-separator" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk2"><hr></label><div class="goal-conclusion">unject (inject (a :: ls)) = a :: ls</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span></span></pre><p>Because I really want to better understand dependent types and how to
use proofs in programs, I decided to try to do the latter. Here is
what I have so far.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk3"><span class="kn">Definition</span> <span class="nf">ilists_sizechange</span> (<span class="nv">n1</span> <span class="nv">n2</span> : nat) (<span class="nv">l1</span> : ilist n1) (<span class="nv">P</span> : n1=n2) :
    ilist n2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>ilist n1</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>n1 = n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ilist n2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>ilist n1</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>n1 = n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ilist n2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk5"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>ilist n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ilist n2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk6"><span class="kn">Lemma</span> <span class="nf">ilists_size_equal</span> : <span class="kr">forall</span> <span class="nv">n</span> (<span class="nv">ls</span> : ilist n), n = length (unject ls).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">ls</span> : ilist n),
n = length (unject ls)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">ls</span> : ilist n),
n = length (unject ls)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk8"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>ilist n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = length (unject ls)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk9"><span class="nb">induction</span> ls.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = length (unject Nil)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chka" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>ilist n</span></span></span><br><span><var>IHls</var><span class="hyp-type"><b>: </b><span>n = length (unject ls)</span></span></span><br></div><label class="goal-separator" for="some-help-dealing-with-inject-unject-and-vector-types-v-chka"><hr></label><div class="goal-conclusion">S n = length (unject (Cons a ls))</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chkb"><span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>ilist n</span></span></span><br><span><var>IHls</var><span class="hyp-type"><b>: </b><span>n = length (unject ls)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n = length (unject (Cons a ls))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chkc"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>ilist n</span></span></span><br><span><var>IHls</var><span class="hyp-type"><b>: </b><span>n = length (unject ls)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n = S (length (unject ls))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chkd"><span class="kn">Theorem</span> <span class="nf">unject_inject_thehardway</span> : <span class="kr">forall</span> <span class="nv">n</span> (<span class="nv">ls</span> : ilist n),
      inject (unject ls) = ilists_sizechange ls (ilists_size_equal ls).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">ls</span> : ilist n),
inject (unject ls) =
ilists_sizechange ls (ilists_size_equal ls)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">ls</span> : ilist n),
inject (unject ls) =
ilists_sizechange ls (ilists_size_equal ls)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chkf"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>ilist n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inject (unject ls) =
ilists_sizechange ls (ilists_size_equal ls)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk10"><span class="nb">induction</span> ls.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inject (unject Nil) =
ilists_sizechange Nil (ilists_size_equal Nil)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>ilist n</span></span></span><br><span><var>IHls</var><span class="hyp-type"><b>: </b><span>inject (unject ls) =
ilists_sizechange ls (ilists_size_equal ls)</span></span></span><br></div><label class="goal-separator" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk11"><hr></label><div class="goal-conclusion">inject (unject (Cons a ls)) =
ilists_sizechange (Cons a ls)
  (ilists_size_equal (Cons a ls))</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk12"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Nil = ilists_sizechange Nil (ilists_size_equal Nil)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk13" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>ilist n</span></span></span><br><span><var>IHls</var><span class="hyp-type"><b>: </b><span>inject (unject ls) =
ilists_sizechange ls (ilists_size_equal ls)</span></span></span><br></div><label class="goal-separator" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk13"><hr></label><div class="goal-conclusion">inject (unject (Cons a ls)) =
ilists_sizechange (Cons a ls)
  (ilists_size_equal (Cons a ls))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>I have a target like <tt class="docutils literal">Nil = ilists_sizechange Nil (ilists_size_equal
Nil)</tt> and I'm not really sure what I can do here.</p>
<p>I tried writing <tt class="docutils literal">ilists_sizechange</tt> as a more direct function, but
failed to do so. Not sure how to massage the type checking.</p>
<p>I guess I'm curious first if this approach is fruitful, or if I'm
making some fundamental mistake. I'm also curious what the most
concise way of expressing <tt class="docutils literal">inject (unject ls) = ilists_sizechange ls
(ilists_size_equal ls).</tt> is...here there are two custom functions
(the sizechange and the proof of equality), and one imagines it should
be possible with just one.</p>
<p>Coq is great but the syntax around dependently types stuff can be
tricky. I appreciate any help!</p>
<p>Edit: I realize that an inductive type or something expressing
equality of two lists and then building up and showing the sizes are
equal is probably easier (eg the first suggestion they have), but I
want to understand this case because I can imagine running into these
sorts of issues in the future and I want to know how to work around
them.</p>
<p>Edit2: I was able to make it past the Nil case using the following</p>
<pre class="code coq literal-block">
<span class="n">dep_destruct</span> <span class="o">(</span><span class="n">ilists_size_equal</span> <span class="n">Nil</span><span class="o">).</span>
<span class="nb">compute</span><span class="o">.</span>
<span class="bp">reflexivity</span><span class="o">.</span>
</pre>
<p>But then get stuck on the Cons case...I will try to prove some
theorems and see if I can't get there, but I think I'm still missing
something conceptual here.</p>
</div>
<div class="section" id="answer">
<h1>Answer</h1>
<p>Although functions may depend on proof objects, one approach (I'm
going to show below) is to define the functions so that they don't use
the proof objects except to construct other proof objects and to
eliminate absurd cases, ensuring that opaque proofs never block
computation. Another approach is to fully embrace dependently typed
programming and the unification of &quot;proofs as programs&quot;, but that's a
much bigger paradigm shift to explain, so I'm not going to do that.</p>
<p>Starting with <tt class="docutils literal">ilists_sizechange</tt>, we now care about the shape of
the term constructed by tactics, so not all tactics are allowed. Not
wanting to use the equality proof rules out the tactic <tt class="docutils literal">subst</tt>.
Instead we can recurse (<tt class="docutils literal">induction</tt>) on the list <tt class="docutils literal">l1</tt> and
pattern-match (<tt class="docutils literal">destruct</tt>) on the natural number <tt class="docutils literal">n2</tt>; there are
four cases:</p>
<ul class="simple">
<li>two absurd ones, which can be eliminated by using the equality
(<tt class="docutils literal">discriminate</tt>)</li>
<li>the <tt class="docutils literal">0 = 0</tt> case, where you can just construct the empty list</li>
<li>the <tt class="docutils literal">S m1 = S m2</tt> case, where you can construct <tt class="docutils literal">Cons</tt>, use the
induction hypothesis (i.e., recursive call), and then you are asked
for a proof of <tt class="docutils literal">m1 = m2</tt>, which is where you can fall back to
regular reasoning without caring what the proof term looks like.</li>
</ul>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk14"><span class="kn">Definition</span> <span class="nf">ilists_sizechange</span> (<span class="nv">n1</span> <span class="nv">n2</span> : nat) (<span class="nv">l1</span> : ilist n1) (<span class="nv">P</span>: n1=n2) :
    ilist n2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>ilist n1</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>n1 = n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ilist n2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk15"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>ilist n1</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>n1 = n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ilist n2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk16"><span class="nb">revert</span> n2 P. <span class="c">(* Generalize the induction hypothesis. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n1</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>ilist n1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n2</span> : nat, n1 = n2 -&gt; ilist n2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> l1; <span class="nb">destruct</span> n2; <span class="bp">discriminate</span> + <span class="nb">constructor</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>While the rest of the proof below would technically work with that
definition, it is still not ideal because any computation would unfold
<tt class="docutils literal">ilist_sizechange</tt> into an ugly function. While we've been careful
to give that function the &quot;right&quot; computational behavior, tactic-based
programming tends to be sloppy about some finer details of the syntax
of those functions, which makes later proofs where they appear hard to
read.</p>
<p>To have it look nicer in proofs, one way is to define a <tt class="docutils literal">Fixpoint</tt>
with the <tt class="docutils literal">refine</tt> tactic. You write down the body of the function in
Gallina, and put underscores for the proof terms, which become
obligations that you have to prove separately. <tt class="docutils literal">refine</tt> is not the
only way to perform this technique, there's also the <tt class="docutils literal">Program
Fixpoint</tt> command and the Equations plugin. I would recommend looking
into Equations. I stick with <tt class="docutils literal">refine</tt> out of familiarity.</p>
<p>As you can see, intuitively all this function does is deconstruct the
list <tt class="docutils literal">l1</tt>, indexed by <tt class="docutils literal">n1</tt>, and reconstruct it with index <tt class="docutils literal">n2</tt>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk17"><span class="kn">Fixpoint</span> <span class="nf">ilists_sizechange</span> (<span class="nv">n1</span> <span class="nv">n2</span> : nat) (<span class="nv">l1</span> : ilist n1) {<span class="nv">struct</span> <span class="nv">l1</span>} :
    n1 = n2 -&gt; ilist n2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>ilists_sizechange</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat,
ilist n1 -&gt; n1 = n2 -&gt; ilist n2</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>ilist n1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n1 = n2 -&gt; ilist n2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk18"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>ilists_sizechange</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat,
ilist n1 -&gt; n1 = n2 -&gt; ilist n2</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>ilist n1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n1 = n2 -&gt; ilist n2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk19"><span class="nb">refine</span> (
        <span class="kr">match</span> l1, n2 <span class="kr">with</span>
        | Nil, <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; Nil
        | Cons x xs, S n2&#39; =&gt; <span class="kr">fun</span> <span class="nv">EQ</span> =&gt; Cons x (ilists_sizechange _ _ xs _)
        | _, _ =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; _
        <span class="kr">end</span>
      ); <span class="kp">try</span> <span class="bp">discriminate</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>ilists_sizechange</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat,
ilist n1 -&gt; n1 = n2 -&gt; ilist n2</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>ilist n1</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>ilist n</span></span></span><br><span><var>n2'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span>S n = S n2&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = n2&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>The proof of <tt class="docutils literal">ilists_size_equal</tt> needs no modification.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk1a"><span class="kn">Lemma</span> <span class="nf">ilists_size_equal</span> : <span class="kr">forall</span> <span class="nv">n</span> (<span class="nv">ls</span> : ilist n), n = length (unject ls).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">ls</span> : ilist n),
n = length (unject ls)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk1b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">ls</span> : ilist n),
n = length (unject ls)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk1c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>ilist n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = length (unject ls)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk1d"><span class="nb">induction</span> ls.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = length (unject Nil)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk1e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>ilist n</span></span></span><br><span><var>IHls</var><span class="hyp-type"><b>: </b><span>n = length (unject ls)</span></span></span><br></div><label class="goal-separator" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk1e"><hr></label><div class="goal-conclusion">S n = length (unject (Cons a ls))</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk1f"><span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>ilist n</span></span></span><br><span><var>IHls</var><span class="hyp-type"><b>: </b><span>n = length (unject ls)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n = length (unject (Cons a ls))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk20"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>ilist n</span></span></span><br><span><var>IHls</var><span class="hyp-type"><b>: </b><span>n = length (unject ls)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n = S (length (unject ls))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>For the final proof, there is one more step: first generalize the
equality proof. The idea is that <tt class="docutils literal">ilists_sizechange</tt> doesn't
actually look at it, but when it makes a recursive call it will need
to construct some other proof, and this generalization allows you to
use the induction hypothesis independently of that particular proof.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk21"><span class="kn">Theorem</span> <span class="nf">unject_inject_</span> :
    <span class="kr">forall</span> <span class="nv">n</span> (<span class="nv">ls</span> : ilist n) (<span class="nv">EQ</span> : n = length (unject ls)),
      inject (unject ls) = ilists_sizechange ls EQ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">ls</span> : ilist n)
  (<span class="nv">EQ</span> : n = length (unject ls)),
inject (unject ls) = ilists_sizechange ls EQ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">ls</span> : ilist n)
  (<span class="nv">EQ</span> : n = length (unject ls)),
inject (unject ls) = ilists_sizechange ls EQ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk23"><span class="nb">intros</span> n ls; <span class="nb">induction</span> ls; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = <span class="mi">0</span> -&gt; Nil = Nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>ilist n</span></span></span><br><span><var>IHls</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">EQ</span> : n = length (unject ls),
inject (unject ls) = ilists_sizechange ls EQ</span></span></span><br></div><label class="goal-separator" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk24"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">EQ</span> : S n = S (length (unject ls)),
Cons a (inject (unject ls)) =
Cons a
  (ilists_sizechange ls
     (eq_add_S n (length (unject ls)) EQ))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk25">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = <span class="mi">0</span> -&gt; Nil = Nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk26">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>ilist n</span></span></span><br><span><var>IHls</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">EQ</span> : n = length (unject ls),
inject (unject ls) = ilists_sizechange ls EQ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">EQ</span> : S n = S (length (unject ls)),
Cons a (inject (unject ls)) =
Cons a
  (ilists_sizechange ls
     (eq_add_S n (length (unject ls)) EQ))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk27"><span class="nb">intros</span> EQ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>ilist n</span></span></span><br><span><var>IHls</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">EQ</span> : n = length (unject ls),
inject (unject ls) = ilists_sizechange ls EQ</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span>S n = S (length (unject ls))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Cons a (inject (unject ls)) =
Cons a
  (ilists_sizechange ls
     (eq_add_S n (length (unject ls)) EQ))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk28"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>ilist n</span></span></span><br><span><var>IHls</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">EQ</span> : n = length (unject ls),
inject (unject ls) = ilists_sizechange ls EQ</span></span></span><br><span><var>EQ</var><span class="hyp-type"><b>: </b><span>S n = S (length (unject ls))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inject (unject ls) =
ilists_sizechange ls
  (eq_add_S n (length (unject ls)) EQ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHls.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* Here we have ilists_sizechange applied to some big proof</span>
<span class="c">         object, which we can ignore because the induction hypothesis</span>
<span class="c">         generalizes over all such proof objects *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Then you want to specialize that theorem to use a concrete proof,
ensuring that such a proof exists so the theorem is not vacuous.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk29"><span class="kn">Theorem</span> <span class="nf">unject_inject</span> : <span class="kr">forall</span> <span class="nv">n</span> (<span class="nv">ls</span> : ilist n),
      inject (unject ls) = ilists_sizechange ls (ilists_size_equal _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">ls</span> : ilist n),
inject (unject ls) =
ilists_sizechange ls (ilists_size_equal ls)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="some-help-dealing-with-inject-unject-and-vector-types-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="some-help-dealing-with-inject-unject-and-vector-types-v-chk2a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Set</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">ls</span> : ilist n),
inject (unject ls) =
ilists_sizechange ls (ilists_size_equal ls)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="nb">apply</span> unject_inject_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ilist</span>.</span></span></pre></div>
</div>
</div>
</div></body>
</html>
