<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Coq: How to refer to the types generated by a specific constructor?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="coq-how-to-refer-to-the-types-generated-by-a-specific-constructor">
<h1 class="title">Coq: How to refer to the types generated by a specific constructor?</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/52621517">https://stackoverflow.com/q/52621517</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>For example, if I define a function from <span class="docutils literal">nat</span> to <span class="docutils literal">nat</span>, it would
be</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">plusfive</span> (<span class="nv">a</span> : nat) : nat := a + <span class="mi">5</span>.</span></span></pre><p>However, I would like to define a function whose arguments are
<span class="docutils literal">nat</span>s constructed using the <span class="docutils literal">S</span> constructor (i.e. nonzero) is
that possible to directly specify as a type? something like</p>
<pre class="code coq literal-block"><code><span class="kn">Definition</span> <span class="nf">plusfive</span> <span class="o">(</span><span class="nv">a</span> <span class="o">:</span> <span class="n">nat</span><span class="o">.</span><span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">5</span><span class="o">.</span></code></pre>
<p>(I know that for this case I could also add an argument with a proof
that <span class="docutils literal">a</span> is nonzero, but I am wondering if it is possible to
directly name the type based on the <span class="docutils literal">S</span> constructor).</p>
</section>
<section id="answer">
<h2>Answer</h2>
<p>Functions have to be complete, so you will have to use some subtype
instead of <span class="docutils literal">nat</span>, or add an argument that reduces input space, for
instance <span class="docutils literal">(H: a &lt;&gt; 0)</span></p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">plusfive</span> (<span class="nv">a</span> : nat) (<span class="nv">H</span> : a &lt;&gt; <span class="mi">0</span>) :=
  <span class="kr">match</span> a <span class="kr">as</span> e <span class="kr">return</span> a = e -&gt; _ <span class="kr">with</span>
  | S _ =&gt; <span class="kr">fun</span> <span class="nv">_</span>  =&gt; a + <span class="mi">5</span>
  | _   =&gt; <span class="kr">fun</span> <span class="nv">H0</span> =&gt; <span class="kr">match</span> (H H0) <span class="kr">with</span> <span class="kr">end</span>
  <span class="kr">end</span> eq_refl.</span></span></pre><p>However, these kinds of tricks have been discovered to be very
cumbersome to work with in large developments, and often one instead
uses complete functions on the base type that return dummy values for
bad input values, and prove that the function is called with correct
arguments separately from the function definition. See for example how
division is defined in the standard library.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="coq-how-to-refer-to-the-types-generated-by-a-specific-constructor-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-how-to-refer-to-the-types-generated-by-a-specific-constructor-v-chk0"><span class="kn">Print</span> div.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">div = 
<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : nat =&gt;
<span class="kr">match</span> y <span class="kr">with</span>
| <span class="mi">0</span> =&gt; y
| S y&#39; =&gt; fst (divmod x y&#39; <span class="mi">0</span> y&#39;)
<span class="kr">end</span>
     : nat -&gt; nat -&gt; nat

<span class="kn">Arguments</span> div (_ _)%nat_scope</blockquote></div></div></small></span></pre><p>So <span class="docutils literal">Compute (div 1 0).</span> gives you <span class="docutils literal">0</span>.</p>
<p>The nice thing is that you can use <span class="docutils literal">div</span> in expressions directly,
without having to interleave proofs that the denominator is non-zero.
Proving that an expression is correct is then done <em>after</em> it has been
defined, not at the same time.</p>
</section>
</div>
</main>
</div></body>
</html>
