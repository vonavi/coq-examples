<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>Coq: How to refer to the types generated by a specific constructor?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="coq-how-to-refer-to-the-types-generated-by-a-specific-constructor">
<h1 class="title">Coq: How to refer to the types generated by a specific constructor?</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/52621517">https://stackoverflow.com/q/52621517</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>For example, if I define a function from <tt class="docutils literal">nat</tt> to <tt class="docutils literal">nat</tt>, it would
be</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">plusfive</span> (<span class="nv">a</span> : nat) : nat := a + <span class="mi">5</span>.</span></span></pre><p>However, I would like to define a function whose arguments are
<tt class="docutils literal">nat</tt>s constructed using the <tt class="docutils literal">S</tt> constructor (i.e. nonzero) is
that possible to directly specify as a type? something like</p>
<pre class="code coq literal-block">
<span class="kn">Definition</span> <span class="nf">plusfive</span> <span class="o">(</span><span class="nv">a</span> <span class="o">:</span> <span class="n">nat</span><span class="o">.</span><span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">5</span><span class="o">.</span>
</pre>
<p>(I know that for this case I could also add an argument with a proof
that <tt class="docutils literal">a</tt> is nonzero, but I am wondering if it is possible to
directly name the type based on the <tt class="docutils literal">S</tt> constructor).</p>
</div>
<div class="section" id="answer">
<h1>Answer</h1>
<p>Functions have to be complete, so you will have to use some subtype
instead of <tt class="docutils literal">nat</tt>, or add an argument that reduces input space, for
instance <tt class="docutils literal">(H: a &lt;&gt; 0)</tt></p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">plusfive</span> (<span class="nv">a</span> : nat) (<span class="nv">H</span> : a &lt;&gt; <span class="mi">0</span>) :=
  <span class="kr">match</span> a <span class="kr">as</span> e <span class="kr">return</span> a = e -&gt; _ <span class="kr">with</span>
  | S _ =&gt; <span class="kr">fun</span> <span class="nv">_</span>  =&gt; a + <span class="mi">5</span>
  | _   =&gt; <span class="kr">fun</span> <span class="nv">H0</span> =&gt; <span class="kr">match</span> (H H0) <span class="kr">with</span> <span class="kr">end</span>
  <span class="kr">end</span> eq_refl.</span></span></pre><p>However, these kinds of tricks have been discovered to be very
cumbersome to work with in large developments, and often one instead
uses complete functions on the base type that return dummy values for
bad input values, and prove that the function is called with correct
arguments separately from the function definition. See for example how
division is defined in the standard library.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="coq-how-to-refer-to-the-types-generated-by-a-specific-constructor-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-how-to-refer-to-the-types-generated-by-a-specific-constructor-v-chk0"><span class="kn">Print</span> div.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">div = 
<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : nat =&gt;
<span class="kr">match</span> y <span class="kr">with</span>
| <span class="mi">0</span> =&gt; y
| S y&#39; =&gt; fst (divmod x y&#39; <span class="mi">0</span> y&#39;)
<span class="kr">end</span>
     : nat -&gt; nat -&gt; nat

<span class="kn">Arguments</span> div (_ _)%nat_scope</blockquote></div></div></small></span></pre><p>So <tt class="docutils literal">Compute (div 1 0).</tt> gives you <tt class="docutils literal">0</tt>.</p>
<p>The nice thing is that you can use <tt class="docutils literal">div</tt> in expressions directly,
without having to interleave proofs that the denominator is non-zero.
Proving that an expression is correct is then done <em>after</em> it has been
defined, not at the same time.</p>
</div>
</div>
</div>
</div></body>
</html>
