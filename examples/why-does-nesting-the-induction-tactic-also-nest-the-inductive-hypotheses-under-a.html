<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Why does nesting the induction tactic also nest the inductive hypotheses under a lambda?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-lambda">
<h1 class="title">Why does nesting the induction tactic also nest the inductive hypotheses under a lambda?</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/55596125">https://stackoverflow.com/q/55596125</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk0"><span class="kn">Theorem</span> <span class="nf">mult_comm</span> : <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> : nat, m * n = n * m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> : nat, m * n = n * m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> : nat, m * n = n * m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m * n = n * m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk3"><span class="nb">induction</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m * <span class="mi">0</span> = <span class="mi">0</span> * m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>m * n = n * m</span></span></span><br></div><label class="goal-separator" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk4"><hr></label><div class="goal-conclusion">m * S n = S n * m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m * <span class="mi">0</span> = <span class="mi">0</span> * m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk6"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m * <span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk7"><span class="nb">rewrite</span> (Nat.mul_0_r m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>m * n = n * m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m * S n = S n * m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk9"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>m * n = n * m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m * S n = m + n * m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chka"><span class="nb">rewrite</span> &lt;- IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>m * n = n * m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m * S n = m + m * n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chkb"><span class="nb">induction</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> * n = n * <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> * S n = <span class="mi">0</span> + <span class="mi">0</span> * n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>S m * n = n * S m</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span>m * n = n * m -&gt; m * S n = m + m * n</span></span></span><br></div><label class="goal-separator" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chkc"><hr></label><div class="goal-conclusion">S m * S n = S m + S m * n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chkd">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> * n = n * <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> * S n = <span class="mi">0</span> + <span class="mi">0</span> * n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chke"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> * n = n * <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chkf">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>S m * n = n * S m</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span>m * n = n * m -&gt; m * S n = m + m * n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S m * S n = S m + S m * n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk10"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>S m * n = n * S m</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span>m * n = n * m -&gt; m * S n = m + m * n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (n + m * S n) = S (m + (n + m * n))</div></blockquote></div></div></small></span></pre><p>The above is from the Software Foundation's second chapter.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk11" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">1</span> subgoal

  m, n : nat
  IHn : S m * n = n * S m
  IHm : m * n = n * m -&gt; m * S n = m + m * n
  ============================
  S (n + m * S n) = S (m + (n + m * n))</blockquote></div></div></small></span></pre><p>I am really confused as to what <span class="docutils literal">IHm</span> is supposed to be here. The
way I understand it, Coq tactics get compiled under the hood to some
functional program, but I am really not sure what is going on here. I
am pretty sure that this is not I intended it to do.</p>
<p>What I wanted to do is something like the following Idris program.</p>
<pre class="code idris literal-block"><code><span class="nf">add_comm</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="ow">{</span>a,b<span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="kt">Nat</span><span class="ow">}</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span>a<span class="w"> </span><span class="ow">+</span><span class="w"> </span>b<span class="w"> </span><span class="ow">=</span><span class="w"> </span>b<span class="w"> </span><span class="ow">+</span><span class="w"> </span>a<span class="w">
</span><span class="nf">add_assoc</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="ow">{</span>a,b,c<span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="kt">Nat</span><span class="ow">}</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="ow">(</span>a<span class="w"> </span><span class="ow">+</span><span class="w"> </span>b<span class="ow">)</span><span class="w"> </span><span class="ow">+</span><span class="w"> </span>c<span class="w"> </span><span class="ow">=</span><span class="w"> </span>a<span class="w"> </span><span class="ow">+</span><span class="w"> </span><span class="ow">(</span>b<span class="w"> </span><span class="ow">+</span><span class="w"> </span>c<span class="ow">)</span><span class="w">

</span><span class="kr">total</span><span class="w">
</span><span class="nf">mult_comm</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="ow">{</span>m,n<span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="kt">Nat</span><span class="ow">}</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="ow">(</span>m<span class="w"> </span><span class="ow">*</span><span class="w"> </span>n<span class="ow">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span>n<span class="w"> </span><span class="ow">*</span><span class="w"> </span>m<span class="w">
</span>mult_comm<span class="w"> </span><span class="ow">{</span>m<span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Z</span><span class="ow">}</span><span class="w"> </span><span class="ow">{</span>n<span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Z</span><span class="ow">}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Refl</span><span class="w">
</span>mult_comm<span class="w"> </span><span class="ow">{</span>m<span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Z</span><span class="ow">}</span><span class="w"> </span><span class="ow">{</span>n<span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="ow">(</span><span class="kt">S</span><span class="w"> </span>k<span class="ow">)}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span>mult_comm<span class="w"> </span><span class="ow">{</span>m<span class="ow">=</span><span class="kt">Z</span><span class="ow">}</span><span class="w"> </span><span class="ow">{</span>n<span class="ow">=</span>k<span class="ow">}</span><span class="w">
</span>mult_comm<span class="w"> </span><span class="ow">{</span>m<span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="ow">(</span><span class="kt">S</span><span class="w"> </span>k<span class="ow">)}</span><span class="w"> </span><span class="ow">{</span>n<span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Z</span><span class="ow">}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span>mult_comm<span class="w"> </span><span class="ow">{</span>m<span class="ow">=</span>k<span class="ow">}</span><span class="w"> </span><span class="ow">{</span>n<span class="ow">=</span><span class="kt">Z</span><span class="ow">}</span><span class="w">
</span>mult_comm<span class="w"> </span><span class="ow">{</span>m<span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="ow">(</span><span class="kt">S</span><span class="w"> </span>k<span class="ow">)}</span><span class="w"> </span><span class="ow">{</span>n<span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="ow">(</span><span class="kt">S</span><span class="w"> </span>j<span class="ow">)}</span><span class="w"> </span><span class="ow">=</span><span class="w">
    </span><span class="kr">let</span><span class="w"> </span>prf1<span class="w"> </span><span class="ow">=</span><span class="w"> </span>mult_comm<span class="w"> </span><span class="ow">{</span>m<span class="ow">=</span>k<span class="ow">}</span><span class="w"> </span><span class="ow">{</span>n<span class="ow">=</span><span class="kt">S</span><span class="w"> </span>j<span class="ow">}</span><span class="w">
        </span>prf2<span class="w"> </span><span class="ow">=</span><span class="w"> </span>mult_comm<span class="w"> </span><span class="ow">{</span>m<span class="ow">=</span><span class="kt">S</span><span class="w"> </span>k<span class="ow">}</span><span class="w"> </span><span class="ow">{</span>n<span class="ow">=</span>j<span class="ow">}</span><span class="w">
        </span>prf3<span class="w"> </span><span class="ow">=</span><span class="w"> </span>mult_comm<span class="w"> </span><span class="ow">{</span>m<span class="ow">=</span>k<span class="ow">}</span><span class="w"> </span><span class="ow">{</span>n<span class="ow">=</span>j<span class="ow">}</span><span class="w">
        </span>prf_add_comm<span class="w"> </span><span class="ow">=</span><span class="w"> </span>add_comm<span class="w"> </span><span class="ow">{</span>a<span class="ow">=</span>k<span class="ow">}</span><span class="w"> </span><span class="ow">{</span>b<span class="ow">=</span>j<span class="ow">}</span><span class="w">
        </span>prf_add_assoc<span class="w"> </span><span class="ow">=</span><span class="w"> </span>add_assoc<span class="w"> </span><span class="ow">{</span>a<span class="ow">=</span>k<span class="ow">}</span><span class="w"> </span><span class="ow">{</span>b<span class="ow">=</span>j<span class="ow">}</span><span class="w"> </span><span class="ow">{</span>c<span class="ow">=</span>j<span class="ow">*</span>k<span class="ow">}</span><span class="w">
        </span>prf_add_assoc'<span class="w"> </span><span class="ow">=</span><span class="w"> </span>add_assoc<span class="w"> </span><span class="ow">{</span>a<span class="ow">=</span>j<span class="ow">}</span><span class="w"> </span><span class="ow">{</span>b<span class="ow">=</span>k<span class="ow">}</span><span class="w"> </span><span class="ow">{</span>c<span class="ow">=</span>j<span class="ow">*</span>k<span class="ow">}</span><span class="w">
    </span><span class="kr">in</span><span class="w">
        </span><span class="kr">rewrite</span><span class="w"> </span>prf1<span class="w"> </span><span class="kr">in</span><span class="w">
        </span><span class="kr">rewrite</span><span class="w"> </span>sym<span class="w"> </span>prf2<span class="w"> </span><span class="kr">in</span><span class="w">
        </span><span class="kr">rewrite</span><span class="w"> </span>prf3<span class="w"> </span><span class="kr">in</span><span class="w">
        </span><span class="kr">rewrite</span><span class="w"> </span>sym<span class="w"> </span>prf_add_assoc<span class="w"> </span><span class="kr">in</span><span class="w">
        </span><span class="kr">rewrite</span><span class="w"> </span>sym<span class="w"> </span>prf_add_assoc'<span class="w"> </span><span class="kr">in</span><span class="w">
        </span><span class="kr">rewrite</span><span class="w"> </span><span class="ow">(</span>add_comm<span class="w"> </span><span class="ow">{</span>a<span class="ow">=</span>k<span class="ow">}</span><span class="w"> </span><span class="ow">{</span>b<span class="ow">=</span>j<span class="ow">})</span><span class="w"> </span><span class="kr">in</span><span class="w">
        </span><span class="kt">Refl</span></code></pre>
<p>More specifically, I need <span class="docutils literal">prf1</span>, <span class="docutils literal">prf2</span> and <span class="docutils literal">prf3</span> which I get
using recursive calls to <span class="docutils literal">mult_comm</span>. In Coq the two of the proofs
are stuck in a lambda and I am not sure how that happened. I see that
Coq's <span class="docutils literal">induction</span> tactic is not doing what I think it should be
doing.</p>
<p>In addition to the explanation of the above, let me also ask is there
more introductory material to Coq than Software Foundations just in
case I get stuck like this again on some tactic? Note that I know how
to solve this in Coq as I've found the solution online.</p>
<p>I've tried tackling the SF book unsuccessfully back in 2016 as an
introduction to dependently typed programming and now with the benefit
of hindsight, I see that Little Typer and the Idris book are much
better in that regard.</p>
</section>
<section id="answer">
<h2>Answer</h2>
<p>When you call the <span class="docutils literal">induction</span> tactic, Coq uses heuristics to
determine the predicate <span class="docutils literal">P : nat <span class="pre">-&gt;</span> Prop</span> that you want to prove by
induction. Before calling <span class="docutils literal">induction</span> for the second time, the proof
state looks like this:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk12" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">1</span> subgoal

  m, n : nat
  IHn : m * n = n * m
  ============================
  m * S n = m + m * n</blockquote></div></div></small></span></pre><p>What happened is that Coq decided to include the premise <span class="docutils literal">IHn</span> in
the induction predicate, which was inferred to be</p>
<pre class="code coq literal-block"><code><span class="n">P</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="o">*</span> <span class="n">S</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span></code></pre>
<p>which is exactly what you had in your induction hypothesis. In this
case, you could argue that it was silly for Coq to use the premise,
but there are cases where dropping it would result in an unprovable
goal. For instance, consider the following proof attempt:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk13"><span class="kn">Lemma</span> <span class="nf">double_inj</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>, n + n = m + m -&gt; n = m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + n = m + m -&gt; n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + n = m + m -&gt; n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk15"><span class="nb">intros</span> n m H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n + n = m + m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk16"><span class="nb">induction</span> n <span class="kr">as</span> [|n IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> + <span class="mi">0</span> = m + m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk17" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>S n + S n = m + m</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>n + n = m + m -&gt; n = m</span></span></span><br></div><label class="goal-separator" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk17"><hr></label><div class="goal-conclusion">S n = m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* ... *)</span>
</span></pre><p>If <span class="docutils literal">H</span> were dropped after calling <span class="docutils literal">induction</span>, you would have to
prove <span class="docutils literal">forall n m, n = m</span>, which clearly does not hold.</p>
<p>This example is one of the reasons why it is often a bad idea to call
<span class="docutils literal">induction</span> multiple times in a single Coq proof. As we suggest in
that exercise in Software Foundations, it is better to prove an
auxiliary lemma, since you can be explicit about the induction
predicate. For this example, there are other options as well. You
could, for instance, call <span class="docutils literal">clear IHn</span> to drop the <span class="docutils literal">IHn</span> premise,
which would lead Coq to the correct predicate. The ssreflect proof
language, which now ships with Coq, has a different tactic for
performing induction called <span class="docutils literal">elim</span>, which allows you to be more
explicit in the choice of the predicate.</p>
<p>I agree with your final comment, but I should add that it is not the
goal of Software Foundations to be an introduction to dependently
typed programming. Though Coq supports this paradigm, it is generally
cumbersome to write such programs directly, and much easier to use
tactics to prove lemmas about simply typed programs. For instance,
your proof of <span class="docutils literal">mult_comm</span> is accepted by Idris because its
termination checker is smart enough to recognize all recursive calls
as decreasing, even though they are not decreasing with respect to a
fixed argument (in the second clause, <span class="docutils literal">n</span> decreases, whereas in the
third <span class="docutils literal">m</span> does). This is not possible in Coq, and you must split the
definition into multiple recursive functions, one for each argument,
or use well-founded induction on pairs of natural numbers, which would
be overkill for this example.</p>
<p>Adam Chlipala has another Coq textbook called <a class="reference external" href="http://adam.chlipala.net/cpdt/">CPDT</a> that you might want to check out.
However, I don't think you will find a comprehensive description of
Coq's tactics there, either. Like <span class="docutils literal">induction</span>, many tactics rely on
heuristics and are hard to explain in detail.</p>
<p>On a final note, Matthieu Sozeau has developed a package called
<a class="reference external" href="https://github.com/mattam82/Coq-Equations">Equations</a> that makes
dependently typed programming in Coq much closer to Idris or Agda. If
you find this style of proving more intuitive, you could try to use
it.</p>
</section>
</div>
</main>
</div></body>
</html>
