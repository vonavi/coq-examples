<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>Why does nesting the induction tactic also nest the inductive hypotheses under a lambda?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-lambda">
<h1 class="title">Why does nesting the induction tactic also nest the inductive hypotheses under a lambda?</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/questions/55596125/why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a">https://stackoverflow.com/questions/55596125/why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk0"><span class="kn">Theorem</span> <span class="nf">mult_comm</span> : <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> : nat, m * n = n * m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> : nat, m * n = n * m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> : nat, m * n = n * m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m * n = n * m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk3"><span class="nb">induction</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m * <span class="mi">0</span> = <span class="mi">0</span> * m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>m * n = n * m</span></span></span><br></div><label class="goal-separator" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk4"><hr></label><div class="goal-conclusion">m * S n = S n * m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m * <span class="mi">0</span> = <span class="mi">0</span> * m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk6"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m * <span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk7"><span class="nb">rewrite</span> (Nat.mul_0_r m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>m * n = n * m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m * S n = S n * m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk9"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>m * n = n * m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m * S n = m + n * m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chka"><span class="nb">rewrite</span> &lt;- IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>m * n = n * m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m * S n = m + m * n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chkb"><span class="nb">induction</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> * n = n * <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> * S n = <span class="mi">0</span> + <span class="mi">0</span> * n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>S m * n = n * S m</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span>m * n = n * m -&gt; m * S n = m + m * n</span></span></span><br></div><label class="goal-separator" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chkc"><hr></label><div class="goal-conclusion">S m * S n = S m + S m * n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chkd">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> * n = n * <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> * S n = <span class="mi">0</span> + <span class="mi">0</span> * n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chke"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> * n = n * <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chkf">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>S m * n = n * S m</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span>m * n = n * m -&gt; m * S n = m + m * n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S m * S n = S m + S m * n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk10"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>S m * n = n * S m</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span>m * n = n * m -&gt; m * S n = m + m * n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (n + m * S n) = S (m + (n + m * n))</div></blockquote></div></div></small></span></pre><p>The above is from the Software Foundation's second chapter.</p>
<p>I am really confused as to what <tt class="docutils literal">IHm</tt> is supposed to be here. The
way I understand it, Coq tactics get compiled under the hood to some
functional program, but I am really not sure what is going on here. I
am pretty sure that this is not I intended it to do.</p>
<p>What I wanted to do is something like the following Idris program.</p>
<pre class="code idris literal-block">
<span class="nf">add_comm</span> <span class="ow">:</span> <span class="ow">{</span>a,b <span class="ow">:</span> <span class="kt">Nat</span><span class="ow">}</span> <span class="ow">-&gt;</span> a <span class="ow">+</span> b <span class="ow">=</span> b <span class="ow">+</span> a
<span class="nf">add_assoc</span> <span class="ow">:</span> <span class="ow">{</span>a,b,c <span class="ow">:</span> <span class="kt">Nat</span><span class="ow">}</span> <span class="ow">-&gt;</span> <span class="ow">(</span>a <span class="ow">+</span> b<span class="ow">)</span> <span class="ow">+</span> c <span class="ow">=</span> a <span class="ow">+</span> <span class="ow">(</span>b <span class="ow">+</span> c<span class="ow">)</span>

<span class="kr">total</span>
<span class="nf">mult_comm</span> <span class="ow">:</span> <span class="ow">{</span>m,n <span class="ow">:</span> <span class="kt">Nat</span><span class="ow">}</span> <span class="ow">-&gt;</span> <span class="ow">(</span>m <span class="ow">*</span> n<span class="ow">)</span> <span class="ow">=</span> n <span class="ow">*</span> m
mult_comm <span class="ow">{</span>m <span class="ow">=</span> <span class="kt">Z</span><span class="ow">}</span> <span class="ow">{</span>n <span class="ow">=</span> <span class="kt">Z</span><span class="ow">}</span> <span class="ow">=</span> <span class="kt">Refl</span>
mult_comm <span class="ow">{</span>m <span class="ow">=</span> <span class="kt">Z</span><span class="ow">}</span> <span class="ow">{</span>n <span class="ow">=</span> <span class="ow">(</span><span class="kt">S</span> k<span class="ow">)}</span> <span class="ow">=</span> mult_comm <span class="ow">{</span>m<span class="ow">=</span><span class="kt">Z</span><span class="ow">}</span> <span class="ow">{</span>n<span class="ow">=</span>k<span class="ow">}</span>
mult_comm <span class="ow">{</span>m <span class="ow">=</span> <span class="ow">(</span><span class="kt">S</span> k<span class="ow">)}</span> <span class="ow">{</span>n <span class="ow">=</span> <span class="kt">Z</span><span class="ow">}</span> <span class="ow">=</span> mult_comm <span class="ow">{</span>m<span class="ow">=</span>k<span class="ow">}</span> <span class="ow">{</span>n<span class="ow">=</span><span class="kt">Z</span><span class="ow">}</span>
mult_comm <span class="ow">{</span>m <span class="ow">=</span> <span class="ow">(</span><span class="kt">S</span> k<span class="ow">)}</span> <span class="ow">{</span>n <span class="ow">=</span> <span class="ow">(</span><span class="kt">S</span> j<span class="ow">)}</span> <span class="ow">=</span>
    <span class="kr">let</span> prf1 <span class="ow">=</span> mult_comm <span class="ow">{</span>m<span class="ow">=</span>k<span class="ow">}</span> <span class="ow">{</span>n<span class="ow">=</span><span class="kt">S</span> j<span class="ow">}</span>
        prf2 <span class="ow">=</span> mult_comm <span class="ow">{</span>m<span class="ow">=</span><span class="kt">S</span> k<span class="ow">}</span> <span class="ow">{</span>n<span class="ow">=</span>j<span class="ow">}</span>
        prf3 <span class="ow">=</span> mult_comm <span class="ow">{</span>m<span class="ow">=</span>k<span class="ow">}</span> <span class="ow">{</span>n<span class="ow">=</span>j<span class="ow">}</span>
        prf_add_comm <span class="ow">=</span> add_comm <span class="ow">{</span>a<span class="ow">=</span>k<span class="ow">}</span> <span class="ow">{</span>b<span class="ow">=</span>j<span class="ow">}</span>
        prf_add_assoc <span class="ow">=</span> add_assoc <span class="ow">{</span>a<span class="ow">=</span>k<span class="ow">}</span> <span class="ow">{</span>b<span class="ow">=</span>j<span class="ow">}</span> <span class="ow">{</span>c<span class="ow">=</span>j<span class="ow">*</span>k<span class="ow">}</span>
        prf_add_assoc' <span class="ow">=</span> add_assoc <span class="ow">{</span>a<span class="ow">=</span>j<span class="ow">}</span> <span class="ow">{</span>b<span class="ow">=</span>k<span class="ow">}</span> <span class="ow">{</span>c<span class="ow">=</span>j<span class="ow">*</span>k<span class="ow">}</span>
    <span class="kr">in</span>
        <span class="kr">rewrite</span> prf1 <span class="kr">in</span>
        <span class="kr">rewrite</span> sym prf2 <span class="kr">in</span>
        <span class="kr">rewrite</span> prf3 <span class="kr">in</span>
        <span class="kr">rewrite</span> sym prf_add_assoc <span class="kr">in</span>
        <span class="kr">rewrite</span> sym prf_add_assoc' <span class="kr">in</span>
        <span class="kr">rewrite</span> <span class="ow">(</span>add_comm <span class="ow">{</span>a<span class="ow">=</span>k<span class="ow">}</span> <span class="ow">{</span>b<span class="ow">=</span>j<span class="ow">})</span> <span class="kr">in</span>
        <span class="kt">Refl</span>
</pre>
<p>More specifically, I need <tt class="docutils literal">prf1</tt>, <tt class="docutils literal">prf2</tt> and <tt class="docutils literal">prf3</tt> which I get
using recursive calls to <tt class="docutils literal">mult_comm</tt>. In Coq the two of the proofs
are stuck in a lambda and I am not sure how that happened. I see that
Coq's <tt class="docutils literal">induction</tt> tactic is not doing what I think it should be
doing.</p>
<p>In addition to the explanation of the above, let me also ask is there
more introductory material to Coq than Software Foundations just in
case I get stuck like this again on some tactic? Note that I know how
to solve this in Coq as I've found the solution online.</p>
<p>I've tried tackling the SF book unsuccessfully back in 2016 as an
introduction to dependently typed programming and now with the benefit
of hindsight, I see that Little Typer and the Idris book are much
better in that regard.</p>
</div>
<div class="section" id="answer">
<h1>Answer</h1>
<p>When you call the <tt class="docutils literal">induction</tt> tactic, Coq uses heuristics to
determine the predicate <tt class="docutils literal">P : nat <span class="pre">-&gt;</span> Prop</tt> that you want to prove by
induction. Before calling <tt class="docutils literal">induction</tt> for the second time, the proof
state looks like this:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk11" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>m * n = n * m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m * S n = m + m * n</div></blockquote></div></div></small></span></pre><p>What happened is that Coq decided to include the premise <tt class="docutils literal">IHn</tt> in
the induction predicate, which was inferred to be</p>
<pre class="code coq literal-block">
<span class="n">P</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="o">*</span> <span class="n">S</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span>
</pre>
<p>which is exactly what you had in your induction hypothesis. In this
case, you could argue that it was silly for Coq to use the premise,
but there are cases where dropping it would result in an unprovable
goal. For instance, consider the following proof attempt:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk12"><span class="kn">Lemma</span> <span class="nf">double_inj</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>, n + n = m + m -&gt; n = m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + n = m + m -&gt; n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk13"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + n = m + m -&gt; n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk14"><span class="nb">intros</span> n m H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n + n = m + m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk15"><span class="nb">induction</span> n <span class="kr">as</span> [|n IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> + <span class="mi">0</span> = m + m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk16" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>S n + S n = m + m</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>n + n = m + m -&gt; n = m</span></span></span><br></div><label class="goal-separator" for="why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a-v-chk16"><hr></label><div class="goal-conclusion">S n = m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* ... *)</span>
</span></pre><p>If <tt class="docutils literal">H</tt> were dropped after calling <tt class="docutils literal">induction</tt>, you would have to
prove <tt class="docutils literal">forall n m, n = m</tt>, which clearly does not hold.</p>
<p>This example is one of the reasons why it is often a bad idea to call
<tt class="docutils literal">induction</tt> multiple times in a single Coq proof. As we suggest in
that exercise in Software Foundations, it is better to prove an
auxiliary lemma, since you can be explicit about the induction
predicate. For this example, there are other options as well. You
could, for instance, call <tt class="docutils literal">clear IHn</tt> to drop the <tt class="docutils literal">IHn</tt> premise,
which would lead Coq to the correct predicate. The ssreflect proof
language, which now ships with Coq, has a different tactic for
performing induction called <tt class="docutils literal">elim</tt>, which allows you to be more
explicit in the choice of the predicate.</p>
<p>I agree with your final comment, but I should add that it is not the
goal of Software Foundations to be an introduction to dependently
typed programming. Though Coq supports this paradigm, it is generally
cumbersome to write such programs directly, and much easier to use
tactics to prove lemmas about simply typed programs. For instance,
your proof of <tt class="docutils literal">mult_comm</tt> is accepted by Idris because its
termination checker is smart enough to recognize all recursive calls
as decreasing, even though they are not decreasing with respect to a
fixed argument (in the second clause, <tt class="docutils literal">n</tt> decreases, whereas in the
third <tt class="docutils literal">m</tt> does). This is not possible in Coq, and you must split the
definition into multiple recursive functions, one for each argument,
or use well-founded induction on pairs of natural numbers, which would
be overkill for this example.</p>
<p>Adam Chlipala has another Coq textbook called <a class="reference external" href="http://adam.chlipala.net/cpdt/">CPDT</a> that you might want to check out.
However, I don't think you will find a comprehensive description of
Coq's tactics there, either. Like <tt class="docutils literal">induction</tt>, many tactics rely on
heuristics and are hard to explain in detail.</p>
<p>On a final note, Matthieu Sozeau has developed a package called
<a class="reference external" href="https://github.com/mattam82/Coq-Equations">Equations</a> that makes
dependently typed programming in Coq much closer to Idris or Agda. If
you find this style of proving more intuitive, you could try to use
it.</p>
</div>
</div>
</div>
</div></body>
</html>
