<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Difference between type parameters and indices?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="difference-between-type-parameters-and-indices">
<h1 class="title">Difference between type parameters and indices?</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/24600256">https://stackoverflow.com/q/24600256</a></p>
</dd>
</dl>
<section id="question">
<h2>Question</h2>
<p>I am new to dependent types and am confused about the difference
between the two. It seems people usually say a type is <em>parameterized
by another type</em> and <em>indexed by some value</em>. But isn't there no
distinction between types and terms in a dependently typed language?
Is the distinction between parameters and indices fundamental? Can you
show me examples showing difference in their meanings in both
programming and theorem proving?</p>
</section>
<section id="answer-ptival">
<h2>Answer (Ptival)</h2>
<p>When you see a family of types, you may wonder whether each of the
arguments it has are <em>parameters</em> or <em>indices</em>.</p>
<hr class="docutils" />
<p><strong>Parameters</strong> are merely indicative that the type is somewhat
generic, and behaves <em>parametrically</em> with regards to the argument
supplied.</p>
<p>What this means for instance, is that the type <span class="docutils literal">List T</span> will have
the same shapes regardless of which <span class="docutils literal">T</span> you consider: <span class="docutils literal">nil</span>,
<span class="docutils literal">cons t0 nil</span>, <span class="docutils literal">cons t1 (cons t2 nil)</span>, etc. The choice of <span class="docutils literal">T</span>
only affects which values can be plugged for <span class="docutils literal">t0</span>, <span class="docutils literal">t1</span>, <span class="docutils literal">t2</span>.</p>
<hr class="docutils" />
<p><strong>Indices</strong> on the other hand may affect which inhabitants you may
find in the type! That's why we say they <em>index</em> a family of types,
that is, each index tells you which one of the types (within the
family of types) you are looking at (in that sense, a parameter is a
degenerate case where all the indices point to the same set of
&quot;shapes&quot;).</p>
<p>For instance, the type family <span class="docutils literal">Fin n</span> or finite sets of size <span class="docutils literal">n</span>
contains very different structures depending on your choice of <span class="docutils literal">n</span>.</p>
<p>The index <span class="docutils literal">0</span> indices an empty set. The index <span class="docutils literal">1</span> indices a set
with one element.</p>
<p>In that sense, the knowledge of the value of the index may carry
important information! Usually, you can learn which constructors may
or may not have been used by looking at an index. That's how
pattern-matching in dependently-typed languages can eliminate
non-feasible patterns, and extract information out of the triggering
of a pattern.</p>
<hr class="docutils" />
<p>This is why, when you define inductive families, usually you can
define the parameters for the entire type, but you have to specify the
indices for each constructor (since you are allowed to specify, for
each constructor, what indices it lives at).</p>
<p>For instance I can define:</p>
<pre class="code agda literal-block"><code>F<span class="w"> </span><span class="o">(</span>T<span class="w"> </span><span class="ow">:</span><span class="w"> </span>Type<span class="o">)</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>ℕ<span class="w"> </span><span class="ow">→</span><span class="w"> </span>Type<span class="w">
</span><span class="nf">C1</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>F<span class="w"> </span>T<span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="nf">C2</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>F<span class="w"> </span>T<span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="nf">C3</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>F<span class="w"> </span>T<span class="w"> </span><span class="mi">0</span></code></pre>
<p>Here, <span class="docutils literal">T</span> is a parameter, while <span class="docutils literal">0</span> and <span class="docutils literal">1</span> are indices. When
you receive some <span class="docutils literal">x</span> of type <span class="docutils literal">F T n</span>, looking at what <span class="docutils literal">T</span> is
will not reveal anything about <span class="docutils literal">x</span>. But looking at <span class="docutils literal">n</span> will tell
you:</p>
<ul class="simple">
<li><p>that <span class="docutils literal">x</span> must be <span class="docutils literal">C1</span> or <span class="docutils literal">C3</span> when <span class="docutils literal">n</span> is <span class="docutils literal">0</span></p></li>
<li><p>that <span class="docutils literal">x</span> must be <span class="docutils literal">C2</span> when <span class="docutils literal">n</span> is <span class="docutils literal">1</span></p></li>
<li><p>that <span class="docutils literal">x</span> must have been forged from a contradiction otherwise</p></li>
</ul>
<p>Similarly, if you receive a <span class="docutils literal">y</span> of type <span class="docutils literal">F T 0</span>, you know that you
need only pattern-match against <span class="docutils literal">C1</span> and <span class="docutils literal">C3</span>.</p>
<hr class="docutils" />
<p><strong>Q:</strong> Is there any advantage other than readability to declaring
parameters as parameters (e.g. left of the colon) as opposed to as
index? Can the type checker always recover the information which of
the indices is a parameter?</p>
<p><strong>A:</strong> Yes, putting parameters on the left affects the shape of the
eliminators generated by Coq, as well as the type-checking for
depedent pattern-matching. It is &quot;better&quot; to put parameters on the
left, as it indicates to Coq that the type is &quot;uniform&quot; in the choice
of those parameters, which simplifies things for you down the road.</p>
</section>
<section id="answer-user3237465">
<h2>Answer (user3237465)</h2>
<p>Here is an example of a type paramerised by some value:</p>
<pre class="code agda literal-block"><code><span class="kr">open</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="n">Data.Nat</span><span class="w">

</span><span class="kr">infixr</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span>_∷_<span class="w">

</span><span class="kr">data</span><span class="w"> </span>≤List<span class="w"> </span><span class="o">(</span>n<span class="w"> </span><span class="ow">:</span><span class="w"> </span>ℕ<span class="o">)</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="kr">where</span><span class="w">
  </span><span class="nf">[]</span><span class="w">  </span><span class="ow">:</span><span class="w"> </span>≤List<span class="w"> </span>n<span class="w">
  </span><span class="nf">_∷_</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="o">{</span>m<span class="w"> </span><span class="ow">:</span><span class="w"> </span>ℕ<span class="o">}</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span>m<span class="w"> </span>≤<span class="w"> </span>n<span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span>≤List<span class="w"> </span>n<span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span>≤List<span class="w"> </span>n<span class="w">

</span><span class="nf">1≤3</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span>≤<span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="mi">1</span>≤3<span class="w"> </span><span class="ow">=</span><span class="w"> </span>s≤s<span class="w"> </span>z≤n<span class="w">

</span><span class="nf">3≤3</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span>≤<span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="mi">3</span>≤3<span class="w"> </span><span class="ow">=</span><span class="w"> </span>s≤s<span class="w"> </span><span class="o">(</span>s≤s<span class="w"> </span><span class="o">(</span>s≤s<span class="w"> </span>z≤n<span class="o">))</span><span class="w">

</span><span class="nf">example</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>≤List<span class="w"> </span><span class="mi">3</span><span class="w">
</span>example<span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">3</span>≤3<span class="w"> </span>∷<span class="w"> </span><span class="mi">1</span>≤3<span class="w"> </span>∷<span class="w"> </span>[]</code></pre>
<p>It's a type of lists with every element less or equal <span class="docutils literal">n</span>. The general intuition is: if some property holds for every inhabitant of a type, then you can abstract it into parameter. There is a mechanical rule also: &quot;The first index can be turned into a new parameter if each constructor has the same variable on the first index position (in the result type).&quot; This quote is from <a class="footnote-reference brackets" href="#footnote-1" id="footnote-reference-1" role="doc-noteref"><span class="fn-bracket">[</span>*<span class="fn-bracket">]</span></a>, you should read it.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footnote-1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#footnote-reference-1">*</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://people.inf.elte.hu/divip/AgdaTutorial/Sets.Parameters_vs_Indices.html">http://people.inf.elte.hu/divip/AgdaTutorial/Sets.Parameters_vs_Indices.html</a></p>
</aside>
</aside>
</section>
</main>
</div></body>
</html>
