<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>Difference between type parameters and indices?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="difference-between-type-parameters-and-indices">
<h1 class="title">Difference between type parameters and indices?</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/24600256">https://stackoverflow.com/q/24600256</a></td>
</tr>
</tbody>
</table>
<div class="section" id="question">
<h1>Question</h1>
<p>I am new to dependent types and am confused about the difference
between the two. It seems people usually say a type is <em>parameterized
by another type</em> and <em>indexed by some value</em>. But isn't there no
distinction between types and terms in a dependently typed language?
Is the distinction between parameters and indices fundamental? Can you
show me examples showing difference in their meanings in both
programming and theorem proving?</p>
</div>
<div class="section" id="answer-ptival">
<h1>Answer (Ptival)</h1>
<p>When you see a family of types, you may wonder whether each of the
arguments it has are <em>parameters</em> or <em>indices</em>.</p>
<hr class="docutils" />
<p><strong>Parameters</strong> are merely indicative that the type is somewhat
generic, and behaves <em>parametrically</em> with regards to the argument
supplied.</p>
<p>What this means for instance, is that the type <tt class="docutils literal">List T</tt> will have
the same shapes regardless of which <tt class="docutils literal">T</tt> you consider: <tt class="docutils literal">nil</tt>,
<tt class="docutils literal">cons t0 nil</tt>, <tt class="docutils literal">cons t1 (cons t2 nil)</tt>, etc. The choice of <tt class="docutils literal">T</tt>
only affects which values can be plugged for <tt class="docutils literal">t0</tt>, <tt class="docutils literal">t1</tt>, <tt class="docutils literal">t2</tt>.</p>
<hr class="docutils" />
<p><strong>Indices</strong> on the other hand may affect which inhabitants you may
find in the type! That's why we say they <em>index</em> a family of types,
that is, each index tells you which one of the types (within the
family of types) you are looking at (in that sense, a parameter is a
degenerate case where all the indices point to the same set of
&quot;shapes&quot;).</p>
<p>For instance, the type family <tt class="docutils literal">Fin n</tt> or finite sets of size <tt class="docutils literal">n</tt>
contains very different structures depending on your choice of <tt class="docutils literal">n</tt>.</p>
<p>The index <tt class="docutils literal">0</tt> indices an empty set. The index <tt class="docutils literal">1</tt> indices a set
with one element.</p>
<p>In that sense, the knowledge of the value of the index may carry
important information! Usually, you can learn which constructors may
or may not have been used by looking at an index. That's how
pattern-matching in dependently-typed languages can eliminate
non-feasible patterns, and extract information out of the triggering
of a pattern.</p>
<hr class="docutils" />
<p>This is why, when you define inductive families, usually you can
define the parameters for the entire type, but you have to specify the
indices for each constructor (since you are allowed to specify, for
each constructor, what indices it lives at).</p>
<p>For instance I can define:</p>
<pre class="code agda literal-block">
F<span class="w"> </span><span class="o">(</span>T<span class="w"> </span><span class="ow">:</span><span class="w"> </span>Type<span class="o">)</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>ℕ<span class="w"> </span><span class="ow">→</span><span class="w"> </span>Type<span class="w">
</span><span class="nf">C1</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>F<span class="w"> </span>T<span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="nf">C2</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>F<span class="w"> </span>T<span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="nf">C3</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>F<span class="w"> </span>T<span class="w"> </span><span class="mi">0</span>
</pre>
<p>Here, <tt class="docutils literal">T</tt> is a parameter, while <tt class="docutils literal">0</tt> and <tt class="docutils literal">1</tt> are indices. When
you receive some <tt class="docutils literal">x</tt> of type <tt class="docutils literal">F T n</tt>, looking at what <tt class="docutils literal">T</tt> is
will not reveal anything about <tt class="docutils literal">x</tt>. But looking at <tt class="docutils literal">n</tt> will tell
you:</p>
<ul class="simple">
<li>that <tt class="docutils literal">x</tt> must be <tt class="docutils literal">C1</tt> or <tt class="docutils literal">C3</tt> when <tt class="docutils literal">n</tt> is <tt class="docutils literal">0</tt></li>
<li>that <tt class="docutils literal">x</tt> must be <tt class="docutils literal">C2</tt> when <tt class="docutils literal">n</tt> is <tt class="docutils literal">1</tt></li>
<li>that <tt class="docutils literal">x</tt> must have been forged from a contradiction otherwise</li>
</ul>
<p>Similarly, if you receive a <tt class="docutils literal">y</tt> of type <tt class="docutils literal">F T 0</tt>, you know that you
need only pattern-match against <tt class="docutils literal">C1</tt> and <tt class="docutils literal">C3</tt>.</p>
<hr class="docutils" />
<p><strong>Q:</strong> Is there any advantage other than readability to declaring
parameters as parameters (e.g. left of the colon) as opposed to as
index? Can the type checker always recover the information which of
the indices is a parameter?</p>
<p><strong>A:</strong> Yes, putting parameters on the left affects the shape of the
eliminators generated by Coq, as well as the type-checking for
depedent pattern-matching. It is &quot;better&quot; to put parameters on the
left, as it indicates to Coq that the type is &quot;uniform&quot; in the choice
of those parameters, which simplifies things for you down the road.</p>
</div>
<div class="section" id="answer-user3237465">
<h1>Answer (user3237465)</h1>
<p>Here is an example of a type paramerised by some value:</p>
<pre class="code agda literal-block">
<span class="kr">open</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="n">Data.Nat</span><span class="w">

</span><span class="kr">infixr</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span>_∷_<span class="w">

</span><span class="kr">data</span><span class="w"> </span>≤List<span class="w"> </span><span class="o">(</span>n<span class="w"> </span><span class="ow">:</span><span class="w"> </span>ℕ<span class="o">)</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="kr">where</span><span class="w">
  </span><span class="nf">[]</span><span class="w">  </span><span class="ow">:</span><span class="w"> </span>≤List<span class="w"> </span>n<span class="w">
  </span><span class="nf">_∷_</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="o">{</span>m<span class="w"> </span><span class="ow">:</span><span class="w"> </span>ℕ<span class="o">}</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span>m<span class="w"> </span>≤<span class="w"> </span>n<span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span>≤List<span class="w"> </span>n<span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span>≤List<span class="w"> </span>n<span class="w">

</span><span class="nf">1≤3</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span>≤<span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="mi">1</span>≤3<span class="w"> </span><span class="ow">=</span><span class="w"> </span>s≤s<span class="w"> </span>z≤n<span class="w">

</span><span class="nf">3≤3</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span>≤<span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="mi">3</span>≤3<span class="w"> </span><span class="ow">=</span><span class="w"> </span>s≤s<span class="w"> </span><span class="o">(</span>s≤s<span class="w"> </span><span class="o">(</span>s≤s<span class="w"> </span>z≤n<span class="o">))</span><span class="w">

</span><span class="nf">example</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>≤List<span class="w"> </span><span class="mi">3</span><span class="w">
</span>example<span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">3</span>≤3<span class="w"> </span>∷<span class="w"> </span><span class="mi">1</span>≤3<span class="w"> </span>∷<span class="w"> </span>[]
</pre>
<p>It's a type of lists with every element less or equal <tt class="docutils literal">n</tt>. The general intuition is: if some property holds for every inhabitant of a type, then you can abstract it into parameter. There is a mechanical rule also: &quot;The first index can be turned into a new parameter if each constructor has the same variable on the first index position (in the result type).&quot; This quote is from <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[*]</a>, you should read it.</p>
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[*]</a></td><td><a class="reference external" href="http://people.inf.elte.hu/divip/AgdaTutorial/Sets.Parameters_vs_Indices.html">http://people.inf.elte.hu/divip/AgdaTutorial/Sets.Parameters_vs_Indices.html</a></td></tr>
</tbody>
</table>
</div>
</div>
</div></body>
</html>
