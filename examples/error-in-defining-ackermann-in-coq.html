<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>Error in defining Ackermann in Coq</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="error-in-defining-ackermann-in-coq">
<h1 class="title">Error in defining Ackermann in Coq</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/10292421">https://stackoverflow.com/q/10292421</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>I am trying to define the Ackermann-Peters function in Coq, and I'm
getting an error message that I don't understand. As you can see, I'm
packaging the arguments <tt class="docutils literal">a, b</tt> of Ackermann in a pair <tt class="docutils literal">ab</tt>; I
provide an ordering defining an ordering function for the arguments.
Then I use the <tt class="docutils literal">Function</tt> form to define Ackermann itself, providing
it with the ordering function for the <tt class="docutils literal">ab</tt> argument.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Recdef.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ack_ordering</span> (<span class="nv">ab1</span> <span class="nv">ab2</span> : nat * nat) :=
  <span class="kr">match</span> ab1, ab2 <span class="kr">with</span>
  | (a1, b1), (a2, b2) =&gt; a1 &gt; a2 \/ (a1 = a2 /\ b1 &gt; b2)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="error-in-defining-ackermann-in-coq-v-chk0"><span class="kn">Function</span> <span class="nf">ack</span> (ab : nat * nat) {<span class="kn">wf</span> ack_ordering ab} : nat :=
  <span class="kr">match</span> ab <span class="kr">with</span>
  | (<span class="mi">0</span>, b) =&gt; b + <span class="mi">1</span>
  | (a, <span class="mi">0</span>) =&gt; ack (a - <span class="mi">1</span>, <span class="mi">1</span>)
  | (a, b) =&gt; ack (a - <span class="mi">1</span>, ack (a, b - <span class="mi">1</span>))
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">No such section variable or <span class="bp">assumption</span>: ack.</blockquote></div></div></small></span></pre><p>I'm not sure what bothers Coq, but searching the internet, I found a
suggestion there may be a problem with using a recursive function
defined with an ordering or a measure, where the recursive call occurs
within a match. However, using the projections <tt class="docutils literal">fst</tt> and <tt class="docutils literal">snd</tt> and
an <tt class="docutils literal"><span class="pre">if-then-else</span></tt> generated a different error message. Can someone
please suggest how to define Ackermann in Coq?</p>
</div>
<div class="section" id="answer-anton-trunov">
<h1>Answer (Anton Trunov)</h1>
<p>It seems like <tt class="docutils literal">Function</tt> can't solve this problem. However, its
cousin <tt class="docutils literal">Program Fixpoint</tt> can.</p>
<p>Let's define some lemmas treating well-foundedness first:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Program.Wf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Arith.Arith.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">lexicographic_ordering</span> (<span class="nv">ab1</span> <span class="nv">ab2</span> : nat * nat) : <span class="kt">Prop</span> :=
  <span class="kr">match</span> ab1, ab2 <span class="kr">with</span>
  | (a1, b1), (a2, b2) =&gt; a1 &lt; a2 \/ (a1 = a2 /\ b1 &lt; b2)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* this is defined in stdlib, but unfortunately it is opaque *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk1"><span class="kn">Lemma</span> <span class="nf">lt_wf_ind</span> : <span class="kr">forall</span> <span class="nv">n</span> (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>),
    (<span class="kr">forall</span> <span class="nv">n</span>, (<span class="kr">forall</span> <span class="nv">m</span>, m &lt; n -&gt; P m) -&gt; P n) -&gt; P n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>),
(<span class="kr">forall</span> <span class="nv">n0</span> : nat,
 (<span class="kr">forall</span> <span class="nv">m</span> : nat, m &lt; n0 -&gt; P m) -&gt; P n0) -&gt; P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>),
(<span class="kr">forall</span> <span class="nv">n0</span> : nat,
 (<span class="kr">forall</span> <span class="nv">m</span> : nat, m &lt; n0 -&gt; P m) -&gt; P n0) -&gt; P n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk3"><span class="nb">intro</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>,
(<span class="kr">forall</span> <span class="nv">n</span> : nat, (<span class="kr">forall</span> <span class="nv">m</span> : nat, m &lt; n -&gt; P m) -&gt; P n) -&gt;
P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk4"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">m</span> : nat, m &lt; n -&gt; P m) -&gt; P n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk5"><span class="nb">elim</span> (lt_wf p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">m</span> : nat, m &lt; n -&gt; P m) -&gt; P n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : nat,
(<span class="kr">forall</span> <span class="nv">y</span> : nat, y &lt; x -&gt; Acc lt y) -&gt;
(<span class="kr">forall</span> <span class="nv">y</span> : nat, y &lt; x -&gt; P y) -&gt; P x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto with</span> arith.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* this is defined in stdlib, but unfortunately it is opaque too *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk6"><span class="kn">Lemma</span> <span class="nf">lt_wf_double_ind</span> : <span class="kr">forall</span> <span class="nv">P</span> : nat -&gt; nat -&gt; <span class="kt">Prop</span>,
    (<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>,
        (<span class="kr">forall</span> <span class="nv">p</span> (<span class="nv">q</span> : nat), p &lt; n -&gt; P p q) -&gt;
        (<span class="kr">forall</span> <span class="nv">p</span>, p &lt; m -&gt; P n p) -&gt; P n m) -&gt; <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>, P n m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : nat -&gt; nat -&gt; <span class="kt">Prop</span>,
(<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span> : nat, p &lt; n -&gt; P p q) -&gt;
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; m -&gt; P n p) -&gt; P n m) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, P n m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : nat -&gt; nat -&gt; <span class="kt">Prop</span>,
(<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat,
 (<span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span> : nat, p &lt; n -&gt; P p q) -&gt;
 (<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; m -&gt; P n p) -&gt; P n m) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, P n m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk8"><span class="nb">intros</span> P Hrec p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Hrec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span> : nat, p &lt; n -&gt; P p q) -&gt;
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; m -&gt; P n p) -&gt; P n m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">m</span> : nat, P p m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk9"><span class="nb">pattern</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Hrec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span> : nat, p &lt; n -&gt; P p q) -&gt;
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; m -&gt; P n p) -&gt; P n m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; <span class="kr">forall</span> <span class="nv">m</span> : nat, P n m) p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chka"><span class="nb">apply</span> lt_wf_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Hrec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span> : nat, p &lt; n -&gt; P p q) -&gt;
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; m -&gt; P n p) -&gt; P n m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">m</span> : nat, m &lt; n -&gt; <span class="kr">forall</span> <span class="nv">m0</span> : nat, P m m0) -&gt;
<span class="kr">forall</span> <span class="nv">m</span> : nat, P n m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chkb"><span class="nb">intros</span> n H q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Hrec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span> : nat, p &lt; n -&gt; P p q) -&gt;
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; m -&gt; P n p) -&gt; P n m</span></span></span><br><span><var>p, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : nat, m &lt; n -&gt; <span class="kr">forall</span> <span class="nv">m0</span> : nat, P m m0</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chkc"><span class="nb">pattern</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Hrec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span> : nat, p &lt; n -&gt; P p q) -&gt;
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; m -&gt; P n p) -&gt; P n m</span></span></span><br><span><var>p, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : nat, m &lt; n -&gt; <span class="kr">forall</span> <span class="nv">m0</span> : nat, P m m0</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; P n n0) q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chkd"><span class="nb">apply</span> lt_wf_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Hrec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span> : nat, p &lt; n -&gt; P p q) -&gt;
(<span class="kr">forall</span> <span class="nv">p</span> : nat, p &lt; m -&gt; P n p) -&gt; P n m</span></span></span><br><span><var>p, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : nat, m &lt; n -&gt; <span class="kr">forall</span> <span class="nv">m0</span> : nat, P m m0</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n0</span> : nat,
(<span class="kr">forall</span> <span class="nv">m</span> : nat, m &lt; n0 -&gt; P n m) -&gt; P n n0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chke"><span class="kn">Lemma</span> <span class="nf">lexicographic_ordering_wf</span> : well_founded lexicographic_ordering.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lexicographic_ordering</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chkf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lexicographic_ordering</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk10"><span class="nb">intros</span> (a, b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lexicographic_ordering (a, b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk11"><span class="nb">pattern</span> a, b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">n0</span> : nat =&gt; Acc lexicographic_ordering (n, n0))
  a b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk12"><span class="nb">apply</span> lt_wf_double_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat,
(<span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span> : nat,
 p &lt; n -&gt; Acc lexicographic_ordering (p, q)) -&gt;
(<span class="kr">forall</span> <span class="nv">p</span> : nat,
 p &lt; m -&gt; Acc lexicographic_ordering (n, p)) -&gt;
Acc lexicographic_ordering (n, m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk13"><span class="nb">intros</span> m n H1 H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span> : nat,
p &lt; m -&gt; Acc lexicographic_ordering (p, q)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat,
p &lt; n -&gt; Acc lexicographic_ordering (m, p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lexicographic_ordering (m, n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk14"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span> : nat,
p &lt; m -&gt; Acc lexicographic_ordering (p, q)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat,
p &lt; n -&gt; Acc lexicographic_ordering (m, p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : nat * nat,
lexicographic_ordering y (m, n) -&gt;
Acc lexicographic_ordering y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk15"><span class="nb">intros</span> (m&#39;, n&#39;) [G | [-&gt; G]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span> : nat,
p &lt; m -&gt; Acc lexicographic_ordering (p, q)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat,
p &lt; n -&gt; Acc lexicographic_ordering (m, p)</span></span></span><br><span><var>m', n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>m&#39; &lt; m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lexicographic_ordering (m&#39;, n&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="error-in-defining-ackermann-in-coq-v-chk16" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span> : nat,
p &lt; m -&gt; Acc lexicographic_ordering (p, q)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat,
p &lt; n -&gt; Acc lexicographic_ordering (m, p)</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>n&#39; &lt; n</span></span></span><br></div><label class="goal-separator" for="error-in-defining-ackermann-in-coq-v-chk16"><hr></label><div class="goal-conclusion">Acc lexicographic_ordering (m, n&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk17">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span> : nat,
p &lt; m -&gt; Acc lexicographic_ordering (p, q)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat,
p &lt; n -&gt; Acc lexicographic_ordering (m, p)</span></span></span><br><span><var>m', n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>m&#39; &lt; m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lexicographic_ordering (m&#39;, n&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> H1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk18">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span> : nat,
p &lt; m -&gt; Acc lexicographic_ordering (p, q)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : nat,
p &lt; n -&gt; Acc lexicographic_ordering (m, p)</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>n&#39; &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lexicographic_ordering (m, n&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> H2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>Now we can define the Ackermann-Péter function:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Fixpoint</span> <span class="nf">ack</span> (<span class="nv">ab</span> : nat * nat) {<span class="nv">wf</span> <span class="nv">lexicographic_ordering</span> <span class="nv">ab</span>} : nat :=
  <span class="kr">match</span> ab <span class="kr">with</span>
  | (<span class="mi">0</span>, b) =&gt; b + <span class="mi">1</span>
  | (S a, <span class="mi">0</span>) =&gt; ack (a, <span class="mi">1</span>)
  | (S a, S b) =&gt; ack (a, ack (S a, b))
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk19"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ack</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ab</span> : nat * nat, lexicographic_ordering ab (n, n0) -&gt; nat</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq_ab</var><span class="hyp-type"><b>: </b><span>(S a, S b) = (n, n0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a &lt; n \/
a = n /\
ack (S a, b) (ack_obligation_2 (n, n0) ack a b Heq_ab) &lt;
n0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk1a"><span class="nb">inversion</span> Heq_ab.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ack</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ab</span> : nat * nat,
lexicographic_ordering ab (n, n0) -&gt; nat</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq_ab</var><span class="hyp-type"><b>: </b><span>(S a, S b) = (n, n0)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>S a = n</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>S b = n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a &lt; n \/
a = n /\
ack (S a, b) (ack_obligation_2 (n, n0) ack a b Heq_ab) &lt;
n0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk1b"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq_ab</var><span class="hyp-type"><b>: </b><span>(S a, S b) = (S a, S b)</span></span></span><br><span><var>ack</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ab</span> : nat * nat,
lexicographic_ordering ab (S a, S b) -&gt; nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a &lt; S a \/
a = S a /\
ack (S a, b)
  (ack_obligation_2 (S a, S b) ack a b Heq_ab) &lt; 
S b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk1c"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq_ab</var><span class="hyp-type"><b>: </b><span>(S a, S b) = (S a, S b)</span></span></span><br><span><var>ack</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ab</span> : nat * nat,
lexicographic_ordering ab (S a, S b) -&gt; nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a &lt; S a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="error-in-defining-ackermann-in-coq-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="error-in-defining-ackermann-in-coq-v-chk1d"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded
  (MR lexicographic_ordering
     (<span class="kr">fun</span> <span class="nv">recarg</span> : nat * nat =&gt; recarg))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> lexicographic_ordering_wf.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>Some simple tests demonstrating that we can compute with <tt class="docutils literal">ack</tt>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">test1</span> : ack (<span class="mi">1</span>, <span class="mi">2</span>) = <span class="mi">4</span> := eq_refl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">test2</span> : ack (<span class="mi">3</span>, <span class="mi">4</span>) = <span class="mi">125</span> := eq_refl. <span class="c">(* this may take several seconds *)</span></span></span></pre><hr class="docutils" />
<p>Using the <a class="reference external" href="http://mattam82.github.io/Coq-Equations/">Equations</a>
plugin by M. Sozeau and C. Mangin it is possible to define the
function this way:</p>
<pre class="code coq literal-block">
<span class="kn">From</span> <span class="kn">Equations</span> <span class="nf">Require</span> <span class="nv">Import</span> <span class="nv">Equations</span> <span class="nv">Subterm</span><span class="o">.</span>

<span class="kn">Equations</span> <span class="nf">ack</span> <span class="o">(</span><span class="nv">p</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">*</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span>
  <span class="n">ack</span> <span class="n">p</span> <span class="bp">by</span> <span class="n">rec</span> <span class="n">p</span> <span class="o">(</span><span class="n">lexprod</span> <span class="n">_</span> <span class="n">_</span> <span class="n">lt</span> <span class="n">lt</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">ack</span> <span class="o">(</span><span class="n">pair</span> <span class="mi">0</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
  <span class="n">ack</span> <span class="o">(</span><span class="n">pair</span> <span class="o">(</span><span class="n">S</span> <span class="n">m</span><span class="o">)</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ack</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
  <span class="n">ack</span> <span class="o">(</span><span class="n">pair</span> <span class="o">(</span><span class="n">S</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="n">ack</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">ack</span> <span class="o">(</span><span class="n">S</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">)).</span>
</pre>
<p>Unfortunately, it's not possible to use the <tt class="docutils literal">( , )</tt> notation for
pairs due to <a class="reference external" href="https://github.com/mattam82/Coq-Equations/issues/81">issue #81</a>. The code is
taken from Equation's test suite: <a class="reference external" href="https://github.com/mattam82/Coq-Equations/blob/71b3b266563b18b47a8bd2677e65e94f08674283/test-suite/ack.v">ack.v</a>.</p>
</div>
<div class="section" id="answer-wires">
<h1>Answer (wires)</h1>
<p>You get this error because you are referencing the <tt class="docutils literal">ack</tt> function
while you are defining it. Self reference is only allowed in
<tt class="docutils literal">Fixpoint</tt>s (ie. recursive functions) but the problem is, as you
probably know, that the Ackermann function is not a primitive
recursive function.</p>
<p>See <a class="reference external" href="http://books.google.nl/books?id=m5w5PRj5Nj4C&amp;pg=PA95">Coq'Art section 4.3.2.2</a> for some
more information on this.</p>
<p>So one alternative way to define it is by inlining a second recursive
function that is structurally recursive for the second argument; so
something like</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">ack</span> (<span class="nv">n</span> <span class="nv">m</span> : nat) : nat :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | O =&gt; S m
  | S p =&gt; <span class="kr">let fix</span> <span class="nv">ackn</span> (<span class="nv">m</span> : nat) :=
             <span class="kr">match</span> m <span class="kr">with</span>
             | O =&gt; ack p <span class="mi">1</span>
             | S q =&gt; ack p (ackn q)
             <span class="kr">end</span>
           <span class="kr">in</span> ackn m
  <span class="kr">end</span>.</span></span></pre><hr class="docutils" />
<p><strong>Q:</strong> I wasn't using <tt class="docutils literal">Fixpoint</tt>, but <tt class="docutils literal">Function</tt>. This is supposed
to work with total functions that have a decreasing argument, and I
should be able to do so using either a measure or a comparison,
followed by a theorem that arguments in recursive calls either have a
smaller measure or are less than the original arguments, as per the
comparator. I know Ackermann is 2nd-order PR, but obviously the PR
status of the function didn't prevent you from encoding it in some
way. What I'm wondering about is what is wrong with the encoding I
gave, which seems to follow the description in the manual.</p>
</div>
</div>
</div>
</div></body>
</html>
