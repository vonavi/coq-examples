<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Why do Calculus of Construction based languages use Setoids so much?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="why-do-calculus-of-construction-based-languages-use-setoids-so-much">
<h1 class="title">Why do Calculus of Construction based languages use Setoids so much?</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/65493694">https://stackoverflow.com/q/65493694</a></p>
</dd>
</dl>
<section id="question">
<h2>Question</h2>
<p>One finds that Setoids are widely used in languages such as Agda, Coq,
... Indeed languages such as Lean have argued that they could help
avoid &quot;Setoid Hell&quot;. What is the reason for using Setoids in the first
place? Does the move to extensional type theories based on HoTT (such
as cubical Agda) reduce the need for Setoids?</p>
</section>
<section id="answer-floris-van-doorn">
<h2>Answer (Floris van Doorn)</h2>
<p>As Li-yao Xia's answer describes, setoids are used when we don't have
or don't want to use quotients.</p>
<p>In the HoTT book and in Lean quotients are (basically) axiomatized.
One difference between Lean and the HoTT book is that the latter has
many more higher inductive types, and Lean only has quotients and
(regular) inductive types. If we just restrict our attention to
quotients (set quotients in the HoTT book), it works the same in Lean
and in Book HoTT. In this case you just postulate that given a type
<span class="docutils literal">A</span> and an equivalence <span class="docutils literal">R</span> on <span class="docutils literal">A</span> you have a quotient <span class="docutils literal">Q</span>, and
a function <span class="docutils literal"><span class="pre">[-]</span> : A <span class="pre">-&gt;</span> Q</span> with the property <span class="docutils literal">forall x y : A, R x y <span class="pre">-&gt;</span> [x] = [y]</span>. It comes with the following elimination principle: to
construct a function <span class="docutils literal">g : Q <span class="pre">-&gt;</span> X</span> for some type <span class="docutils literal">X</span> (or hSet <span class="docutils literal">X</span>
in HoTT) we need a function <span class="docutils literal">f : A <span class="pre">-&gt;</span> X</span> such that we can prove
<span class="docutils literal">forall x y : A, R x y <span class="pre">-&gt;</span> f x = f y</span>. This comes with the
computation rule, that states <span class="docutils literal">forall x : A, g [x] === f x</span> (this is
a definitional equality in both Lean and Book HoTT).</p>
<p>The main disadvantage of this quotient is that it breaks canonicity.
Canonicity states that every closed term (that is, a term without free
variables) in (say) the natural numbers normalizes to either zero or
the successor of some natural number. The reason that this quotient
breaks canonicity is that we can apply the elimination principle for
<span class="docutils literal">=</span> to the new equalities in a quotient, and a term like that will
not reduce. In Lean the opinion is that this doesn't matter, since in
all cases we care about we can still prove an equality, even though it
might not be a definitional equality.</p>
<p>Cubical type theory has a fancy way to work with quotients while
retaining canonicity. In CTT equality works differently, and this
means that higher inductive types can be introduced while keeping
canonicity. Potential disadvantages of CTT are that the type theory is
a lot more complicated, and that you have to embrace HoTT (and in
particular give up on proof irrelevance).</p>
</section>
<section id="answer-jacques-carette">
<h2>Answer (Jacques Carette)</h2>
<p>[The answers by Lia-yao Xia and Floris van Doorn are both excellent,
so I will try to augment them with additional information.]</p>
<p>Another view is that quotients, while used a lot in classical
mathematics, are perhaps not so great after all. Not taking quotients
but sticking to Groupoids is <strong>exactly</strong> where <em>non-commutative
geometry</em> starts from! It teaches us that some quotients are
incredibly badly behaved, and the last thing we want to do (in those
cases!) is to actually quotient. But that the thing itself is not so
bad, even quite good, if you treat it using the 'right' tools.</p>
<p>It is arguably also deeply embedded in all of category theory, where
one doesn't quotient out equivalent objects. Taking of 'skeletons' in
category theory is regarded to be in bad taste. The same is true of
strictness, and a host of other things, all of which boil down to
trying to squish things down that are better left as they are, as they
do no harm at all. We're just used to wanting 'uniqueness' to be
reflected in our representations - something we should just get over.</p>
<p>Setoid hell arises not because some coherences must be proven (you
need to prove them to show you have a proper equivalence, and again
whenever you define functions on raw representations instead of on the
quotiented version). It arises when you're forced to prove these
coherences again and again when defining functions that can't possibly
&quot;go wrong&quot;. So Setoid hell is actually caused by a failure to provide
proper abstraction mechanisms.</p>
<p>In other words, if you're doing sufficient simple mathematics, where
quotients are well-behaved, then there should be some automation that
lets you work with that smoothly. Currently, in type theory, working
out exactly what that could look like, is ongoing research. Floris'
answer outlines well what one pitfall is: at some point, you give up
that <span class="docutils literal">computations</span> will be well-behaved, and from then on, are
forced to do everything via proofs.</p>
</section>
<section id="answer-li-yao-xia">
<h2>Answer (Li-yao Xia)</h2>
<p>Ideally one would certainly like to be able to treat arbitrary
equivalence relations as Leibniz equality (<span class="docutils literal">eq</span>), enabling rewriting
in arbitrary contexts. That means to define the <strong>quotient</strong> of a type
by an equivalence relation.</p>
<p>I'm not an expert on the topic, but I've been wondering the same for a
while, and I think the reliance on setoids stems from the fact that
quotients are still a poorly understood concept in type theory.</p>
<ol class="arabic simple">
<li><p>Setoid Hell is where we're stuck when we don't have/want quotient
types.</p></li>
<li><p>We can axiomatize quotient types, I believe (I could be mistaken)
that's what Lean does.</p></li>
<li><p>We can develop a type theory which can naturally express quotients,
that's what HoTT/Cubical TT do with higher inductive types.</p></li>
</ol>
<p>Furthermore, quotient types (or my naive imagination of them) force us
to package programs and proofs together in a perhaps less-than-ideal
way: a function between two quotient types is a plain function
together with a proof that it respects the underlying equivalence
relation. While one can technically do that, this interleaving of
programming and proving is arguably indesirable because it makes
programs unreadable: one often seeks to either keep programs and
proofs in two completely separate worlds (so that mandates setoids,
keeping types separate from their equivalence relations), or to change
some representations so the program and the proof are one and the same
entity (so we might not even need to explicitly reason about
equivalences in the first place).</p>
</section>
</main>
</div></body>
</html>
