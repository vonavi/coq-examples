<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Inductive definition for family of types</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="inductive-definition-for-family-of-types">
<h1 class="title">Inductive definition for family of types</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/37366941">https://stackoverflow.com/q/37366941</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>I have been struggling on this for a while now. I have an inductive
type:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">char</span> := nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">string</span> := list char.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Exp</span> : <span class="kt">Set</span> :=
| Lit  : char -&gt; Exp
| And  : Exp -&gt; Exp -&gt; Exp
| Or   : Exp -&gt; Exp -&gt; Exp
| Many : Exp -&gt; Exp.</span></span></pre><p>from which I define a family of types inductively:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Language</span> : Exp -&gt; <span class="kt">Set</span> :=
| LangLit     : <span class="kr">forall</span> <span class="nv">c</span> : char, Language (Lit c)
| LangAnd     :
  <span class="kr">forall</span> <span class="nv">r1</span> <span class="nv">r2</span> : Exp, Language(r1) -&gt; Language(r2) -&gt; Language(And r1 r2)
| LangOrLeft  : <span class="kr">forall</span> <span class="nv">r1</span> <span class="nv">r2</span> : Exp, Language(r1) -&gt; Language(Or r1 r2)
| LangOrRight : <span class="kr">forall</span> <span class="nv">r1</span> <span class="nv">r2</span> : Exp, Language(r2) -&gt; Language(Or r1 r2)
| LangEmpty   : <span class="kr">forall</span> <span class="nv">r</span> : Exp, Language (Many r)
| LangMany    :
  <span class="kr">forall</span> <span class="nv">r</span> : Exp, Language (Many r) -&gt; Language r -&gt; Language (Many r).</span></span></pre><p>The rational here is that given a regular expression <span class="docutils literal">r : Exp</span> I am
attempting to represent the language associated with <span class="docutils literal">r</span> as a type
<span class="docutils literal">Language r</span>, and I am doing so with a single inductive definition.</p>
<p>I would like to prove:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="inductive-definition-for-family-of-types-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="inductive-definition-for-family-of-types-v-chk0"><span class="kn">Lemma</span> <span class="nf">L1</span> : <span class="kr">forall</span> (<span class="nv">c</span> : char) (<span class="nv">x</span> : Language (Lit c)),
    x = LangLit c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">c</span> : char) (<span class="nv">x</span> : Language (Lit c)),
x = LangLit c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>(In other words, the type <span class="docutils literal">Language (Lit c)</span> has only one element,
i.e. the language of the regular expression <span class="docutils literal">'c'</span> is made of the
single string <span class="docutils literal">&quot;c&quot;</span>. Of course I need to define some semantics
converting elements of <span class="docutils literal">Language r</span> to <span class="docutils literal">string</span>)</p>
<p>Now the specifics of this problem are not important and simply serve
to motivate my question: let us use <span class="docutils literal">nat</span> instead of <span class="docutils literal">Exp</span> and let
us define a type <span class="docutils literal">List n</span> which represents the lists of length
<span class="docutils literal">n</span>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">A</span> : <span class="kt">Set</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">List</span> : nat -&gt; <span class="kt">Set</span> :=
| ListNil  : List <span class="mi">0</span>
| ListCons : <span class="kr">forall</span> <span class="nv">n</span> : nat, A -&gt; List n -&gt; List (S n).</span></span></pre><p>Here again I am using a single inductive definition to define a family
of types <span class="docutils literal">List n</span>.</p>
<p>I would like to prove:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="inductive-definition-for-family-of-types-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="inductive-definition-for-family-of-types-v-chk1"><span class="kn">Lemma</span> <span class="nf">L2</span> : <span class="kr">forall</span> <span class="nv">x</span> : List <span class="mi">0</span>, x = ListNil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : List <span class="mi">0</span>, x = ListNil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>(in other words, the type <span class="docutils literal">List 0</span> has only one element).</p>
<p>I have run out of ideas on this one.</p>
<p>Normally when attempting to prove (negative) results with inductive
types (or predicates), I would use the <span class="docutils literal">elim</span> tactic (having made
sure all the relevant hypothesis are inside my goal (<span class="docutils literal">generalize</span>)
and only variables occur in the type constructors). But <span class="docutils literal">elim</span> is no
good in this case.</p>
</section>
<section id="answer">
<h2>Answer</h2>
<p>If you are willing to accept more than just the basic logic of Coq,
you can just use the <span class="docutils literal">dependent destruction</span> tactic, available in
the <span class="docutils literal">Program</span> library (I've taken the liberty of rephrasing your
last example in terms of standard-library vectors):</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require</span> Coq.Vectors.Vector.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Program.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="inductive-definition-for-family-of-types-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="inductive-definition-for-family-of-types-v-chk2"><span class="kn">Lemma</span> <span class="nf">l0</span> <span class="nv">A</span> (<span class="nv">v</span> : Vector.t A <span class="mi">0</span>) : v = @Vector.nil A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">v = Vector.nil A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="inductive-definition-for-family-of-types-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="inductive-definition-for-family-of-types-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">v = Vector.nil A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">dependent destruction</span> v.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>If you inspect the term, you'll see that this tactic relied on the
<span class="docutils literal">JMeq_eq</span> axiom to get the proof to go through:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="inductive-definition-for-family-of-types-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="inductive-definition-for-family-of-types-v-chk4"><span class="kn">Print Assumptions</span> l0.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Axioms</span>:
JMeq_eq : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> <span class="nv">y</span> : A), x ~= y -&gt; x = y</blockquote></div></div></small></span></pre><p>Fortunately, it is possible to prove <span class="docutils literal">l0</span> without having to resort
to features outside of Coq's basic logic, by making a small change to
the statement of the previous lemma.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="inductive-definition-for-family-of-types-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="inductive-definition-for-family-of-types-v-chk5"><span class="kn">Lemma</span> <span class="nf">l0_gen</span> <span class="nv">A</span> <span class="nv">n</span> (<span class="nv">v</span> : Vector.t A n) :
  <span class="kr">match</span> n <span class="kr">return</span> Vector.t A n -&gt; <span class="kt">Prop</span> <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">v</span> =&gt; v = @Vector.nil A
  | _ =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="kt">True</span>
  <span class="kr">end</span> v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> n <span class="kr">return</span> (Vector.t A n -&gt; <span class="kt">Prop</span>) <span class="kr">with</span>
| <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">v</span> : Vector.t A <span class="mi">0</span> =&gt; v = Vector.nil A
| S n0 =&gt; <span class="kr">fun</span> <span class="nv">_</span> : Vector.t A (S n0) =&gt; <span class="kt">True</span>
<span class="kr">end</span> v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="inductive-definition-for-family-of-types-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="inductive-definition-for-family-of-types-v-chk6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> n <span class="kr">return</span> (Vector.t A n -&gt; <span class="kt">Prop</span>) <span class="kr">with</span>
| <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">v</span> : Vector.t A <span class="mi">0</span> =&gt; v = Vector.nil A
| S n0 =&gt; <span class="kr">fun</span> <span class="nv">_</span> : Vector.t A (S n0) =&gt; <span class="kt">True</span>
<span class="kr">end</span> v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">destruct</span> v.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="inductive-definition-for-family-of-types-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="inductive-definition-for-family-of-types-v-chk7"><span class="kn">Lemma</span> <span class="nf">l0&#39;</span> <span class="nv">A</span> (<span class="nv">v</span> : Vector.t A <span class="mi">0</span>) : v = @Vector.nil A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">v = Vector.nil A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="inductive-definition-for-family-of-types-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="inductive-definition-for-family-of-types-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">v = Vector.nil A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (l0_gen A <span class="mi">0</span> v).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>We can see that this new proof does not require any additional axioms:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="inductive-definition-for-family-of-types-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="inductive-definition-for-family-of-types-v-chk9"><span class="kn">Print Assumptions</span> l0&#39;.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Closed <span class="nb">under</span> the <span class="kn">global</span> <span class="kp">context</span></blockquote></div></div></small></span></pre><p>What happened here? The problem, roughly speaking, is that in Coq we
cannot perform case analysis on terms of dependent types whose indices
have a specific shape (such as <span class="docutils literal">0</span>, in your case) <em>directly</em>.
Instead, we must prove a more general statement where the problematic
indices are replaced by variables. This is exactly what the <span class="docutils literal">l0_gen</span>
lemma is doing. Notice how we had to make the match on <span class="docutils literal">n</span> return a
function that abstracts on <span class="docutils literal">v</span>. This is another instance of what is
known as <a class="reference external" href="http://adam.chlipala.net/cpdt/html/Cpdt.MoreDep.html">&quot;convoy pattern&quot;</a>. Had we
written</p>
<pre class="code coq literal-block"><code><span class="kr">match</span> <span class="n">n</span> <span class="kr">with</span>
<span class="o">|</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="o">&#64;</span><span class="n">Vector</span><span class="o">.</span><span class="n">nil</span> <span class="n">A</span>
<span class="o">|</span> <span class="n">_</span> <span class="o">=&gt;</span> <span class="kt">True</span>
<span class="kr">end</span><span class="o">.</span></code></pre>
<p>Coq would see the <span class="docutils literal">v</span> in the <span class="docutils literal">0</span> branch as having type <span class="docutils literal">Vector.t A n</span>, making that branch ill-typed.</p>
<p>Coming up with such generalizations is one of the big pains of doing
dependently typed programming in Coq. Other systems, such as Agda,
make it possible to write this kind of code with much less effort, but
it was only recently <a class="reference external" href="https://people.cs.kuleuven.be/~jesper.cockx/Without-K/Pattern-matching-without-K.pdf">shown</a>
that this can be done without relying on the extra axioms that Coq
wanted to avoid including in its basic theory. We can only hope that
this will be simplified in future versions.</p>
<hr class="docutils" />
<p><strong>A:</strong> I also find this alternative proof <span class="docutils literal">by apply: eq_dep_eq; move E: {1 2}0 v =&gt; iz v; case: iz / v E.</span> useful sometimes. Indeed,
<span class="docutils literal">eq_dep</span> and similar tricks can be very useful when working with
dependent types.</p>
</section>
</div>
</main>
</div></body>
</html>
