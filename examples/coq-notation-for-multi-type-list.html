<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Coq notation for multi type list</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="coq-notation-for-multi-type-list">
<h1 class="title">Coq notation for multi type list</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/26755507">https://stackoverflow.com/q/26755507</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>Here is a contrived multi type list:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Apple</span> : <span class="kt">Set</span> :=.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Pear</span> : <span class="kt">Set</span> :=.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">FruitList</span> : <span class="kt">Set</span> :=
| Empty
| Cons_apple (a : Apple) (p : FruitList)
| Cons_pear (p : Pear) (p : FruitList).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-notation-for-multi-type-list-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-notation-for-multi-type-list-v-chk0"><span class="kn">Variable</span> <span class="nv">a</span> : Apple.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Interpreting this declaration <span class="kr">as</span> <span class="kr">if</span> a <span class="kn">global</span>
declaration prefixed <span class="bp">by</span> <span class="s2">&quot;Local&quot;</span>, i.e. <span class="kr">as</span> a <span class="kn">global</span>
declaration which shall not be available without
qualification when imported. [local-declaration,scope]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-notation-for-multi-type-list-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-notation-for-multi-type-list-v-chk1"><span class="kn">Variable</span> <span class="nv">p</span> : Pear.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Interpreting this declaration <span class="kr">as</span> <span class="kr">if</span> a <span class="kn">global</span>
declaration prefixed <span class="bp">by</span> <span class="s2">&quot;Local&quot;</span>, i.e. <span class="kr">as</span> a <span class="kn">global</span>
declaration which shall not be available without
qualification when imported. [local-declaration,scope]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a_fruitList</span> := Cons_apple a (Cons_pear p Empty).</span></span></pre><p>Is there a way to define a list notation for this so that, for
example, <span class="docutils literal">a_fruitList</span> could have been defined by <span class="docutils literal">[p,a]</span> instead?</p>
</section>
<section id="answer-arthur-azevedo-de-amorim">
<h2>Answer (Arthur Azevedo De Amorim)</h2>
<p>The problem is that your list has two cons constructors, whereas the
usual notation mechanism for recursive notations requires you to use
always the same constructors. Coercions can help you overcome part of
this problem:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ApplesAndPears</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">Apple</span> <span class="nv">Pear</span> : <span class="kt">Set</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">FruitList</span> : <span class="kt">Set</span> :=
  | Nil
  | ConsApple (a : Apple) (l : FruitList)
  | ConsPear (p : Pear) (l : FruitList).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Fruit</span> : <span class="kt">Set</span> :=
  | IsApple (a : Apple)
  | IsPear (p : Pear).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">IsApple</span> : Apple &gt;-&gt; Fruit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">IsPear</span> : Pear &gt;-&gt; Fruit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ConsFruit</span> (<span class="nv">f</span> : Fruit) (<span class="nv">l</span> : FruitList) : FruitList :=
    <span class="kr">match</span> f <span class="kr">with</span>
    | IsApple a =&gt; ConsApple a l
    | IsPear p =&gt; ConsPear p l
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ ]&quot;</span> := (Nil) (<span class="kn">at level</span> <span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ x ; .. ; y ]&quot;</span> := (ConsFruit x .. (ConsFruit y Nil) ..) (<span class="kn">at level</span> <span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">a</span> : Apple.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">p</span> : Pear.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a_fruitList</span> := [ a ; p ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ApplesAndPears</span>.</span></span></pre><p>(By the way, I'm assuming that you really meant to write <span class="docutils literal">[ a ; p ]</span>, and not <span class="docutils literal">[ p ; a ]</span>. If you did mean to write <span class="docutils literal">[ p ; a ]</span>,
then you just have to use a <span class="docutils literal">SnocFruit</span> function instead, that adds
the element to the end of the list. However, this would make the
problems explained later even worse.)</p>
<p>Now, we've defined a new function to replace the constructors, and can
use that function instead, by declaring the constructors of <span class="docutils literal">Fruit</span>
to be coercions.</p>
<p>This solution is not entirely satisfactory, of course, because the
term your notation produces makes reference to <span class="docutils literal">ConsFruit</span>, while
ideally it would be nice to have something that picks <span class="docutils literal">ConsApple</span> or
<span class="docutils literal">ConsFruit</span> depending on the argument you give. I suspect there
isn't a way of doing this with the notation mechanism, but I could be
wrong.</p>
<p>This is one of the reasons why I would recommend you to use just the
<span class="docutils literal">list</span> type and declare another type such as <span class="docutils literal">Fruit</span> to hold
<span class="docutils literal">Apple</span> and <span class="docutils literal">Pear</span> instead of using two cons constructors, unless
you have a very good reason not to.</p>
</section>
<section id="answer-virgile">
<h2>Answer (Virgile)</h2>
<p>As mentioned by <a class="reference external" href="https://stackoverflow.com/a/26759446/1633665">Arthur Azevedo De Amorim</a>, the issue is that
the <span class="docutils literal">Notation</span> mechanism of Coq does not take the types of the
sub-expressions into account to discriminate between <span class="docutils literal">Cons_apple</span>
and <span class="docutils literal">Cons_pear</span>. However, you can use <a class="reference external" href="https://coq.inria.fr/distrib/current/refman/Reference-Manual022.html">Type Classes</a>
to do that:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Cons_fruit</span> (<span class="nv">A</span> : <span class="kt">Set</span>) := {
    CONS : A -&gt; FruitList -&gt; FruitList }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">Cons_fruit_apple</span> : Cons_fruit Apple := { CONS := Cons_apple }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">Cons_fruit_pear</span> : Cons_fruit Pear := { CONS := Cons_pear }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot; [ x ; .. ; y ] &quot;</span> := (CONS x .. (CONS y Empty) .. ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">test</span> := [a; p; p; a].</span></span></pre><p>We define here a type class <span class="docutils literal">Cons_fruit</span> containing a single
function, and two instances, one for consing apples and one for
consing pears. We can then use the templated <span class="docutils literal">CONS</span> function in the
notation, and Coq will select the appropriate instance when needed.</p>
<p>Note that this may result in less understandable error messages. For
instance, with</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-notation-for-multi-type-list-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="coq-notation-for-multi-type-list-v-chk2"><span class="kn">Definition</span> <span class="nf">bad</span> := [<span class="mi">0</span>; p].</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The following term contains unresolved implicit arguments:
  [<span class="mi">0</span>; p]
More precisely: 
- <span class="nl">?Cons_fruit</span>: Cannot infer the implicit parameter
  Cons_fruit of CONS whose type <span class="kr">is</span> <span class="s2">&quot;Cons_fruit nat&quot;</span>
  (no type class instance found).</blockquote></div></div></small></span></pre><p>You will get</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="coq-notation-for-multi-type-list-v-chk3" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
The following term contains unresolved implicit arguments:
  [<span class="mi">0</span>; p]
More precisely: 
- <span class="nl">?Cons_fruit</span>: Cannot infer the implicit parameter
  Cons_fruit of CONS whose type <span class="kr">is</span> <span class="s2">&quot;Cons_fruit nat&quot;</span>
  (no type class instance found).</blockquote></div></div></small></span></pre></section>
</div>
</main>
</div></body>
</html>
