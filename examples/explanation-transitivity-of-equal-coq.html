<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>Explanation transitivity of equal Coq</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="explanation-transitivity-of-equal-coq">
<h1 class="title">Explanation transitivity of equal Coq</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/54731299">https://stackoverflow.com/q/54731299</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>I have a proof which is already proved.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="explanation-transitivity-of-equal-coq-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="explanation-transitivity-of-equal-coq-v-chk0"><span class="kn">Lemma</span> <span class="nf">Equal_Trans</span> : <span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, <span class="kr">forall</span> <span class="nv">y</span> <span class="nv">x</span> <span class="nv">z</span> : T,
      Equal x y -&gt; Equal y z -&gt; Equal x z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">y</span> <span class="nv">x</span> <span class="nv">z</span> : T),
Equal x y -&gt; Equal y z -&gt; Equal x z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>And secondly, I have the correction of the addition commutativity
proof.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="explanation-transitivity-of-equal-coq-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="explanation-transitivity-of-equal-coq-v-chk1"><span class="kn">Lemma</span> <span class="nf">Add_com</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : Nat, Equal (<span class="kn">Add</span> x x&#39;) (<span class="kn">Add</span> x&#39; x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : Nat, Equal (<span class="kn">Add</span> x x&#39;) (<span class="kn">Add</span> x&#39; x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="explanation-transitivity-of-equal-coq-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="explanation-transitivity-of-equal-coq-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : Nat, Equal (<span class="kn">Add</span> x x&#39;) (<span class="kn">Add</span> x&#39; x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="explanation-transitivity-of-equal-coq-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="explanation-transitivity-of-equal-coq-v-chk3"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equal (<span class="kn">Add</span> x x&#39;) (<span class="kn">Add</span> x&#39; x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="explanation-transitivity-of-equal-coq-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="explanation-transitivity-of-equal-coq-v-chk4"><span class="nb">induction</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equal (<span class="kn">Add</span> <span class="mi">0</span> x&#39;) (<span class="kn">Add</span> x&#39; <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="explanation-transitivity-of-equal-coq-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span>Equal (<span class="kn">Add</span> x x&#39;) (<span class="kn">Add</span> x&#39; x)</span></span></span><br></div><label class="goal-separator" for="explanation-transitivity-of-equal-coq-v-chk5"><hr></label><div class="goal-conclusion">Equal (<span class="kn">Add</span> (S x) x&#39;) (<span class="kn">Add</span> x&#39; (S x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="explanation-transitivity-of-equal-coq-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="explanation-transitivity-of-equal-coq-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equal (<span class="kn">Add</span> <span class="mi">0</span> x&#39;) (<span class="kn">Add</span> x&#39; <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="explanation-transitivity-of-equal-coq-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="explanation-transitivity-of-equal-coq-v-chk7"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equal x&#39; (<span class="kn">Add</span> x&#39; <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Add_zero.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="explanation-transitivity-of-equal-coq-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="explanation-transitivity-of-equal-coq-v-chk8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span>Equal (<span class="kn">Add</span> x x&#39;) (<span class="kn">Add</span> x&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equal (<span class="kn">Add</span> (S x) x&#39;) (<span class="kn">Add</span> x&#39; (S x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="explanation-transitivity-of-equal-coq-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="explanation-transitivity-of-equal-coq-v-chk9"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span>Equal (<span class="kn">Add</span> x x&#39;) (<span class="kn">Add</span> x&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equal (S (<span class="kn">Add</span> x x&#39;)) (<span class="kn">Add</span> x&#39; (S x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="explanation-transitivity-of-equal-coq-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="explanation-transitivity-of-equal-coq-v-chka"><span class="nb">apply</span> (Equal_Trans Nat (S (<span class="kn">Add</span> x&#39; x))). <span class="c">(* var y *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span>Equal (<span class="kn">Add</span> x x&#39;) (<span class="kn">Add</span> x&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equal (S (<span class="kn">Add</span> x x&#39;)) (S (<span class="kn">Add</span> x&#39; x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="explanation-transitivity-of-equal-coq-v-chkb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span>Equal (<span class="kn">Add</span> x x&#39;) (<span class="kn">Add</span> x&#39; x)</span></span></span><br></div><label class="goal-separator" for="explanation-transitivity-of-equal-coq-v-chkb"><hr></label><div class="goal-conclusion">Equal (S (<span class="kn">Add</span> x&#39; x)) (<span class="kn">Add</span> x&#39; (S x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="explanation-transitivity-of-equal-coq-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="explanation-transitivity-of-equal-coq-v-chkc">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span>Equal (<span class="kn">Add</span> x x&#39;) (<span class="kn">Add</span> x&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equal (S (<span class="kn">Add</span> x x&#39;)) (S (<span class="kn">Add</span> x&#39; x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="explanation-transitivity-of-equal-coq-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="explanation-transitivity-of-equal-coq-v-chkd"><span class="nb">apply</span> Equal_Morph.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span>Equal (<span class="kn">Add</span> x x&#39;) (<span class="kn">Add</span> x&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equal (<span class="kn">Add</span> x x&#39;) (<span class="kn">Add</span> x&#39; x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="explanation-transitivity-of-equal-coq-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="explanation-transitivity-of-equal-coq-v-chke">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span>Equal (<span class="kn">Add</span> x x&#39;) (<span class="kn">Add</span> x&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Equal (S (<span class="kn">Add</span> x&#39; x)) (<span class="kn">Add</span> x&#39; (S x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Add_S.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>However, I don't understand the use of <tt class="docutils literal">Equal_Trans</tt> (line 6). If I
understand, <tt class="docutils literal">Equal_Trans</tt> takes 3 arguments: y x z? But why there is
only 1 argument using <tt class="docutils literal">Equal_Trans</tt> in <tt class="docutils literal">Add_com</tt> lemma?</p>
<p>Thank you in advance for your help.</p>
</div>
<div class="section" id="answer">
<h1>Answer</h1>
<p>The tactic <tt class="docutils literal">apply</tt> tries to fill in the blanks to match the type of
the provided term with the goal. In this case, the goal (when the
tactic is used) is probably something along the lines of <tt class="docutils literal">a = b</tt>
(based on your followup, it's actually <tt class="docutils literal">Equal a b</tt>). The type of
<tt class="docutils literal">Equal_Trans</tt> (when all the arguments are used) is <tt class="docutils literal">x = z</tt>
(<tt class="docutils literal">Equal x z</tt>), so to unify these two types, we should have <tt class="docutils literal">x :=
a</tt> and <tt class="docutils literal">z := b</tt>. That only leaves <tt class="docutils literal">y</tt> as ambiguous, so we have to
provide it.</p>
<p>To address your followup, no, <tt class="docutils literal">Equal_Trans</tt> does not take <em>just</em> one
argument. It takes a type (<tt class="docutils literal">Nat</tt> in your case) three elements of
that type (<tt class="docutils literal">y</tt>, <tt class="docutils literal">x</tt> and <tt class="docutils literal">z</tt>) and two equality proofs. However,
remember that functions in Coq are curried, which means that you can
call them with fewer arguments, but the result will be a function of
the remaining arguments.</p>
<p>So really, when we say <tt class="docutils literal">apply (Equal_Trans Nat (S (Add x' <span class="pre">x)).</span></tt>,
we're saying &quot;take this thing that has type <tt class="docutils literal">forall (x z: Nat), Equal
x (S (Add x' x)) <span class="pre">-&gt;</span> Equal (S (Add x' x)) z <span class="pre">-&gt;</span> Equal x z</tt> and try to
fill in some of the arguments to match it with my goal&quot;.</p>
<p>Coq looks at that type and realizes that the goal already looks like
<tt class="docutils literal">Equal x z</tt>, so it's able to deduce what <tt class="docutils literal">x</tt> and <tt class="docutils literal">z</tt> have to be.
<tt class="docutils literal">Equal_Trans</tt> still takes two more arguments that Coq can't figure
out on its own (the proofs of <tt class="docutils literal">Equal x y</tt> and <tt class="docutils literal">Equal y z</tt>), so
that's what the rest of the proof is doing.</p>
<hr class="docutils" />
<p>We use transitivity with <tt class="docutils literal">y := S (Add x' x)</tt> because we can prove
<tt class="docutils literal">Equal (S (Add x <span class="pre">x'))</span> (S (Add x' x))</tt> using the inductive hypothesis
(<tt class="docutils literal">IHx</tt>). We can also prove <tt class="docutils literal">Equal (S (Add x' x)) (Add x' (S x))</tt>
by using the definition of <tt class="docutils literal">Add</tt>. Hence, it's natural to route the
proof of equality through <tt class="docutils literal">S (Add x' x)</tt>.</p>
<p>Now, we don't have to use transitivity with <tt class="docutils literal">y := S (Add x' x)</tt>. We
could prove that <tt class="docutils literal">(S (Add x <span class="pre">x'))</span></tt> and <tt class="docutils literal">(Add x' (S x))</tt> are both
equal to some other element of <tt class="docutils literal">Nat</tt>. But the easiest and most
direct route is through <tt class="docutils literal">S (Add x' x)</tt>.</p>
</div>
</div>
</div>
</div></body>
</html>
