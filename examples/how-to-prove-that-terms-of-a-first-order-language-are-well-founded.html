<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>How to prove that terms of a first-order language are well-founded?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded">
<h1 class="title">How to prove that terms of a first-order language are well-founded?</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/52087304">https://stackoverflow.com/q/52087304</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>Currently, I've started working on proving theorems about first-order
logic in Coq (<a class="reference external" href="https://github.com/georgydunaev/VerifiedMathFoundations">VerifiedMathFoundations</a>). I've
proved deduction theorem, but then I got stuck with lemma 1 for
theorem of correctness. So I've formulated one elegant piece of the
lemma compactly and I invite the community to look at it. That is an
incomplete the proof of well-foundness of the terms. How to get rid of
the pair of <span class="docutils literal">admit</span>s properly?</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* PUBLIC DOMAIN *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Coq.Vectors.Vector.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Coq.Lists.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Bool.Bool.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Logic.FunctionalExtensionality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Program.Wf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">SetVars</span>  := nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">FuncSymb</span> := nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">PredSymb</span> := nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">FSV</span> :=
  {
  fs : FuncSymb;
  fsv : nat;
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">PSV</span> :=
  MPSV {
      ps : PredSymb;
      psv : nat;
    }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Terms</span> : <span class="kt">Type</span> :=
| FVC :&gt; SetVars -&gt; Terms
| FSC (f : FSV) : Vector.t Terms (fsv f) -&gt; Terms.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk0"><span class="kn">Definition</span> <span class="nf">rela</span> : <span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : Terms), <span class="kt">Prop</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Terms -&gt; Terms -&gt; <span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Terms -&gt; Terms -&gt; <span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk2"><span class="kr">fix</span> rela <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Terms -&gt; Terms -&gt; <span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk3"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk4"><span class="nb">destruct</span> y <span class="kr">as</span> [s|f t].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>SetVars</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br></div><label class="goal-separator" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk5"><hr></label><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>SetVars</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> <span class="kt">False</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk8"><span class="nb">refine</span> (or _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br></div><label class="goal-separator" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk9"><hr></label><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chka"><span class="bp">exact</span> (Vector.In x t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chkb"><span class="nb">simple refine</span> (@Vector.fold_left Terms <span class="kt">Prop</span> _ <span class="kt">False</span> (fsv f) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Prop</span> -&gt; Terms -&gt; <span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chkc"><span class="nb">intros</span> Q e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (or Q (rela x e)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">snglV</span> {<span class="nv">A</span>} (<span class="nv">a</span> : A) := Vector.cons A a <span class="mi">0</span> (Vector.nil A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chkd"><span class="kn">Definition</span> <span class="nf">wfr</span> : @well_founded Terms rela.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded rela</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded rela</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chkf"><span class="nb">clear</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded rela</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk10"><span class="nb">unfold</span> well_founded.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Terms, Acc rela a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk11"><span class="nb">assert</span> (H : <span class="kr">forall</span> (<span class="nv">n</span>:Terms) (<span class="nv">a</span>:Terms), (rela a n) -&gt; Acc rela a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br></div><label class="goal-separator" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk12"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Terms, Acc rela a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk13">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk14"><span class="kr">fix</span> iHn <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>iHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk15"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>iHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>SetVars</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Terms, rela a s -&gt; Acc rela a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk16" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>iHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br></div><label class="goal-separator" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk16"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Terms, rela a (FSC f t) -&gt; Acc rela a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk17">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>iHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>SetVars</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Terms, rela a s -&gt; Acc rela a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk18"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>iHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>SetVars</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Terms, <span class="kt">False</span> -&gt; Acc rela a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk19"><span class="nb">intros</span> a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>iHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>SetVars</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc rela a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> b.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk1a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>iHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Terms, rela a (FSC f t) -&gt; Acc rela a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk1b"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>iHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Terms,
Vector.In a t \/
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela a e) <span class="kt">False</span>
  t -&gt; Acc rela a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk1c"><span class="nb">intros</span> a Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>iHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>Vector.In a t \/
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela a e)
  <span class="kt">False</span> t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc rela a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk1d"><span class="nb">destruct</span> Q <span class="kr">as</span> [L|R].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>iHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>Vector.In a t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc rela a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk1e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>iHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela a e)
  <span class="kt">False</span> t</span></span></span><br></div><label class="goal-separator" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk1e"><hr></label><div class="goal-conclusion">Acc rela a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk1f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>iHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>Vector.In a t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc rela a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">admit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="c">(* smth like apply Acc_intro. intros m Hm. apply (iHn a). exact Hm. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk20">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>iHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela a e)
  <span class="kt">False</span> t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc rela a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">admit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="c">(* like in /Arith/Wf_nat.v *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk21">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Terms, Acc rela a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk22"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc rela a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk23"><span class="nb">simple refine</span> (H _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Terms</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br></div><label class="goal-separator" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk24"><hr></label><div class="goal-conclusion">rela a <span class="nl">?n</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk25"><span class="bp">exact</span> (FSC (Build_FSV <span class="mi">0</span> <span class="mi">1</span>) (snglV a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rela a (FSC {| fs := <span class="mi">0</span>; fsv := <span class="mi">1</span> |} (snglV a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk26"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.In a (snglV a) \/ <span class="kt">False</span> \/ rela a a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk27"><span class="nb">apply</span> or_introl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> : Terms, rela a n -&gt; Acc rela a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.In a (snglV a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk28"><span class="kn">Defined</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(<span class="kr">in</span> proof wfr): Attempt to save a proof <span class="kr">with</span> given up
goals. If this <span class="kr">is</span> really what you want to <span class="kp">do</span>, use
<span class="kn">Admitted</span> <span class="kr">in</span> place of <span class="kn">Qed</span>.</blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>It is also available here: <a class="reference external" href="https://pastebin.com/UqpxM5Xb">pastebin</a>.</p>
<p><em>Update:</em> At least transitivity is needed for well-foundness. I also
started a proof, but didn't finished.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk29"><span class="kn">Fixpoint</span> <span class="nf">Tra</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Terms) (<span class="nv">Hc</span> : rela c b) (<span class="nv">Hb</span> : rela b a) {<span class="nv">struct</span> <span class="nv">a</span>} :
  rela c a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Tra</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Terms, rela c b -&gt; rela b a -&gt; rela c a</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>Hc</var><span class="hyp-type"><b>: </b><span>rela c b</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>rela b a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rela c a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk2a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Tra</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Terms, rela c b -&gt; rela b a -&gt; rela c a</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>Hc</var><span class="hyp-type"><b>: </b><span>rela c b</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>rela b a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rela c a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk2b"><span class="nb">destruct</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Tra</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Terms, rela c b -&gt; rela b a -&gt; rela c a</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>SetVars</span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>Hc</var><span class="hyp-type"><b>: </b><span>rela c b</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>rela b s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rela c s</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk2c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Tra</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Terms, rela c b -&gt; rela b a -&gt; rela c a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>Hc</var><span class="hyp-type"><b>: </b><span>rela c b</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>rela b (FSC f t)</span></span></span><br></div><label class="goal-separator" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk2c"><hr></label><div class="goal-conclusion">rela c (FSC f t)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk2d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Tra</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Terms, rela c b -&gt; rela b a -&gt; rela c a</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>SetVars</span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>Hc</var><span class="hyp-type"><b>: </b><span>rela c b</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>rela b s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rela c s</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk2e"><span class="nb">simpl</span> <span class="kr">in</span> * |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Tra</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Terms, rela c b -&gt; rela b a -&gt; rela c a</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>SetVars</span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>Hc</var><span class="hyp-type"><b>: </b><span>rela c b</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Hb.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk2f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Tra</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Terms, rela c b -&gt; rela b a -&gt; rela c a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>Hc</var><span class="hyp-type"><b>: </b><span>rela c b</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>rela b (FSC f t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rela c (FSC f t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk30"><span class="nb">simpl</span> <span class="kr">in</span> * |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Tra</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Terms, rela c b -&gt; rela b a -&gt; rela c a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>Hc</var><span class="hyp-type"><b>: </b><span>rela c b</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>Vector.In b t \/
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela b e)
  <span class="kt">False</span> t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.In c t \/
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela c e) <span class="kt">False</span>
  t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk31"><span class="nb">destruct</span> Hb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Tra</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Terms, rela c b -&gt; rela b a -&gt; rela c a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>Hc</var><span class="hyp-type"><b>: </b><span>rela c b</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Vector.In b t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.In c t \/
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela c e) <span class="kt">False</span>
  t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk32" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Tra</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Terms, rela c b -&gt; rela b a -&gt; rela c a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>Hc</var><span class="hyp-type"><b>: </b><span>rela c b</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela b e)
  <span class="kt">False</span> t</span></span></span><br></div><label class="goal-separator" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk32"><hr></label><div class="goal-conclusion">Vector.In c t \/
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela c e) <span class="kt">False</span>
  t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk33">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Tra</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Terms, rela c b -&gt; rela b a -&gt; rela c a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>Hc</var><span class="hyp-type"><b>: </b><span>rela c b</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Vector.In b t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.In c t \/
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela c e) <span class="kt">False</span>
  t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk34"><span class="nb">apply</span> or_intror.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Tra</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Terms, rela c b -&gt; rela b a -&gt; rela c a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>Hc</var><span class="hyp-type"><b>: </b><span>rela c b</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Vector.In b t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela c e) <span class="kt">False</span>
  t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk35"><span class="nb">revert</span> f t H .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Tra</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Terms, rela c b -&gt; rela b a -&gt; rela c a</span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>Hc</var><span class="hyp-type"><b>: </b><span>rela c b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : FSV) (<span class="nv">t</span> : t Terms (fsv f)),
Vector.In b t -&gt;
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela c e) <span class="kt">False</span>
  t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk36"><span class="kr">fix</span> RECU <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Tra</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Terms, rela c b -&gt; rela b a -&gt; rela c a</span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>Hc</var><span class="hyp-type"><b>: </b><span>rela c b</span></span></span><br><span><var>RECU</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : FSV) (<span class="nv">t</span> : t Terms (fsv f)),
Vector.In b t -&gt;
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela c e)
  <span class="kt">False</span> t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : FSV) (<span class="nv">t</span> : t Terms (fsv f)),
Vector.In b t -&gt;
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela c e) <span class="kt">False</span>
  t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk37"><span class="nb">intros</span> f t H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Tra</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Terms,
rela c b -&gt; rela b a -&gt; rela c a</span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>Hc</var><span class="hyp-type"><b>: </b><span>rela c b</span></span></span><br><span><var>RECU</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : FSV) (<span class="nv">t</span> : Vector.t Terms (fsv f)),
Vector.In b t -&gt;
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela c e)
  <span class="kt">False</span> t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Vector.In b t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela c e) <span class="kt">False</span>
  t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* ... *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span></span></pre></section>
<section id="answer">
<h2>Answer</h2>
<p>You can do it by defining a height function on <span class="docutils literal">Terms</span>, and showing
that decreasing <span class="docutils literal">rela</span> implies decreasing heights:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Coq.Vectors.Vector.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Coq.Lists.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Bool.Bool.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Logic.FunctionalExtensionality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Program.Wf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">SetVars</span>  := nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">FuncSymb</span> := nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">PredSymb</span> := nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">FSV</span> :=
  {
  fs : FuncSymb;
  fsv : nat;
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">PSV</span> :=
  MPSV {
      ps : PredSymb;
      psv : nat;
    }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unset Elimination Schemes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Terms</span> : <span class="kt">Type</span> :=
| FVC :&gt; SetVars -&gt; Terms
| FSC (f : FSV) : Vector.t Terms (fsv f) -&gt; Terms.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Elimination Schemes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Terms_rect</span> (<span class="nv">T</span> : Terms -&gt; <span class="kt">Type</span>)
           (<span class="nv">H_FVC</span> : <span class="kr">forall</span> <span class="nv">sv</span>, T (FVC sv))
           (<span class="nv">H_FSC</span> : <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">v</span>,
               (<span class="kr">forall</span> <span class="nv">n</span>, T (Vector.nth v n)) -&gt; T (FSC f v)) :=
  <span class="kr">fix</span> loopt (t : Terms) : T t :=
    <span class="kr">match</span> t <span class="kr">with</span>
    | FVC sv  =&gt; H_FVC sv
    | FSC f v =&gt;
      <span class="kr">let fix</span> <span class="nv">loopv</span> <span class="nv">s</span> (<span class="nv">v</span> : Vector.t Terms s) : <span class="kr">forall</span> <span class="nv">n</span>, T (Vector.nth v n) :=
          <span class="kr">match</span> v <span class="kr">with</span>
          | @Vector.nil _ =&gt; Fin.case0 _
          | @Vector.cons _ t _ v =&gt;
            <span class="kr">fun</span> <span class="nv">n</span> =&gt;
              Fin.caseS&#39; n (<span class="kr">fun</span> <span class="nv">n</span> =&gt; T (Vector.nth (Vector.cons _ t _ v) n))
                         (loopt t)
                         (loopv _ v)
          <span class="kr">end</span> <span class="kr">in</span>
      H_FSC f v (loopv _ v)
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Terms_ind</span> := Terms_rect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">height</span> (<span class="nv">t</span> : Terms) : nat :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | FVC _ =&gt; <span class="mi">0</span>
  | FSC f v =&gt; S (Vector.fold_right (<span class="kr">fun</span> <span class="nv">t</span> <span class="nv">acc</span> =&gt; Nat.max acc (height t)) v <span class="mi">0</span>)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk38"><span class="kn">Definition</span> <span class="nf">rela</span> : <span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : Terms), <span class="kt">Prop</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Terms -&gt; Terms -&gt; <span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk39"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Terms -&gt; Terms -&gt; <span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk3a"><span class="kr">fix</span> rela <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Terms -&gt; Terms -&gt; <span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk3b"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk3c"><span class="nb">destruct</span> y <span class="kr">as</span> [s|f t].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>SetVars</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk3d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br></div><label class="goal-separator" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk3d"><hr></label><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk3e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>SetVars</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> <span class="kt">False</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk3f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk40"><span class="nb">refine</span> (or _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk41" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br></div><label class="goal-separator" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk41"><hr></label><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk42"><span class="bp">exact</span> (Vector.In x t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk43"><span class="nb">simple refine</span> (@Vector.fold_left Terms <span class="kt">Prop</span> _ <span class="kt">False</span> (fsv f) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Prop</span> -&gt; Terms -&gt; <span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk44"><span class="nb">intros</span> Q e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rela</var><span class="hyp-type"><b>: </b><span>Terms -&gt; Terms -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Vector.t Terms (fsv f)</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (or Q (rela x e)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Lia.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk45"><span class="kn">Definition</span> <span class="nf">wfr</span> : @well_founded Terms rela.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded rela</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk46"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded rela</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk47"><span class="nb">apply</span> (Wf_nat.well_founded_lt_compat _ height).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Terms, rela x y -&gt; height x &lt; height y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk48"><span class="nb">intros</span> t1 t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rela t1 t2 -&gt; height t1 &lt; height t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk49"><span class="nb">induction</span> t2 <span class="kr">as</span> [sv2|f2 v2 IH]; <span class="nb">simpl</span>; <span class="kp">try</span> <span class="bp">easy</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms (fsv f2)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Fin.t (fsv f2),
rela t1 (Vector.nth v2 n) -&gt;
height t1 &lt; height (Vector.nth v2 n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.In t1 v2 \/
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela t1 e) <span class="kt">False</span>
  v2 -&gt;
height t1 &lt;
S
  (Vector.fold_right
     (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
      Nat.max acc (height t)) v2 <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk4a"><span class="nb">intros</span> [t_v|t_sub]; <span class="nb">apply</span> Lt.le_lt_n_Sm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms (fsv f2)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Fin.t (fsv f2),
rela t1 (Vector.nth v2 n) -&gt;
height t1 &lt; height (Vector.nth v2 n)</span></span></span><br><span><var>t_v</var><span class="hyp-type"><b>: </b><span>Vector.In t1 v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t1 &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk4b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms (fsv f2)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Fin.t (fsv f2),
rela t1 (Vector.nth v2 n) -&gt;
height t1 &lt; height (Vector.nth v2 n)</span></span></span><br><span><var>t_sub</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt;
   Q \/ rela t1 e) <span class="kt">False</span> v2</span></span></span><br></div><label class="goal-separator" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk4b"><hr></label><div class="goal-conclusion">height t1 &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk4c">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms (fsv f2)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Fin.t (fsv f2),
rela t1 (Vector.nth v2 n) -&gt;
height t1 &lt; height (Vector.nth v2 n)</span></span></span><br><span><var>t_v</var><span class="hyp-type"><b>: </b><span>Vector.In t1 v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t1 &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk4d"><span class="nb">clear</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms (fsv f2)</span></span></span><br><span><var>t_v</var><span class="hyp-type"><b>: </b><span>Vector.In t1 v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t1 &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> t_v; <span class="nb">simpl</span>; <span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk4e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms (fsv f2)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Fin.t (fsv f2),
rela t1 (Vector.nth v2 n) -&gt;
height t1 &lt; height (Vector.nth v2 n)</span></span></span><br><span><var>t_sub</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt;
   Q \/ rela t1 e) <span class="kt">False</span> v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t1 &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk4f"><span class="nb">revert</span> v2 IH t_sub.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">v2</span> : t Terms (fsv f2),
(<span class="kr">forall</span> <span class="nv">n</span> : Fin.t (fsv f2),
 rela t1 (Vector.nth v2 n) -&gt;
 height t1 &lt; height (Vector.nth v2 n)) -&gt;
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela t1 e) <span class="kt">False</span>
  v2 -&gt;
height t1 &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk50"><span class="nb">generalize</span> (fsv f2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>FSV</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">v2</span> : t Terms n),
(<span class="kr">forall</span> <span class="nv">n0</span> : Fin.t n,
 rela t1 (Vector.nth v2 n0) -&gt;
 height t1 &lt; height (Vector.nth v2 n0)) -&gt;
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela t1 e) <span class="kt">False</span>
  v2 -&gt;
height t1 &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk51"><span class="nb">clear</span> f2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">v2</span> : t Terms n),
(<span class="kr">forall</span> <span class="nv">n0</span> : Fin.t n,
 rela t1 (Vector.nth v2 n0) -&gt;
 height t1 &lt; height (Vector.nth v2 n0)) -&gt;
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela t1 e) <span class="kt">False</span>
  v2 -&gt;
height t1 &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk52"><span class="nb">intros</span> k v2 IH t_sub.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Fin.t k,
rela t1 (Vector.nth v2 n) -&gt;
height t1 &lt; height (Vector.nth v2 n)</span></span></span><br><span><var>t_sub</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt;
   Q \/ rela t1 e) <span class="kt">False</span> v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t1 &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk53"><span class="nb">enough</span> (H : <span class="kr">exists</span> <span class="nv">n</span>, rela t1 (Vector.nth v2 n)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Fin.t k,
rela t1 (Vector.nth v2 n) -&gt;
height t1 &lt; height (Vector.nth v2 n)</span></span></span><br><span><var>t_sub</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt;
   Q \/ rela t1 e) <span class="kt">False</span> v2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">n</span> : Fin.t k, rela t1 (Vector.nth v2 n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t1 &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk54" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Fin.t k,
rela t1 (Vector.nth v2 n) -&gt;
height t1 &lt; height (Vector.nth v2 n)</span></span></span><br><span><var>t_sub</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt;
   Q \/ rela t1 e) <span class="kt">False</span> v2</span></span></span><br></div><label class="goal-separator" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk54"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : Fin.t k, rela t1 (Vector.nth v2 n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk55">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Fin.t k,
rela t1 (Vector.nth v2 n) -&gt;
height t1 &lt; height (Vector.nth v2 n)</span></span></span><br><span><var>t_sub</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt;
   Q \/ rela t1 e) <span class="kt">False</span> v2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">n</span> : Fin.t k, rela t1 (Vector.nth v2 n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t1 &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk56"><span class="nb">destruct</span> H <span class="kr">as</span> [n H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Fin.t k,
rela t1 (Vector.nth v2 n) -&gt;
height t1 &lt; height (Vector.nth v2 n)</span></span></span><br><span><var>t_sub</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt;
   Q \/ rela t1 e) <span class="kt">False</span> v2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Fin.t k</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rela t1 (Vector.nth v2 n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t1 &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk57"><span class="nb">apply</span> IH <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Fin.t k,
rela t1 (Vector.nth v2 n) -&gt;
height t1 &lt; height (Vector.nth v2 n)</span></span></span><br><span><var>t_sub</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt;
   Q \/ rela t1 e) <span class="kt">False</span> v2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Fin.t k</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>height t1 &lt; height (Vector.nth v2 n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t1 &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk58"><span class="nb">clear</span> IH t_sub.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Fin.t k</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>height t1 &lt; height (Vector.nth v2 n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t1 &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk59"><span class="nb">transitivity</span> (height (Vector.nth v2 n)); <span class="kp">try</span> <span class="bp">lia</span>; <span class="nb">clear</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Fin.t k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height (Vector.nth v2 n) &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk5a"><span class="nb">induction</span> v2 <span class="kr">as</span> [|t2 m v2 IHv2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Fin.t <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height (Vector.nth (Vector.nil Terms) n) &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) 
  (Vector.nil Terms) <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk5b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms m</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Fin.t (S m)</span></span></span><br><span><var>IHv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Fin.t m,
height (Vector.nth v2 n) &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk5b"><hr></label><div class="goal-conclusion">height (Vector.nth (Vector.cons Terms t2 m v2) n) &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) 
  (Vector.cons Terms t2 m v2) <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk5c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Fin.t <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height (Vector.nth (Vector.nil Terms) n) &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) 
  (Vector.nil Terms) <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk5d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms m</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Fin.t (S m)</span></span></span><br><span><var>IHv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Fin.t m,
height (Vector.nth v2 n) &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height (Vector.nth (Vector.cons Terms t2 m v2) n) &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) 
  (Vector.cons Terms t2 m v2) <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk5e"><span class="nb">apply</span> (Fin.caseS&#39; n); <span class="nb">clear</span> n; <span class="nb">simpl</span>; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms m</span></span></span><br><span><var>IHv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Fin.t m,
height (Vector.nth v2 n) &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : Fin.t m,
height (Vector.nth v2 p) &lt;=
Nat.max
  (Vector.fold_right
     (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
      Nat.max acc (height t)) v2 <span class="mi">0</span>) 
  (height t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk5f"><span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms m</span></span></span><br><span><var>IHv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Fin.t m,
height (Vector.nth v2 n) &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Fin.t m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height (Vector.nth v2 n) &lt;=
Nat.max
  (Vector.fold_right
     (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
      Nat.max acc (height t)) v2 <span class="mi">0</span>) 
  (height t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk60"><span class="nb">specialize</span> (IHv2 n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms m</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Fin.t m</span></span></span><br><span><var>IHv2</var><span class="hyp-type"><b>: </b><span>height (Vector.nth v2 n) &lt;=
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
   Nat.max acc (height t)) v2 <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height (Vector.nth v2 n) &lt;=
Nat.max
  (Vector.fold_right
     (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">acc</span> : nat) =&gt;
      Nat.max acc (height t)) v2 <span class="mi">0</span>) 
  (height t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk61">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : Fin.t k,
rela t1 (Vector.nth v2 n) -&gt;
height t1 &lt; height (Vector.nth v2 n)</span></span></span><br><span><var>t_sub</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt;
   Q \/ rela t1 e) <span class="kt">False</span> v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : Fin.t k, rela t1 (Vector.nth v2 n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk62"><span class="nb">clear</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>t_sub</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt;
   Q \/ rela t1 e) <span class="kt">False</span> v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : Fin.t k, rela t1 (Vector.nth v2 n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk63"><span class="nb">assert</span> (H : Vector.fold_right (<span class="kr">fun</span> <span class="nv">t</span> <span class="nv">Q</span> =&gt; Q \/ rela t1 t) v2 <span class="kt">False</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>t_sub</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt;
   Q \/ rela t1 e) <span class="kt">False</span> v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t) v2
  <span class="kt">False</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk64" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>t_sub</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt;
   Q \/ rela t1 e) <span class="kt">False</span> v2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t)
  v2 <span class="kt">False</span></span></span></span><br></div><label class="goal-separator" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk64"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : Fin.t k, rela t1 (Vector.nth v2 n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk65">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>t_sub</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt;
   Q \/ rela t1 e) <span class="kt">False</span> v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t) v2
  <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk66"><span class="nb">revert</span> t_sub.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela t1 e) <span class="kt">False</span>
  v2 -&gt;
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t) v2
  <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk67"><span class="nb">generalize</span> <span class="kt">False</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>,
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela t1 e) P v2 -&gt;
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t) v2 P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk68"><span class="nb">induction</span> v2 <span class="kr">as</span> [|t2 n v2]; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">trivial</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms n</span></span></span><br><span><var>IHv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>,
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela t1 e)
  P v2 -&gt;
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t)
  v2 P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>,
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela t1 e)
  (P \/ rela t1 t2) v2 -&gt;
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t) v2 P \/
rela t1 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk69"><span class="nb">intros</span> P H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms n</span></span></span><br><span><var>IHv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>,
Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela t1 e)
  P v2 -&gt;
Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t)
  v2 P</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela t1 e)
  (P \/ rela t1 t2) v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t) v2 P \/
rela t1 t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk6a"><span class="nb">specialize</span> (IHv2 _ H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms n</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>IHv2</var><span class="hyp-type"><b>: </b><span>Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t)
  v2 (P \/ rela t1 t2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt; Q \/ rela t1 e)
  (P \/ rela t1 t2) v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t) v2 P \/
rela t1 t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk6b"><span class="nb">clear</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms n</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>IHv2</var><span class="hyp-type"><b>: </b><span>Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t)
  v2 (P \/ rela t1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t) v2 P \/
rela t1 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> v2 <span class="kr">as</span> [|t2&#39; n v2 IHv2&#39;]; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="bp">tauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk6c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>t_sub</var><span class="hyp-type"><b>: </b><span>Vector.fold_left
  (<span class="kr">fun</span> (<span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">e</span> : Terms) =&gt;
   Q \/ rela t1 e) <span class="kt">False</span> v2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t)
  v2 <span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : Fin.t k, rela t1 (Vector.nth v2 n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk6d"><span class="nb">clear</span> t_sub.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t)
  v2 <span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : Fin.t k, rela t1 (Vector.nth v2 n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk6e"><span class="nb">induction</span> v2 <span class="kr">as</span> [|t2 k v2 IH]; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="kp">try</span> <span class="bp">easy</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t)
  v2 <span class="kt">False</span> \/ rela t1 t2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t)
  v2 <span class="kt">False</span> -&gt;
<span class="kr">exists</span> <span class="nv">n</span> : Fin.t k, rela t1 (Vector.nth v2 n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : Fin.t (S k),
  rela t1
    (<span class="kr">match</span>
       n <span class="kr">in</span> (Fin.t m&#39;) <span class="kr">return</span> (t Terms m&#39; -&gt; Terms)
     <span class="kr">with</span>
     | @Fin.F1 n0 =&gt;
         caseS
           (<span class="kr">fun</span> (<span class="nv">n1</span> : nat) (<span class="nv">_</span> : t Terms (S n1)) =&gt;
            Terms)
           (<span class="kr">fun</span> (<span class="nv">h</span> : Terms) 
              (<span class="nv">n1</span> : nat) 
              (<span class="nv">_</span> : t Terms n1) =&gt; h)
     | @Fin.FS n0 p&#39; =&gt;
         <span class="kr">fun</span> <span class="nv">v</span> : t Terms (S n0) =&gt;
         caseS
           (<span class="kr">fun</span> (<span class="nv">n1</span> : nat) (<span class="nv">_</span> : t Terms (S n1)) =&gt;
            Fin.t n1 -&gt; Terms)
           (<span class="kr">fun</span> (<span class="nv">_</span> : Terms) 
              (<span class="nv">n1</span> : nat) 
              (<span class="nv">t</span> : t Terms n1) 
              (<span class="nv">p0</span> : Fin.t n1) =&gt; 
            Vector.nth t p0) v p&#39;
     <span class="kr">end</span> (Vector.cons Terms t2 k v2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk6f"><span class="nb">destruct</span> H <span class="kr">as</span> [H|H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t)
  v2 <span class="kt">False</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t)
  v2 <span class="kt">False</span> -&gt;
<span class="kr">exists</span> <span class="nv">n</span> : Fin.t k, rela t1 (Vector.nth v2 n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : Fin.t (S k),
  rela t1
    (<span class="kr">match</span>
       n <span class="kr">in</span> (Fin.t m&#39;) <span class="kr">return</span> (t Terms m&#39; -&gt; Terms)
     <span class="kr">with</span>
     | @Fin.F1 n0 =&gt;
         caseS
           (<span class="kr">fun</span> (<span class="nv">n1</span> : nat) (<span class="nv">_</span> : t Terms (S n1)) =&gt;
            Terms)
           (<span class="kr">fun</span> (<span class="nv">h</span> : Terms) 
              (<span class="nv">n1</span> : nat) 
              (<span class="nv">_</span> : t Terms n1) =&gt; h)
     | @Fin.FS n0 p&#39; =&gt;
         <span class="kr">fun</span> <span class="nv">v</span> : t Terms (S n0) =&gt;
         caseS
           (<span class="kr">fun</span> (<span class="nv">n1</span> : nat) (<span class="nv">_</span> : t Terms (S n1)) =&gt;
            Fin.t n1 -&gt; Terms)
           (<span class="kr">fun</span> (<span class="nv">_</span> : Terms) 
              (<span class="nv">n1</span> : nat) 
              (<span class="nv">t</span> : t Terms n1) 
              (<span class="nv">p0</span> : Fin.t n1) =&gt; 
            Vector.nth t p0) v p&#39;
     <span class="kr">end</span> (Vector.cons Terms t2 k v2))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk70" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rela t1 t2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t)
  v2 <span class="kt">False</span> -&gt;
<span class="kr">exists</span> <span class="nv">n</span> : Fin.t k, rela t1 (Vector.nth v2 n)</span></span></span><br></div><label class="goal-separator" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk70"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : Fin.t (S k),
  rela t1
    (<span class="kr">match</span>
       n <span class="kr">in</span> (Fin.t m&#39;) <span class="kr">return</span> (t Terms m&#39; -&gt; Terms)
     <span class="kr">with</span>
     | @Fin.F1 n0 =&gt;
         caseS
           (<span class="kr">fun</span> (<span class="nv">n1</span> : nat) (<span class="nv">_</span> : t Terms (S n1)) =&gt;
            Terms)
           (<span class="kr">fun</span> (<span class="nv">h</span> : Terms) 
              (<span class="nv">n1</span> : nat) 
              (<span class="nv">_</span> : t Terms n1) =&gt; h)
     | @Fin.FS n0 p&#39; =&gt;
         <span class="kr">fun</span> <span class="nv">v</span> : t Terms (S n0) =&gt;
         caseS
           (<span class="kr">fun</span> (<span class="nv">n1</span> : nat) (<span class="nv">_</span> : t Terms (S n1)) =&gt;
            Fin.t n1 -&gt; Terms)
           (<span class="kr">fun</span> (<span class="nv">_</span> : Terms) 
              (<span class="nv">n1</span> : nat) 
              (<span class="nv">t</span> : t Terms n1) 
              (<span class="nv">p0</span> : Fin.t n1) =&gt; 
            Vector.nth t p0) v p&#39;
     <span class="kr">end</span> (Vector.cons Terms t2 k v2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk71">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t)
  v2 <span class="kt">False</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t)
  v2 <span class="kt">False</span> -&gt;
<span class="kr">exists</span> <span class="nv">n</span> : Fin.t k, rela t1 (Vector.nth v2 n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : Fin.t (S k),
  rela t1
    (<span class="kr">match</span>
       n <span class="kr">in</span> (Fin.t m&#39;) <span class="kr">return</span> (t Terms m&#39; -&gt; Terms)
     <span class="kr">with</span>
     | @Fin.F1 n0 =&gt;
         caseS
           (<span class="kr">fun</span> (<span class="nv">n1</span> : nat) (<span class="nv">_</span> : t Terms (S n1)) =&gt;
            Terms)
           (<span class="kr">fun</span> (<span class="nv">h</span> : Terms) 
              (<span class="nv">n1</span> : nat) 
              (<span class="nv">_</span> : t Terms n1) =&gt; h)
     | @Fin.FS n0 p&#39; =&gt;
         <span class="kr">fun</span> <span class="nv">v</span> : t Terms (S n0) =&gt;
         caseS
           (<span class="kr">fun</span> (<span class="nv">n1</span> : nat) (<span class="nv">_</span> : t Terms (S n1)) =&gt;
            Fin.t n1 -&gt; Terms)
           (<span class="kr">fun</span> (<span class="nv">_</span> : Terms) 
              (<span class="nv">n1</span> : nat) 
              (<span class="nv">t</span> : t Terms n1) 
              (<span class="nv">p0</span> : Fin.t n1) =&gt; 
            Vector.nth t p0) v p&#39;
     <span class="kr">end</span> (Vector.cons Terms t2 k v2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk72"><span class="nb">apply</span> IH <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">n</span> : Fin.t k, rela t1 (Vector.nth v2 n)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t)
  v2 <span class="kt">False</span> -&gt;
<span class="kr">exists</span> <span class="nv">n</span> : Fin.t k, rela t1 (Vector.nth v2 n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : Fin.t (S k),
  rela t1
    (<span class="kr">match</span>
       n <span class="kr">in</span> (Fin.t m&#39;) <span class="kr">return</span> (t Terms m&#39; -&gt; Terms)
     <span class="kr">with</span>
     | @Fin.F1 n0 =&gt;
         caseS
           (<span class="kr">fun</span> (<span class="nv">n1</span> : nat) (<span class="nv">_</span> : t Terms (S n1)) =&gt;
            Terms)
           (<span class="kr">fun</span> (<span class="nv">h</span> : Terms) 
              (<span class="nv">n1</span> : nat) 
              (<span class="nv">_</span> : t Terms n1) =&gt; h)
     | @Fin.FS n0 p&#39; =&gt;
         <span class="kr">fun</span> <span class="nv">v</span> : t Terms (S n0) =&gt;
         caseS
           (<span class="kr">fun</span> (<span class="nv">n1</span> : nat) (<span class="nv">_</span> : t Terms (S n1)) =&gt;
            Fin.t n1 -&gt; Terms)
           (<span class="kr">fun</span> (<span class="nv">_</span> : Terms) 
              (<span class="nv">n1</span> : nat) 
              (<span class="nv">t</span> : t Terms n1) 
              (<span class="nv">p0</span> : Fin.t n1) =&gt; 
            Vector.nth t p0) v p&#39;
     <span class="kr">end</span> (Vector.cons Terms t2 k v2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk73"><span class="nb">destruct</span> H <span class="kr">as</span> [n Hn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Fin.t k</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>rela t1 (Vector.nth v2 n)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t)
  v2 <span class="kt">False</span> -&gt;
<span class="kr">exists</span> <span class="nv">n</span> : Fin.t k, rela t1 (Vector.nth v2 n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : Fin.t (S k),
  rela t1
    (<span class="kr">match</span>
       n <span class="kr">in</span> (Fin.t m&#39;) <span class="kr">return</span> (t Terms m&#39; -&gt; Terms)
     <span class="kr">with</span>
     | @Fin.F1 n0 =&gt;
         caseS
           (<span class="kr">fun</span> (<span class="nv">n1</span> : nat) (<span class="nv">_</span> : t Terms (S n1)) =&gt;
            Terms)
           (<span class="kr">fun</span> (<span class="nv">h</span> : Terms) 
              (<span class="nv">n1</span> : nat) 
              (<span class="nv">_</span> : t Terms n1) =&gt; h)
     | @Fin.FS n0 p&#39; =&gt;
         <span class="kr">fun</span> <span class="nv">v</span> : t Terms (S n0) =&gt;
         caseS
           (<span class="kr">fun</span> (<span class="nv">n1</span> : nat) (<span class="nv">_</span> : t Terms (S n1)) =&gt;
            Fin.t n1 -&gt; Terms)
           (<span class="kr">fun</span> (<span class="nv">_</span> : Terms) 
              (<span class="nv">n1</span> : nat) 
              (<span class="nv">t</span> : t Terms n1) 
              (<span class="nv">p0</span> : Fin.t n1) =&gt; 
            Vector.nth t p0) v p&#39;
     <span class="kr">end</span> (Vector.cons Terms t2 k v2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> (<span class="kr">exists</span> (<span class="nv">Fin</span>.FS n)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-prove-that-terms-of-a-first-order-language-are-well-founded-v-chk74">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>Terms</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>t Terms k</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rela t1 t2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Vector.fold_right
  (<span class="kr">fun</span> (<span class="nv">t</span> : Terms) (<span class="nv">Q</span> : <span class="kt">Prop</span>) =&gt; Q \/ rela t1 t)
  v2 <span class="kt">False</span> -&gt;
<span class="kr">exists</span> <span class="nv">n</span> : Fin.t k, rela t1 (Vector.nth v2 n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : Fin.t (S k),
  rela t1
    (<span class="kr">match</span>
       n <span class="kr">in</span> (Fin.t m&#39;) <span class="kr">return</span> (t Terms m&#39; -&gt; Terms)
     <span class="kr">with</span>
     | @Fin.F1 n0 =&gt;
         caseS
           (<span class="kr">fun</span> (<span class="nv">n1</span> : nat) (<span class="nv">_</span> : t Terms (S n1)) =&gt;
            Terms)
           (<span class="kr">fun</span> (<span class="nv">h</span> : Terms) 
              (<span class="nv">n1</span> : nat) 
              (<span class="nv">_</span> : t Terms n1) =&gt; h)
     | @Fin.FS n0 p&#39; =&gt;
         <span class="kr">fun</span> <span class="nv">v</span> : t Terms (S n0) =&gt;
         caseS
           (<span class="kr">fun</span> (<span class="nv">n1</span> : nat) (<span class="nv">_</span> : t Terms (S n1)) =&gt;
            Fin.t n1 -&gt; Terms)
           (<span class="kr">fun</span> (<span class="nv">_</span> : Terms) 
              (<span class="nv">n1</span> : nat) 
              (<span class="nv">t</span> : t Terms n1) 
              (<span class="nv">p0</span> : Fin.t n1) =&gt; 
            Vector.nth t p0) v p&#39;
     <span class="kr">end</span> (Vector.cons Terms t2 k v2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="kr">exists</span> <span class="nv">Fin</span>.F1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>(Note the use of the custom induction principle, which is needed
because of the nested inductives.)</p>
<p>This style of development, however, is too complicated. Avoiding
certain pitfalls would greatly simplify it:</p>
<ol class="arabic">
<li><p>The Coq standard vector library is too hard to use. The issue here
is exacerbated because of the nested inductives. It would probably
be better to use plain lists and have a separate well-formedness
predicate on terms.</p></li>
<li><p>Defining a relation such as <span class="docutils literal">rela</span> in proof mode makes it harder
to read. Consider, for instance, the following simpler alternative:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">rela</span> <span class="nv">x</span> <span class="nv">y</span> :=
  <span class="kr">match</span> y <span class="kr">with</span>
  | FVC _ =&gt; <span class="kt">False</span>
  | FSC f v =&gt;
    Vector.In x v \/
    Vector.fold_right (<span class="kr">fun</span> <span class="nv">z</span> <span class="nv">P</span> =&gt; rela x z \/ P) v <span class="kt">False</span>
  <span class="kr">end</span>.</span></span></pre></li>
<li><p>Folding left has a poor reduction behavior, because it forces us to
generalize over the accumulator argument to get the induction to go
through. This is why in my proof I had to switch to a
<span class="docutils literal">fold_right</span>.</p></li>
</ol>
</section>
</div>
</main>
</div></body>
</html>
