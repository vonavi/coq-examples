<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>How to do cases with an inductive type in Coq</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="how-to-do-cases-with-an-inductive-type-in-coq">
<h1 class="title">How to do cases with an inductive type in Coq</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/6823301">https://stackoverflow.com/q/6823301</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>I wan to use the <tt class="docutils literal">destruct</tt> tactic to prove a statement by cases. I
have read a couple of examples online and I'm confused. Could someone
explain it better?</p>
<p>Here is a small example (there are other ways to solve it but try
using <tt class="docutils literal">destruct</tt>):</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">three</span> := zero | one | two.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk0"><span class="kn">Lemma</span> <span class="nf">has2b2</span> : <span class="kr">forall</span> <span class="nv">a</span> : three, a &lt;&gt; zero /\ a &lt;&gt; one -&gt; a = two.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : three, a &lt;&gt; zero /\ a &lt;&gt; one -&gt; a = two</div></blockquote></div></div></small></span></pre><p>Now some examples online suggest doing the following:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : three, a &lt;&gt; zero /\ a &lt;&gt; one -&gt; a = two</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>three</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; zero /\ a &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = two</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk3"><span class="nb">destruct</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero /\ zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = two</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>one &lt;&gt; zero /\ one &lt;&gt; one</span></span></span><br></div><label class="goal-separator" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk4"><hr></label><div class="goal-conclusion">one = two</div></blockquote><input class="alectryon-extra-goal-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>two &lt;&gt; zero /\ two &lt;&gt; one</span></span></span><br></div><label class="goal-separator" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk5"><hr></label><div class="goal-conclusion">two = two</div></blockquote></div></div></div></small></span></pre><p>In which case I get:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk6" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">3</span> subgoals

  H : zero &lt;&gt; zero /\ zero &lt;&gt; one
  ============================
  zero = two

subgoal <span class="mi">2</span> <span class="kr">is</span>:
 one = two
subgoal <span class="mi">3</span> <span class="kr">is</span>:
 two = two</blockquote></div></div></small></span></pre><p>So, I want to prove that the first two cases are impossible. But the
machine lists them as subgoals and wants me to PROVE them... which is
impossible.</p>
<p>Summary: How to exactly discard the impossible cases?</p>
<p>I have seen some examples using <tt class="docutils literal">inversion</tt> but I don't understand
the procedure.</p>
<p>Finally, what happens if my lemma depends on several inductive types
and I still want to cover ALL cases?</p>
</div>
<div class="section" id="answer-akoprowski">
<h1>Answer (akoprowski)</h1>
<p>How to discard impossible cases? Well, it's true that the first two
obligations are impossible to prove, but note they have contradicting
assumptions (<tt class="docutils literal">zero &lt;&gt; zero</tt> and <tt class="docutils literal">one &lt;&gt; one</tt>, respectively). So
you will be able to prove those goals with <tt class="docutils literal">tauto</tt> (there are also
more primitive tactics that will do the trick, if you are interested).</p>
<p><tt class="docutils literal">inversion</tt> is a more advanced version of destruct. Additional to
'destructing' the inductive, it will sometimes generate some
equalities (that you may need). It itself is a simple version of
<tt class="docutils literal">induction</tt>, which will additionally generate an induction
hypothesis for you.</p>
<p>If you have several inductive types in your goal, you can
<tt class="docutils literal">destruct</tt>/<tt class="docutils literal">invert</tt> them one by one.</p>
<p>More detailed walk-through:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">three</span> := zero | one | two.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk7"><span class="kn">Lemma</span> <span class="nf">test</span> : <span class="kr">forall</span> <span class="nv">a</span>, a &lt;&gt; zero /\ a &lt;&gt; one -&gt; a = two.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : three, a &lt;&gt; zero /\ a &lt;&gt; one -&gt; a = two</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : three, a &lt;&gt; zero /\ a &lt;&gt; one -&gt; a = two</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk9"><span class="nb">intros</span> a H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>three</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; zero /\ a &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = two</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chka"><span class="nb">destruct</span> H. <span class="c">(* to get two parts of conjunction *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>three</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; zero</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = two</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chkb"><span class="nb">destruct</span> a. <span class="c">(* case analysis on &#39;a&#39; *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = two</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>one &lt;&gt; zero</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>one &lt;&gt; one</span></span></span><br></div><label class="goal-separator" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chkc"><hr></label><div class="goal-conclusion">one = two</div></blockquote><input class="alectryon-extra-goal-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>two &lt;&gt; zero</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>two &lt;&gt; one</span></span></span><br></div><label class="goal-separator" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chkd"><hr></label><div class="goal-conclusion">two = two</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* low-level proof *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chke">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = two</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chkf"><span class="nb">compute</span> <span class="kr">in</span> H. <span class="c">(* to see through the &#39;&lt;&gt;&#39; notation *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>zero = zero -&gt; <span class="kt">False</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = two</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk10"><span class="nb">elimtype</span> <span class="kt">False</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>zero = zero -&gt; <span class="kt">False</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"> <span class="c">(* meaning: assumptions are contradictory, I can</span>
<span class="c">                       prove False from them *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk11"><span class="nb">apply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>zero = zero -&gt; <span class="kt">False</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = zero</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* can as well be handled with more high-level tactics *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk12">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>one &lt;&gt; zero</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>one &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">one = two</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* the &quot;proper&quot; case *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk13">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>two &lt;&gt; zero</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>two &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">two = two</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="answer-gilles-so-stop-being-evil">
<h1>Answer (Gilles 'SO- stop being evil')</h1>
<p>If you see an impossible goal, there are two possibilities: either you
made a mistake in your proof strategy (perhaps your lemma is wrong),
or the hypotheses are contradictory.</p>
<p>If you think the hypotheses are contradictory, you can set the goal to
<tt class="docutils literal">False</tt>, to get a little complexity out of the way. <tt class="docutils literal">elimtype
False</tt> achieves this. Often, you prove <tt class="docutils literal">False</tt> by proving a
proposition <tt class="docutils literal">P</tt> and its negation <tt class="docutils literal">~ P</tt>; the tactic <tt class="docutils literal">absurd P</tt>
deduces any goal from <tt class="docutils literal">P</tt> and <tt class="docutils literal">~ P</tt>. If there's a particular
hypothesis which is contradictory, <tt class="docutils literal">contradict H</tt> will set the goal
to <tt class="docutils literal">~ H</tt>, or if the hypothesis is a negation <tt class="docutils literal">~ A</tt> then the goal
will be <tt class="docutils literal">A</tt> (stronger than <tt class="docutils literal">~ ~ A</tt> but usually more convenient).
If one particular hypothesis is obviously contradictory,
<tt class="docutils literal">contradiction H</tt> or just <tt class="docutils literal">contradiction</tt> will prove any goal.</p>
<p>There are many tactics involving hypotheses of inductive types.
Figuring out which one to use is mostly a matter of experience. Here
are the main ones (but you will run into cases not covered here soon):</p>
<ol class="arabic simple">
<li><tt class="docutils literal">destruct</tt> simply breaks down the hypothesis into several parts.
It loses information about dependencies and recursion. A typical
example is <tt class="docutils literal">destruct H</tt> where <tt class="docutils literal">H</tt> is a conjunction <tt class="docutils literal">H : A /\
B</tt>, which splits <tt class="docutils literal">H</tt> into two independent hypotheses of types
<tt class="docutils literal">A</tt> and <tt class="docutils literal">B</tt>; or dually <tt class="docutils literal">destruct H</tt> where <tt class="docutils literal">H</tt> is a
disjunction <tt class="docutils literal">H : A \/ B</tt>, which splits the proof into two
different subproofs, one with the hypothesis <tt class="docutils literal">A</tt> and one with the
hypothesis <tt class="docutils literal">B</tt>.</li>
<li><tt class="docutils literal">case_eq</tt> is similar to <tt class="docutils literal">destruct</tt>, but retains the connections
that the hypothesis has with other hypotheses. For example,
<tt class="docutils literal">destruct n</tt> where <tt class="docutils literal">n : nat</tt> breaks the proof into two
subproofs, one for <tt class="docutils literal">n = 0</tt> and one for <tt class="docutils literal">n = S m</tt>. If <tt class="docutils literal">n</tt> is
used in other hypotheses (i.e. you have a <tt class="docutils literal">H : P n</tt>), you may
need to remember that the <tt class="docutils literal">n</tt> you've destructed is the same <tt class="docutils literal">n</tt>
used in these hypotheses: <tt class="docutils literal">case_eq n</tt> does this.</li>
<li><tt class="docutils literal">inversion</tt> performs a case analysis on the type of a hypothesis.
It is particularly useful when there are dependencies in the type
of the hypothesis that <tt class="docutils literal">destruct</tt> would forget. You would
typically use <tt class="docutils literal">case_eq</tt> on hypotheses in <tt class="docutils literal">Set</tt> (where equality
is relevant) and <tt class="docutils literal">inversion</tt> on hypotheses in <tt class="docutils literal">Prop</tt> (which
have very dependent types). The <tt class="docutils literal">inversion</tt> tactic leaves a lot
of equalities behind, and it's often followed by <tt class="docutils literal">subst</tt> to
simplify the hypotheses. The <tt class="docutils literal">inversion_clear</tt> tactic is a simple
alternative to <tt class="docutils literal">inversion; subst</tt> but loses a little information.</li>
<li><tt class="docutils literal">induction</tt> means that you are going to prove the goal by
induction (= recursion) on the given hypothesis. For example,
<tt class="docutils literal">induction n</tt> where <tt class="docutils literal">n : nat</tt> means that you'll perform integer
induction and prove the base case (<tt class="docutils literal">n</tt> replaced by <tt class="docutils literal">0</tt>) and the
inductive case (<tt class="docutils literal">n</tt> replaced by <tt class="docutils literal">m + 1</tt>).</li>
</ol>
<p>Your example is simple enough that you can prove it as &quot;obvious by
case analysis on <tt class="docutils literal">a</tt>&quot;.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk14"><span class="kn">Lemma</span> <span class="nf">has2b2</span> : <span class="kr">forall</span> <span class="nv">a</span> : three, a &lt;&gt; zero /\ a &lt;&gt; one -&gt; a = two.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : three, a &lt;&gt; zero /\ a &lt;&gt; one -&gt; a = two</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk15"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : three, a &lt;&gt; zero /\ a &lt;&gt; one -&gt; a = two</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> a; <span class="bp">tauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>But let's look at the cases generated by the <tt class="docutils literal">destruct</tt> tactic, i.e.
after just <tt class="docutils literal">intros; destruct a.</tt>. (The case where <tt class="docutils literal">a</tt> is <tt class="docutils literal">one</tt>
is symmetric; the last case, where <tt class="docutils literal">a</tt> is <tt class="docutils literal">two</tt>, is obvious by
reflexivity.)</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk16">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero /\ zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = two</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk17" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">1</span> subgoal

  H : zero &lt;&gt; zero /\ zero &lt;&gt; one
  ============================
  zero = two</blockquote></div></div></small></span></pre><p>The goal looks impossible. We can tell this to Coq, and here it can
spot the contradiction automatically (<tt class="docutils literal">zero = zero</tt> is obvious, and
the rest is a first-order tautology handled by the <tt class="docutils literal">tauto</tt> tactic).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk18"><span class="nb">elimtype</span> <span class="kt">False</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero /\ zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">tauto</span>.</span></span></pre><p>In fact <tt class="docutils literal">tauto</tt> works even if you don't start by telling Coq not to
worry about the goal and wrote <tt class="docutils literal">tauto</tt> without the <tt class="docutils literal">elimtype
False</tt> first (IIRC it didn't in older versions of Coq). You can see
what Coq is doing with the <tt class="docutils literal">tauto</tt> tactic by writing <tt class="docutils literal">info tauto</tt>.
Coq will tell you what proof script the <tt class="docutils literal">tauto</tt> tactic generated.
It's not very easy to follow, so let's look at a manual proof of this
case. First, let's split the hypothesis (which is a conjunction) into
two.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk19"><span class="nb">destruct</span> H <span class="kr">as</span> [H0 H1].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = two</div></blockquote></div></div></small></span></pre><p>We now have two hypotheses, one of which is <tt class="docutils literal">zero &lt;&gt; zero</tt>. This is
clearly false, because it's the negation of <tt class="docutils literal">zero = zero</tt> which is
clearly true.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1a"><span class="bp">contradiction</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = zero</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span></span></pre><p>We can look in even more detail at what the <tt class="docutils literal">contradiction</tt> tactic
does. (<tt class="docutils literal">info contradiction</tt> would reveal what happens under the
scene, but again it's not novice-friendly). We claim that the goal is
true because the hypotheses are contradictory so we can prove
anything. So let's set the intermediate goal to <tt class="docutils literal">False</tt>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1b"><span class="nb">assert</span> (F : <span class="kt">False</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><label class="goal-separator" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1c"><hr></label><div class="goal-conclusion">zero = two</div></blockquote></div></div></div></small></span></pre><p>Run <tt class="docutils literal">red in H0.</tt> to see that <tt class="docutils literal">zero &lt;&gt; zero</tt> is really notation for
<tt class="docutils literal">~(zero = zero)</tt> which in turn is defined as meaning <tt class="docutils literal">zero = zero
<span class="pre">-&gt;</span> False</tt>. So <tt class="docutils literal">False</tt> is the conclusion of <tt class="docutils literal">H0</tt>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1e"><span class="nb">red</span> <span class="kr">in</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero = zero -&gt; <span class="kt">False</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1f"><span class="nb">apply</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero = zero -&gt; <span class="kt">False</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = zero</div></blockquote></div></div></small></span></pre><p>And now we need to prove that <tt class="docutils literal">zero = zero</tt>, which is</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span></span></pre><p>Now we've proved our assertion of <tt class="docutils literal">False</tt>. What remains is to prove
that <tt class="docutils literal">False</tt> implies our goal. Well, <tt class="docutils literal">False</tt> implies any goal,
that's its definition (<tt class="docutils literal">False</tt> is defined as an inductive type with
0 case).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk20">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = two</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> F.</span></span></pre></div>
</div>
</div>
</div></body>
</html>
