<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>How to do cases with an inductive type in Coq</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="how-to-do-cases-with-an-inductive-type-in-coq">
<h1 class="title">How to do cases with an inductive type in Coq</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/6823301">https://stackoverflow.com/q/6823301</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>I wan to use the <span class="docutils literal">destruct</span> tactic to prove a statement by cases. I
have read a couple of examples online and I'm confused. Could someone
explain it better?</p>
<p>Here is a small example (there are other ways to solve it but try
using <span class="docutils literal">destruct</span>):</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">three</span> := zero | one | two.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk0"><span class="kn">Lemma</span> <span class="nf">has2b2</span> : <span class="kr">forall</span> <span class="nv">a</span> : three, a &lt;&gt; zero /\ a &lt;&gt; one -&gt; a = two.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : three, a &lt;&gt; zero /\ a &lt;&gt; one -&gt; a = two</div></blockquote></div></div></small></span></pre><p>Now some examples online suggest doing the following:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : three, a &lt;&gt; zero /\ a &lt;&gt; one -&gt; a = two</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>three</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; zero /\ a &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = two</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk3"><span class="nb">destruct</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero /\ zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = two</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>one &lt;&gt; zero /\ one &lt;&gt; one</span></span></span><br></div><label class="goal-separator" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk4"><hr></label><div class="goal-conclusion">one = two</div></blockquote><input class="alectryon-extra-goal-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>two &lt;&gt; zero /\ two &lt;&gt; one</span></span></span><br></div><label class="goal-separator" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk5"><hr></label><div class="goal-conclusion">two = two</div></blockquote></div></div></div></small></span></pre><p>In which case I get:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk6" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">3</span> subgoals

  H : zero &lt;&gt; zero /\ zero &lt;&gt; one
  ============================
  zero = two

subgoal <span class="mi">2</span> <span class="kr">is</span>:
 one = two
subgoal <span class="mi">3</span> <span class="kr">is</span>:
 two = two</blockquote></div></div></small></span></pre><p>So, I want to prove that the first two cases are impossible. But the
machine lists them as subgoals and wants me to PROVE them... which is
impossible.</p>
<p>Summary: How to exactly discard the impossible cases?</p>
<p>I have seen some examples using <span class="docutils literal">inversion</span> but I don't understand
the procedure.</p>
<p>Finally, what happens if my lemma depends on several inductive types
and I still want to cover ALL cases?</p>
</section>
<section id="answer-akoprowski">
<h2>Answer (akoprowski)</h2>
<p>How to discard impossible cases? Well, it's true that the first two
obligations are impossible to prove, but note they have contradicting
assumptions (<span class="docutils literal">zero &lt;&gt; zero</span> and <span class="docutils literal">one &lt;&gt; one</span>, respectively). So
you will be able to prove those goals with <span class="docutils literal">tauto</span> (there are also
more primitive tactics that will do the trick, if you are interested).</p>
<p><span class="docutils literal">inversion</span> is a more advanced version of destruct. Additional to
'destructing' the inductive, it will sometimes generate some
equalities (that you may need). It itself is a simple version of
<span class="docutils literal">induction</span>, which will additionally generate an induction
hypothesis for you.</p>
<p>If you have several inductive types in your goal, you can
<span class="docutils literal">destruct</span>/<span class="docutils literal">invert</span> them one by one.</p>
<p>More detailed walk-through:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">three</span> := zero | one | two.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk7"><span class="kn">Lemma</span> <span class="nf">test</span> : <span class="kr">forall</span> <span class="nv">a</span>, a &lt;&gt; zero /\ a &lt;&gt; one -&gt; a = two.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : three, a &lt;&gt; zero /\ a &lt;&gt; one -&gt; a = two</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : three, a &lt;&gt; zero /\ a &lt;&gt; one -&gt; a = two</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk9"><span class="nb">intros</span> a H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>three</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; zero /\ a &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = two</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chka"><span class="nb">destruct</span> H. <span class="c">(* to get two parts of conjunction *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>three</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; zero</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = two</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chkb"><span class="nb">destruct</span> a. <span class="c">(* case analysis on &#39;a&#39; *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = two</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>one &lt;&gt; zero</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>one &lt;&gt; one</span></span></span><br></div><label class="goal-separator" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chkc"><hr></label><div class="goal-conclusion">one = two</div></blockquote><input class="alectryon-extra-goal-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>two &lt;&gt; zero</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>two &lt;&gt; one</span></span></span><br></div><label class="goal-separator" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chkd"><hr></label><div class="goal-conclusion">two = two</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* low-level proof *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chke">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = two</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chkf"><span class="nb">compute</span> <span class="kr">in</span> H. <span class="c">(* to see through the &#39;&lt;&gt;&#39; notation *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>zero = zero -&gt; <span class="kt">False</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = two</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk10"><span class="nb">elimtype</span> <span class="kt">False</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>zero = zero -&gt; <span class="kt">False</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"> <span class="c">(* meaning: assumptions are contradictory, I can</span>
<span class="c">                       prove False from them *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk11"><span class="nb">apply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>zero = zero -&gt; <span class="kt">False</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = zero</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* can as well be handled with more high-level tactics *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk12">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>one &lt;&gt; zero</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>one &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">one = two</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* the &quot;proper&quot; case *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk13">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>two &lt;&gt; zero</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>two &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">two = two</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></section>
<section id="answer-gilles-so-stop-being-evil">
<h2>Answer (Gilles 'SO- stop being evil')</h2>
<p>If you see an impossible goal, there are two possibilities: either you
made a mistake in your proof strategy (perhaps your lemma is wrong),
or the hypotheses are contradictory.</p>
<p>If you think the hypotheses are contradictory, you can set the goal to
<span class="docutils literal">False</span>, to get a little complexity out of the way. <span class="docutils literal">elimtype False</span> achieves this. Often, you prove <span class="docutils literal">False</span> by proving a
proposition <span class="docutils literal">P</span> and its negation <span class="docutils literal">~ P</span>; the tactic <span class="docutils literal">absurd P</span>
deduces any goal from <span class="docutils literal">P</span> and <span class="docutils literal">~ P</span>. If there's a particular
hypothesis which is contradictory, <span class="docutils literal">contradict H</span> will set the goal
to <span class="docutils literal">~ H</span>, or if the hypothesis is a negation <span class="docutils literal">~ A</span> then the goal
will be <span class="docutils literal">A</span> (stronger than <span class="docutils literal">~ ~ A</span> but usually more convenient).
If one particular hypothesis is obviously contradictory,
<span class="docutils literal">contradiction H</span> or just <span class="docutils literal">contradiction</span> will prove any goal.</p>
<p>There are many tactics involving hypotheses of inductive types.
Figuring out which one to use is mostly a matter of experience. Here
are the main ones (but you will run into cases not covered here soon):</p>
<ol class="arabic simple">
<li><p><span class="docutils literal">destruct</span> simply breaks down the hypothesis into several parts.
It loses information about dependencies and recursion. A typical
example is <span class="docutils literal">destruct H</span> where <span class="docutils literal">H</span> is a conjunction <span class="docutils literal">H : A /\ B</span>, which splits <span class="docutils literal">H</span> into two independent hypotheses of types
<span class="docutils literal">A</span> and <span class="docutils literal">B</span>; or dually <span class="docutils literal">destruct H</span> where <span class="docutils literal">H</span> is a
disjunction <span class="docutils literal">H : A \/ B</span>, which splits the proof into two
different subproofs, one with the hypothesis <span class="docutils literal">A</span> and one with the
hypothesis <span class="docutils literal">B</span>.</p></li>
<li><p><span class="docutils literal">case_eq</span> is similar to <span class="docutils literal">destruct</span>, but retains the connections
that the hypothesis has with other hypotheses. For example,
<span class="docutils literal">destruct n</span> where <span class="docutils literal">n : nat</span> breaks the proof into two
subproofs, one for <span class="docutils literal">n = 0</span> and one for <span class="docutils literal">n = S m</span>. If <span class="docutils literal">n</span> is
used in other hypotheses (i.e. you have a <span class="docutils literal">H : P n</span>), you may
need to remember that the <span class="docutils literal">n</span> you've destructed is the same <span class="docutils literal">n</span>
used in these hypotheses: <span class="docutils literal">case_eq n</span> does this.</p></li>
<li><p><span class="docutils literal">inversion</span> performs a case analysis on the type of a hypothesis.
It is particularly useful when there are dependencies in the type
of the hypothesis that <span class="docutils literal">destruct</span> would forget. You would
typically use <span class="docutils literal">case_eq</span> on hypotheses in <span class="docutils literal">Set</span> (where equality
is relevant) and <span class="docutils literal">inversion</span> on hypotheses in <span class="docutils literal">Prop</span> (which
have very dependent types). The <span class="docutils literal">inversion</span> tactic leaves a lot
of equalities behind, and it's often followed by <span class="docutils literal">subst</span> to
simplify the hypotheses. The <span class="docutils literal">inversion_clear</span> tactic is a simple
alternative to <span class="docutils literal">inversion; subst</span> but loses a little information.</p></li>
<li><p><span class="docutils literal">induction</span> means that you are going to prove the goal by
induction (= recursion) on the given hypothesis. For example,
<span class="docutils literal">induction n</span> where <span class="docutils literal">n : nat</span> means that you'll perform integer
induction and prove the base case (<span class="docutils literal">n</span> replaced by <span class="docutils literal">0</span>) and the
inductive case (<span class="docutils literal">n</span> replaced by <span class="docutils literal">m + 1</span>).</p></li>
</ol>
<p>Your example is simple enough that you can prove it as &quot;obvious by
case analysis on <span class="docutils literal">a</span>&quot;.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk14"><span class="kn">Lemma</span> <span class="nf">has2b2</span> : <span class="kr">forall</span> <span class="nv">a</span> : three, a &lt;&gt; zero /\ a &lt;&gt; one -&gt; a = two.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : three, a &lt;&gt; zero /\ a &lt;&gt; one -&gt; a = two</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk15"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : three, a &lt;&gt; zero /\ a &lt;&gt; one -&gt; a = two</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> a; <span class="bp">tauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>But let's look at the cases generated by the <span class="docutils literal">destruct</span> tactic, i.e.
after just <span class="docutils literal">intros; destruct a.</span>. (The case where <span class="docutils literal">a</span> is <span class="docutils literal">one</span>
is symmetric; the last case, where <span class="docutils literal">a</span> is <span class="docutils literal">two</span>, is obvious by
reflexivity.)</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk16">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero /\ zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = two</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk17" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">1</span> subgoal

  H : zero &lt;&gt; zero /\ zero &lt;&gt; one
  ============================
  zero = two</blockquote></div></div></small></span></pre><p>The goal looks impossible. We can tell this to Coq, and here it can
spot the contradiction automatically (<span class="docutils literal">zero = zero</span> is obvious, and
the rest is a first-order tautology handled by the <span class="docutils literal">tauto</span> tactic).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk18"><span class="nb">elimtype</span> <span class="kt">False</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero /\ zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">tauto</span>.</span></span></pre><p>In fact <span class="docutils literal">tauto</span> works even if you don't start by telling Coq not to
worry about the goal and wrote <span class="docutils literal">tauto</span> without the <span class="docutils literal">elimtype False</span> first (IIRC it didn't in older versions of Coq). You can see
what Coq is doing with the <span class="docutils literal">tauto</span> tactic by writing <span class="docutils literal">info tauto</span>.
Coq will tell you what proof script the <span class="docutils literal">tauto</span> tactic generated.
It's not very easy to follow, so let's look at a manual proof of this
case. First, let's split the hypothesis (which is a conjunction) into
two.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk19"><span class="nb">destruct</span> H <span class="kr">as</span> [H0 H1].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = two</div></blockquote></div></div></small></span></pre><p>We now have two hypotheses, one of which is <span class="docutils literal">zero &lt;&gt; zero</span>. This is
clearly false, because it's the negation of <span class="docutils literal">zero = zero</span> which is
clearly true.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1a"><span class="bp">contradiction</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = zero</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span></span></pre><p>We can look in even more detail at what the <span class="docutils literal">contradiction</span> tactic
does. (<span class="docutils literal">info contradiction</span> would reveal what happens under the
scene, but again it's not novice-friendly). We claim that the goal is
true because the hypotheses are contradictory so we can prove
anything. So let's set the intermediate goal to <span class="docutils literal">False</span>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1b"><span class="nb">assert</span> (F : <span class="kt">False</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><label class="goal-separator" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1c"><hr></label><div class="goal-conclusion">zero = two</div></blockquote></div></div></div></small></span></pre><p>Run <span class="docutils literal">red in H0.</span> to see that <span class="docutils literal">zero &lt;&gt; zero</span> is really notation for
<span class="docutils literal">~(zero = zero)</span> which in turn is defined as meaning <span class="docutils literal">zero = zero <span class="pre">-&gt;</span> False</span>. So <span class="docutils literal">False</span> is the conclusion of <span class="docutils literal">H0</span>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1e"><span class="nb">red</span> <span class="kr">in</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero = zero -&gt; <span class="kt">False</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk1f"><span class="nb">apply</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero = zero -&gt; <span class="kt">False</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = zero</div></blockquote></div></div></small></span></pre><p>And now we need to prove that <span class="docutils literal">zero = zero</span>, which is</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span></span></pre><p>Now we've proved our assertion of <span class="docutils literal">False</span>. What remains is to prove
that <span class="docutils literal">False</span> implies our goal. Well, <span class="docutils literal">False</span> implies any goal,
that's its definition (<span class="docutils literal">False</span> is defined as an inductive type with
0 case).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-cases-with-an-inductive-type-in-coq-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-cases-with-an-inductive-type-in-coq-v-chk20">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; zero</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>zero &lt;&gt; one</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = two</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> F.</span></span></pre></section>
</div>
</main>
</div></body>
</html>
