<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Coq: destruct (co)inductive hypothesis without losing information</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="coq-destruct-co-inductive-hypothesis-without-losing-information">
<h1 class="title">Coq: destruct (co)inductive hypothesis without losing information</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/45151308">https://stackoverflow.com/q/45151308</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>Consider the following development:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Relation_Definitions RelationClasses.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoInductive</span> <span class="nf">stream</span> (<span class="nv">A</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
| scons : A -&gt; stream A -&gt; stream A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoInductive</span> <span class="nf">stream_le</span> (<span class="nv">A</span> : <span class="kt">Type</span>) {<span class="nv">eqA</span> <span class="nv">R</span> : relation A}
            `{PO : PartialOrder A eqA R} :
  stream A -&gt; stream A -&gt; <span class="kt">Prop</span> :=
| le_step : <span class="kr">forall</span> <span class="nv">h1</span> <span class="nv">h2</span> <span class="nv">t1</span> <span class="nv">t2</span>, R h1 h2 -&gt;
                                (eqA h1 h2 -&gt; stream_le t1 t2) -&gt;
                                stream_le (scons h1 t1) (scons h2 t2).</span></span></pre><p>If I have a hypothesis <span class="docutils literal">stream_le (scons h1 t1) (scons h2 t2)</span>, it
would be reasonable for the <span class="docutils literal">destruct</span> tactic to turn it into a pair
of hypotheses <span class="docutils literal">R h1 h2</span> and <span class="docutils literal">eqA h1 h2 <span class="pre">-&gt;</span> stream_le t1 t2</span>. But
that's not what happens, because <span class="docutils literal">destruct</span> loses information
whenever doing anything non-trivial. Instead, new terms <span class="docutils literal">h0</span>,
<span class="docutils literal">h3</span>, <span class="docutils literal">t0</span>, <span class="docutils literal">t3</span> are introduced into the context, with no recall
that they are respectively equal to <span class="docutils literal">h1</span>, <span class="docutils literal">h2</span>, <span class="docutils literal">t1</span>, <span class="docutils literal">t2</span>.</p>
<p>I would like to know if there is a quick and easy way to do this kind
of &quot;smart <span class="docutils literal">destruct</span>&quot;. Here is what i have right now:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk0"><span class="kn">Theorem</span> <span class="nf">stream_le_destruct</span> :
  <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) <span class="nv">eqA</span> <span class="nv">R</span>
         `{PO : PartialOrder A eqA R} (h1 h2 : A) (t1 t2 : stream A),
    stream_le (scons h1 t1) (scons h2 t2) -&gt;
    R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">eqA</span> <span class="nv">R</span> : relation A)
  (<span class="nv">equ</span> : Equivalence eqA) (<span class="nv">preo</span> : PreOrder R)
  (<span class="nv">PO</span> : PartialOrder eqA R) (<span class="nv">h1</span> <span class="nv">h2</span> : A)
  (<span class="nv">t1</span> <span class="nv">t2</span> : stream A),
stream_le (scons h1 t1) (scons h2 t2) -&gt;
R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">eqA</span> <span class="nv">R</span> : relation A)
  (<span class="nv">equ</span> : Equivalence eqA) (<span class="nv">preo</span> : PreOrder R)
  (<span class="nv">PO</span> : PartialOrder eqA R) (<span class="nv">h1</span> <span class="nv">h2</span> : A)
  (<span class="nv">t1</span> <span class="nv">t2</span> : stream A),
stream_le (scons h1 t1) (scons h2 t2) -&gt;
R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>eqA, R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>equ</var><span class="hyp-type"><b>: </b><span>Equivalence eqA</span></span></span><br><span><var>preo</var><span class="hyp-type"><b>: </b><span>PreOrder R</span></span></span><br><span><var>PO</var><span class="hyp-type"><b>: </b><span>PartialOrder eqA R</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>stream_le (scons h1 t1) (scons h2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk3"><span class="nb">destruct</span> H <span class="nb">eqn</span>:Heq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>eqA, R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>equ</var><span class="hyp-type"><b>: </b><span>Equivalence eqA</span></span></span><br><span><var>preo</var><span class="hyp-type"><b>: </b><span>PreOrder R</span></span></span><br><span><var>PO</var><span class="hyp-type"><b>: </b><span>PartialOrder eqA R</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>h0, h3</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t0, t3</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>stream_le (scons h0 t0) (scons h3 t3)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R h0 h3</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>eqA h0 h3 -&gt; stream_le t0 t3</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>H = le_step h0 h3 r s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk4"><span class="kn">Undo</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>eqA, R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>equ</var><span class="hyp-type"><b>: </b><span>Equivalence eqA</span></span></span><br><span><var>preo</var><span class="hyp-type"><b>: </b><span>PreOrder R</span></span></span><br><span><var>PO</var><span class="hyp-type"><b>: </b><span>PartialOrder eqA R</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>stream_le (scons h1 t1) (scons h2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk5"><span class="nb">remember</span> (scons h1 t1) <span class="kr">as</span> s1 <span class="nb">eqn</span>:Heqs1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>eqA, R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>equ</var><span class="hyp-type"><b>: </b><span>Equivalence eqA</span></span></span><br><span><var>preo</var><span class="hyp-type"><b>: </b><span>PreOrder R</span></span></span><br><span><var>PO</var><span class="hyp-type"><b>: </b><span>PartialOrder eqA R</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1, t2, s1</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>Heqs1</var><span class="hyp-type"><b>: </b><span>s1 = scons h1 t1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>stream_le s1 (scons h2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk6"><span class="nb">remember</span> (scons h2 t2) <span class="kr">as</span> s2 <span class="nb">eqn</span>:Heqs2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>eqA, R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>equ</var><span class="hyp-type"><b>: </b><span>Equivalence eqA</span></span></span><br><span><var>preo</var><span class="hyp-type"><b>: </b><span>PreOrder R</span></span></span><br><span><var>PO</var><span class="hyp-type"><b>: </b><span>PartialOrder eqA R</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1, t2, s1</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>Heqs1</var><span class="hyp-type"><b>: </b><span>s1 = scons h1 t1</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>Heqs2</var><span class="hyp-type"><b>: </b><span>s2 = scons h2 t2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>stream_le s1 s2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk7"><span class="nb">destruct</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>eqA, R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>equ</var><span class="hyp-type"><b>: </b><span>Equivalence eqA</span></span></span><br><span><var>preo</var><span class="hyp-type"><b>: </b><span>PreOrder R</span></span></span><br><span><var>PO</var><span class="hyp-type"><b>: </b><span>PartialOrder eqA R</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>h0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>Heqs1</var><span class="hyp-type"><b>: </b><span>scons h0 t0 = scons h1 t1</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t3</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>Heqs2</var><span class="hyp-type"><b>: </b><span>scons h3 t3 = scons h2 t2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>R h0 h3</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>eqA h0 h3 -&gt; stream_le t0 t3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk8"><span class="nb">inversion</span> Heqs1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>eqA, R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>equ</var><span class="hyp-type"><b>: </b><span>Equivalence eqA</span></span></span><br><span><var>preo</var><span class="hyp-type"><b>: </b><span>PreOrder R</span></span></span><br><span><var>PO</var><span class="hyp-type"><b>: </b><span>PartialOrder eqA R</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>h0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>Heqs1</var><span class="hyp-type"><b>: </b><span>scons h0 t0 = scons h1 t1</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t3</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>Heqs2</var><span class="hyp-type"><b>: </b><span>scons h3 t3 = scons h2 t2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>R h0 h3</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>eqA h0 h3 -&gt; stream_le t0 t3</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>h0 = h1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>t0 = t1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk9"><span class="nb">inversion</span> Heqs2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>eqA, R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>equ</var><span class="hyp-type"><b>: </b><span>Equivalence eqA</span></span></span><br><span><var>preo</var><span class="hyp-type"><b>: </b><span>PreOrder R</span></span></span><br><span><var>PO</var><span class="hyp-type"><b>: </b><span>PartialOrder eqA R</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>h0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>Heqs1</var><span class="hyp-type"><b>: </b><span>scons h0 t0 = scons h1 t1</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t3</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>Heqs2</var><span class="hyp-type"><b>: </b><span>scons h3 t3 = scons h2 t2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>R h0 h3</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>eqA h0 h3 -&gt; stream_le t0 t3</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>h0 = h1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>t0 = t1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>h3 = h2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>t3 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chka"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>eqA, R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>equ</var><span class="hyp-type"><b>: </b><span>Equivalence eqA</span></span></span><br><span><var>preo</var><span class="hyp-type"><b>: </b><span>PreOrder R</span></span></span><br><span><var>PO</var><span class="hyp-type"><b>: </b><span>PartialOrder eqA R</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>Heqs1</var><span class="hyp-type"><b>: </b><span>scons h1 t1 = scons h1 t1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>R h1 h2</span></span></span><br><span><var>Heqs2</var><span class="hyp-type"><b>: </b><span>scons h2 t2 = scons h2 t2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>eqA h1 h2 -&gt; stream_le t1 t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></section>
<section id="answer-arthur-azevedo-de-amorim">
<h2>Answer (Arthur Azevedo De Amorim)</h2>
<p>Calling <span class="docutils literal">destruct</span> will not directly give you what you want. You
need to use <span class="docutils literal">inversion</span> instead.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chkb"><span class="kn">Theorem</span> <span class="nf">stream_le_destruct</span> :
  <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) <span class="nv">eqA</span> <span class="nv">R</span>
         `{PO : PartialOrder A eqA R} (h1 h2 : A) (t1 t2 : stream A),
    stream_le (scons h1 t1) (scons h2 t2) -&gt;
    R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">eqA</span> <span class="nv">R</span> : relation A)
  (<span class="nv">equ</span> : Equivalence eqA) (<span class="nv">preo</span> : PreOrder R)
  (<span class="nv">PO</span> : PartialOrder eqA R) (<span class="nv">h1</span> <span class="nv">h2</span> : A)
  (<span class="nv">t1</span> <span class="nv">t2</span> : stream A),
stream_le (scons h1 t1) (scons h2 t2) -&gt;
R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chkc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">eqA</span> <span class="nv">R</span> : relation A)
  (<span class="nv">equ</span> : Equivalence eqA) (<span class="nv">preo</span> : PreOrder R)
  (<span class="nv">PO</span> : PartialOrder eqA R) (<span class="nv">h1</span> <span class="nv">h2</span> : A)
  (<span class="nv">t1</span> <span class="nv">t2</span> : stream A),
stream_le (scons h1 t1) (scons h2 t2) -&gt;
R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chkd"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>eqA, R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>equ</var><span class="hyp-type"><b>: </b><span>Equivalence eqA</span></span></span><br><span><var>preo</var><span class="hyp-type"><b>: </b><span>PreOrder R</span></span></span><br><span><var>PO</var><span class="hyp-type"><b>: </b><span>PartialOrder eqA R</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>stream_le (scons h1 t1) (scons h2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chke"><span class="nb">inversion</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>eqA, R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>equ</var><span class="hyp-type"><b>: </b><span>Equivalence eqA</span></span></span><br><span><var>preo</var><span class="hyp-type"><b>: </b><span>PreOrder R</span></span></span><br><span><var>PO</var><span class="hyp-type"><b>: </b><span>PartialOrder eqA R</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>stream_le (scons h1 t1) (scons h2 t2)</span></span></span><br><span><var>h0, h3</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t0, t3</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>R h1 h2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>eqA h1 h2 -&gt; stream_le t1 t2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>h0 = h1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>t0 = t1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>h3 = h2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>t3 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chkf"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>eqA, R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>equ</var><span class="hyp-type"><b>: </b><span>Equivalence eqA</span></span></span><br><span><var>preo</var><span class="hyp-type"><b>: </b><span>PreOrder R</span></span></span><br><span><var>PO</var><span class="hyp-type"><b>: </b><span>PartialOrder eqA R</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>stream_le (scons h1 t1) (scons h2 t2)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>R h1 h2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>eqA h1 h2 -&gt; stream_le t1 t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Unfortunately, the <span class="docutils literal">inversion</span> tactic is quite ill behaved, as it
tends to generate a lot of spurious equality hypotheses, making it
hard to name them consistently. One (somewhat heavyweight, admittedly)
alternative is to use <span class="docutils literal">inversion</span> only to prove a lemma like the one
you did, and apply this lemma in proofs instead of calling
<span class="docutils literal">inversion</span>.</p>
</section>
<section id="answer-ejgallego">
<h2>Answer (ejgallego)</h2>
<p>Indeed, <span class="docutils literal">inversion</span> basically does what you want, however as Arthur
pointed out it is a bit unstable, mainly due to the different
congruence steps.</p>
<p>Under the hood, <span class="docutils literal">inversion</span> just calls a version of <span class="docutils literal">destruct</span>,
but remembering some equalities first. As you have well discovered,
pattern matching in Coq will &quot;forget&quot; arguments of constructors,
except if these are variables, then, all the variables <em>under the
scope</em> of the destruct will be instantiated.</p>
<p>What does that mean? It means that in order to properly destruct an
inductive <span class="docutils literal">I : Idx <span class="pre">-&gt;</span> Prop</span>, you want to get your goal of the form:
<span class="docutils literal">I x <span class="pre">-&gt;</span> Q x</span>, so that destructing the <span class="docutils literal">I x</span> will also refine the
<span class="docutils literal">x</span> in <span class="docutils literal">Q</span>. Thus, a standard transformation for an inductive <span class="docutils literal">I term</span> and goal <span class="docutils literal">Q (f term)</span> is to rewrite it to <span class="docutils literal">I x <span class="pre">-&gt;</span> x = term <span class="pre">-&gt;</span> Q (f x)</span>. Then, destructing <span class="docutils literal">I x</span> will get you <span class="docutils literal">x</span>
instantiated to the proper index.</p>
<p>With that in mind, it may be a good exercise to implement inversion
manually using the <span class="docutils literal">case:</span> tactic of Coq 8.7;</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> ssreflect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk10"><span class="kn">Theorem</span> <span class="nf">stream_le_destruct</span> <span class="nv">A</span> <span class="nv">eqA</span> <span class="nv">R</span>
        `{PO : PartialOrder A eqA R} (h1 h2 : A) (t1 t2 : stream A) :
  stream_le (scons h1 t1) (scons h2 t2) -&gt;
  R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>eqA, R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>equ</var><span class="hyp-type"><b>: </b><span>Equivalence eqA</span></span></span><br><span><var>preo</var><span class="hyp-type"><b>: </b><span>PreOrder R</span></span></span><br><span><var>PO</var><span class="hyp-type"><b>: </b><span>PartialOrder eqA R</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">stream_le (scons h1 t1) (scons h2 t2) -&gt;
R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>eqA, R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>equ</var><span class="hyp-type"><b>: </b><span>Equivalence eqA</span></span></span><br><span><var>preo</var><span class="hyp-type"><b>: </b><span>PreOrder R</span></span></span><br><span><var>PO</var><span class="hyp-type"><b>: </b><span>PartialOrder eqA R</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">stream_le (scons h1 t1) (scons h2 t2) -&gt;
R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk12"><span class="nb">move</span> E1: (scons h1 t1) =&gt; sc1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>eqA, R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>equ</var><span class="hyp-type"><b>: </b><span>Equivalence eqA</span></span></span><br><span><var>preo</var><span class="hyp-type"><b>: </b><span>PreOrder R</span></span></span><br><span><var>PO</var><span class="hyp-type"><b>: </b><span>PartialOrder eqA R</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1, t2, sc1</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>E1</var><span class="hyp-type"><b>: </b><span>scons h1 t1 = sc1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">stream_le sc1 (scons h2 t2) -&gt;
R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-destruct-coinductive-hypothesis-without-losing-information-v-chk13"><span class="nb">move</span> E2: (scons h2 t2) =&gt; sc2 H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>eqA, R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>equ</var><span class="hyp-type"><b>: </b><span>Equivalence eqA</span></span></span><br><span><var>preo</var><span class="hyp-type"><b>: </b><span>PreOrder R</span></span></span><br><span><var>PO</var><span class="hyp-type"><b>: </b><span>PartialOrder eqA R</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1, t2, sc1</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>E1</var><span class="hyp-type"><b>: </b><span>scons h1 t1 = sc1</span></span></span><br><span><var>sc2</var><span class="hyp-type"><b>: </b><span>stream A</span></span></span><br><span><var>E2</var><span class="hyp-type"><b>: </b><span>scons h2 t2 = sc2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>stream_le sc1 sc2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R h1 h2 /\ (eqA h1 h2 -&gt; stream_le t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: sc1 sc2 / H E1 E2 =&gt; h1&#39; h2&#39; t1&#39; t2&#39; hr ih [? ?] [? ?]; <span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>You can read the manual for more details, but basically with the first
line, we create the equalities we need; then, in the second we can
destruct the term and get the proper instantiations solving the goal.
A good effect of the <span class="docutils literal">case:</span> tactic is that, contrary to destruct,
it will try to prevent us from destructing a term without first
bringing its dependencies into scope.</p>
</section>
</div>
</main>
</div></body>
</html>
