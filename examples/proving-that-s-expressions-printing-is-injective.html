<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>Proving that s-expressions printing is injective</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="proving-that-s-expressions-printing-is-injective">
<h1 class="title">Proving that s-expressions printing is injective</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/69617959">https://stackoverflow.com/q/69617959</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>I defined a type of s-expressions and it's printing functions.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">sexp</span> : <span class="kt">Set</span> :=
  K : string -&gt; list sexp -&gt; sexp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">sexpprint</span> (<span class="nv">s</span> : sexp) : list string :=
  <span class="kr">match</span> s <span class="kr">with</span>
    K n l =&gt; [<span class="s2">&quot;(&quot;</span>%string]++[n]++(List.concat (map sexpprint l))++[<span class="s2">&quot;)&quot;</span>%string]
  <span class="kr">end</span>.</span></span></pre><p>(Yes, I understand it can be just string, not the list of strings, but
Coq have small amount of theorems for working with strings, but a big
amount for working with lists.)</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* more usual function *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">sexpprint&#39;</span> (<span class="nv">s</span>:sexp) :string :=
  <span class="kr">match</span> s <span class="kr">with</span>
    K n l =&gt; <span class="s2">&quot;(&quot;</span> ++ n ++ (String.concat <span class="s2">&quot;&quot;</span> (map sexpprint&#39; l)) ++ <span class="s2">&quot;)&quot;</span>
  <span class="kr">end</span>.</span></span></pre><p>And I've got stuck trying to prove this theorem:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-that-s-expressions-printing-is-injective-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-that-s-expressions-printing-is-injective-v-chk0"><span class="kn">Theorem</span> <span class="nf">sexpprint_inj</span> <span class="nv">s1</span> <span class="nv">s2</span> :
  sexpprint s1 = sexpprint s2 -&gt; s1 = s2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>sexp</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sexpprint s1 = sexpprint s2 -&gt; s1 = s2</div></blockquote></div></div></small></span></pre><p>Maybe there are some sources which can help me to plan the theorem's
proof? (books/articles/codes) How to prove it? (Maybe I need a special
kind of inductive principle, could you formulate its statement?)</p>
</div>
<div class="section" id="answer">
<h1>Answer</h1>
<p>The type <tt class="docutils literal">sexp</tt> is an example of a <em>nested inductive type</em>, where
one of the recursive occurrences appears inside of another induction.
Such types are hard to work with in Coq, because the induction
principles that it generates by default are not useful. However, you
can fix this issue by writing down your own induction principle by
hand. Here is one possibility:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unset Elimination Schemes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">sexp</span> : <span class="kt">Type</span> :=
| K : string -&gt; list sexp -&gt; sexp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Elimination Schemes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">tuple</span> (<span class="nv">T</span> : sexp -&gt; <span class="kt">Type</span>) (<span class="nv">es</span> : list sexp) :=
  fold_right (<span class="kr">fun</span> <span class="nv">e</span> <span class="nv">R</span> =&gt; T e * R)%type unit es.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sexp_rect</span>
           (<span class="nv">T</span> : sexp -&gt; <span class="kt">Type</span>)
           (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">s</span> <span class="nv">es</span>, tuple T es -&gt; T (K s es)) :
  <span class="kr">forall</span> <span class="nv">e</span>, T e :=
  <span class="kr">fix</span> outer (e : sexp) : T e :=
    <span class="kr">match</span> e <span class="kr">with</span>
    | K s es =&gt;
      <span class="kr">let fix</span> <span class="nv">inner</span> (<span class="nv">es</span> : list sexp) : tuple T es :=
          <span class="kr">match</span> es <span class="kr">return</span> tuple T es <span class="kr">with</span>
          | [] =&gt; tt
          | e :: es =&gt; (outer e, inner es)
          <span class="kr">end</span> <span class="kr">in</span>
      H s es (inner es)
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sexp_ind</span> (<span class="nv">T</span> : sexp -&gt; <span class="kt">Prop</span>) := sexp_rect T.</span></span></pre><p>With this induction principle, it is now possible to prove your lemma
(exercise!), but you will need to generalize its statement a bit.</p>
<p>For a deeper discussion about these nested inductives, you can have a
look at <a class="reference external" href="http://adam.chlipala.net/cpdt/html/Cpdt.InductiveTypes.html">CPDT</a>.</p>
</div>
</div>
</div>
</div></body>
</html>
