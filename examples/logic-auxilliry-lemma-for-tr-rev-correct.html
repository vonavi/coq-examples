<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Logic: auxilliry lemma for tr_rev_correct</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="logic-auxilliry-lemma-for-tr-rev-correct">
<h1 class="title">Logic: auxilliry lemma for <span class="docutils literal">tr_rev_correct</span></h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/55991920">https://stackoverflow.com/q/55991920</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>In Logic chapter a tail recursive version of reverse list function is
introduced. We need to prove that it works correctly:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">rev_append</span> {<span class="nv">X</span>} (<span class="nv">l1</span> <span class="nv">l2</span> : list X) : list X :=
  <span class="kr">match</span> l1 <span class="kr">with</span>
  | [] =&gt; l2
  | x :: l1&#39; =&gt; rev_append l1&#39; (x :: l2)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Tail recursion rev *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">tr_rev</span> {<span class="nv">X</span>} (<span class="nv">l</span> : list X) : list X :=
  rev_append l [].</span></span></pre><p>But before proving it I wanted to prove a lemma:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk0"><span class="kn">Lemma</span> <span class="nf">rev_append_app</span>: <span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : X) (<span class="nv">l</span> : list X),
    rev_append l [x] = rev_append l [] ++ [x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : X) (<span class="nv">l</span> : list X),
rev_append l [x] = rev_append l [] ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : X) (<span class="nv">l</span> : list X),
rev_append l [x] = rev_append l [] ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk2"><span class="nb">intros</span> X x l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev_append l [x] = rev_append l [] ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk3"><span class="nb">induction</span> l <span class="kr">as</span> [| h t IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev_append [] [x] = rev_append [] [] ++ [x]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, h</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>rev_append t [x] = rev_append t [] ++ [x]</span></span></span><br></div><label class="goal-separator" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk4"><hr></label><div class="goal-conclusion">rev_append (h :: t) [x] =
rev_append (h :: t) [] ++ [x]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev_append [] [x] = rev_append [] [] ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk6"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x] = [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, h</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>rev_append t [x] = rev_append t [] ++ [x]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev_append (h :: t) [x] =
rev_append (h :: t) [] ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk8"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, h</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>rev_append t [x] = rev_append t [] ++ [x]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev_append t [h; x] = rev_append t [h] ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>Here I am stuck. What to do next?</p>
</section>
<section id="answer-simon">
<h2>Answer (Simon)</h2>
<p>As you noticed during your attempted proof, when taking the induction
step from <span class="docutils literal">rev_append l [x]</span> to <span class="docutils literal">rev_append (h :: t) [x]</span>, you end
up with the term <span class="docutils literal">rev_append t [h; x]</span> after simplification. The
induction step does not lead towards the base case of the
<span class="docutils literal">rev_append</span> function, but to another recursive invocation that you
cannot simplify.</p>
<p>Notice how the induction hypothesis that you would like to apply makes
a statement about <span class="docutils literal">rev_append t [x]</span> for some fixed <span class="docutils literal">x</span>, but in
your goal, the extra <span class="docutils literal">h</span> list element before it gets in the way, and
the induction hypothesis is of no use.</p>
<p>This is what Bubbler's answer was referring to when stating that your
induction hypothesis is not strong enough: it only makes a statement
about the case where the second argument is a list with a <em>single
element</em>. But even after just the induction step (one recursive
application), that list already has at least two elements!</p>
<p>As suggested by Bubbler, the helper lemma <span class="docutils literal">rev_append l (l1 ++ l2) = rev_append l l1 ++ l2</span> is stronger and does not have this problem:
when used as the induction hypothesis, it can be applied to
<span class="docutils literal">rev_append t [h; x]</span> as well, allowing you to prove equality with
<span class="docutils literal">rev_append t [h] ++ [x]</span>.</p>
<p>When attempting to prove the helper lemma, you may get stuck (like I
did) in the same way as when proving <span class="docutils literal">rev_append_app</span> itself. The
crucial bit of advice that helped me proceed was to <strong>be careful which
of the universally quantified variables you introduce before you start
the induction</strong>. If you specialize any of them too early on, you might
weaken your induction hypothesis and become stuck again. You may need
to change the order of these quantified variables or use the
<span class="docutils literal">generalize dependent</span> tactic (see the <a class="reference external" href="https://softwarefoundations.cis.upenn.edu/lf-current/Tactics.html">Tactics</a>
chapter of <em>Logic Foundations</em>).</p>
</section>
<section id="answer-bubbler">
<h2>Answer (Bubbler)</h2>
<p>You can see that the induction hypothesis <span class="docutils literal">IH</span> is not strong enough
to prove the goal. Here what you need is <strong>a more general statement to
prove in the first place</strong>. You can find more exercises dedicated to
this topic <a class="reference external" href="https://homes.cs.washington.edu/~jrw12/InductionExercises.html">here</a>.
(Actually, tail-recursive reverse is one of the exercises.)</p>
<p>In your case, the fully generalized statement could be as follows:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk9"><span class="kn">Lemma</span> <span class="nf">rev_append_app&#39;</span>: <span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">l1</span> <span class="nv">l2</span> : list X),
        rev_append l (l1 ++ l2) = rev_append l l1 ++ l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">l1</span> <span class="nv">l2</span> : list X),
rev_append l (l1 ++ l2) = rev_append l l1 ++ l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>Proving this by induction is trivial. Then you can prove your own
statement as a corollary of this one:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chka"><span class="kn">Corollary</span> <span class="nf">rev_append_app</span>: <span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : X) (<span class="nv">l</span> : list X),
    rev_append l [x] = rev_append l [] ++ [x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : X) (<span class="nv">l</span> : list X),
rev_append l [x] = rev_append l [] ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : X) (<span class="nv">l</span> : list X),
rev_append l [x] = rev_append l [] ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chkc"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev_append l [x] = rev_append l [] ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (rev_append_app&#39; _ _ [] [x]).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></section>
<section id="answer-xingfe123">
<h2>Answer (xingfe123)</h2>
<p>use the generalize dependent tactic like this:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chkd"><span class="kn">Lemma</span> <span class="nf">rev_append_app</span>: <span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">l1</span> : list X) (<span class="nv">x</span> : X),
    rev_append l (l1 ++ [x]) = rev_append l l1 ++ [x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">l1</span> : list X) (<span class="nv">x</span> : X),
rev_append l (l1 ++ [x]) = rev_append l l1 ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chke"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l1</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev_append l (l1 ++ [x]) = rev_append l l1 ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chkf"><span class="nb">generalize dependent</span> l1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l1</span> : list X,
rev_append l (l1 ++ [x]) = rev_append l l1 ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk10"><span class="nb">induction</span> l <span class="kr">as</span> [| h t IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l1</span> : list X,
rev_append [] (l1 ++ [x]) = rev_append [] l1 ++ [x]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list X,
rev_append t (l1 ++ [x]) = rev_append t l1 ++ [x]</span></span></span><br></div><label class="goal-separator" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk11"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l1</span> : list X,
rev_append (h :: t) (l1 ++ [x]) =
rev_append (h :: t) l1 ++ [x]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk12">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l1</span> : list X,
rev_append [] (l1 ++ [x]) = rev_append [] l1 ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk13"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev_append [] (l1 ++ [x]) = rev_append [] l1 ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk14">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list X,
rev_append t (l1 ++ [x]) = rev_append t l1 ++ [x]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l1</span> : list X,
rev_append (h :: t) (l1 ++ [x]) =
rev_append (h :: t) l1 ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk15"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list X,
rev_append t (l1 ++ [x]) = rev_append t l1 ++ [x]</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev_append (h :: t) (l1 ++ [x]) =
rev_append (h :: t) l1 ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (IH (h :: l1)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></section>
</div>
</main>
</div></body>
</html>
