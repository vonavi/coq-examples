<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>Logic: auxilliry lemma for tr_rev_correct</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="logic-auxilliry-lemma-for-tr-rev-correct">
<h1 class="title">Logic: auxilliry lemma for tr_rev_correct</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/55991920">https://stackoverflow.com/q/55991920</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>In Logic chapter a tail recursive version of reverse list function is
introduced. We need to prove that it works correctly:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">rev_append</span> {<span class="nv">X</span>} (<span class="nv">l1</span> <span class="nv">l2</span> : list X) : list X :=
  <span class="kr">match</span> l1 <span class="kr">with</span>
  | [] =&gt; l2
  | x :: l1&#39; =&gt; rev_append l1&#39; (x :: l2)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Tail recursion rev *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">tr_rev</span> {<span class="nv">X</span>} (<span class="nv">l</span> : list X) : list X :=
  rev_append l [].</span></span></pre><p>But before proving it I wanted to prove a lemma:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk0"><span class="kn">Lemma</span> <span class="nf">rev_append_app</span>: <span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : X) (<span class="nv">l</span> : list X),
    rev_append l [x] = rev_append l [] ++ [x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : X) (<span class="nv">l</span> : list X),
rev_append l [x] = rev_append l [] ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : X) (<span class="nv">l</span> : list X),
rev_append l [x] = rev_append l [] ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk2"><span class="nb">intros</span> X x l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev_append l [x] = rev_append l [] ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk3"><span class="nb">induction</span> l <span class="kr">as</span> [| h t IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev_append [] [x] = rev_append [] [] ++ [x]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, h</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>rev_append t [x] = rev_append t [] ++ [x]</span></span></span><br></div><label class="goal-separator" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk4"><hr></label><div class="goal-conclusion">rev_append (h :: t) [x] =
rev_append (h :: t) [] ++ [x]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev_append [] [x] = rev_append [] [] ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk6"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[x] = [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, h</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>rev_append t [x] = rev_append t [] ++ [x]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev_append (h :: t) [x] =
rev_append (h :: t) [] ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk8"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, h</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>rev_append t [x] = rev_append t [] ++ [x]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev_append t [h; x] = rev_append t [h] ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>Here I am stuck. What to do next?</p>
</div>
<div class="section" id="answer-simon">
<h1>Answer (Simon)</h1>
<p>As you noticed during your attempted proof, when taking the induction
step from <tt class="docutils literal">rev_append l [x]</tt> to <tt class="docutils literal">rev_append (h :: t) [x]</tt>, you end
up with the term <tt class="docutils literal">rev_append t [h; x]</tt> after simplification. The
induction step does not lead towards the base case of the
<tt class="docutils literal">rev_append</tt> function, but to another recursive invocation that you
cannot simplify.</p>
<p>Notice how the induction hypothesis that you would like to apply makes
a statement about <tt class="docutils literal">rev_append t [x]</tt> for some fixed <tt class="docutils literal">x</tt>, but in
your goal, the extra <tt class="docutils literal">h</tt> list element before it gets in the way, and
the induction hypothesis is of no use.</p>
<p>This is what Bubbler's answer was referring to when stating that your
induction hypothesis is not strong enough: it only makes a statement
about the case where the second argument is a list with a <em>single
element</em>. But even after just the induction step (one recursive
application), that list already has at least two elements!</p>
<p>As suggested by Bubbler, the helper lemma <tt class="docutils literal">rev_append l (l1 ++ l2) =
rev_append l l1 ++ l2</tt> is stronger and does not have this problem:
when used as the induction hypothesis, it can be applied to
<tt class="docutils literal">rev_append t [h; x]</tt> as well, allowing you to prove equality with
<tt class="docutils literal">rev_append t [h] ++ [x]</tt>.</p>
<p>When attempting to prove the helper lemma, you may get stuck (like I
did) in the same way as when proving <tt class="docutils literal">rev_append_app</tt> itself. The
crucial bit of advice that helped me proceed was to <strong>be careful which
of the universally quantified variables you introduce before you start
the induction</strong>. If you specialize any of them too early on, you might
weaken your induction hypothesis and become stuck again. You may need
to change the order of these quantified variables or use the
<tt class="docutils literal">generalize dependent</tt> tactic (see the <a class="reference external" href="https://softwarefoundations.cis.upenn.edu/lf-current/Tactics.html">Tactics</a>
chapter of <em>Logic Foundations</em>).</p>
</div>
<div class="section" id="answer-bubbler">
<h1>Answer (Bubbler)</h1>
<p>You can see that the induction hypothesis <tt class="docutils literal">IH</tt> is not strong enough
to prove the goal. Here what you need is <strong>a more general statement to
prove in the first place</strong>. You can find more exercises dedicated to
this topic <a class="reference external" href="https://homes.cs.washington.edu/~jrw12/InductionExercises.html">here</a>.
(Actually, tail-recursive reverse is one of the exercises.)</p>
<p>In your case, the fully generalized statement could be as follows:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk9"><span class="kn">Lemma</span> <span class="nf">rev_append_app&#39;</span>: <span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">l1</span> <span class="nv">l2</span> : list X),
        rev_append l (l1 ++ l2) = rev_append l l1 ++ l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">l1</span> <span class="nv">l2</span> : list X),
rev_append l (l1 ++ l2) = rev_append l l1 ++ l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>Proving this by induction is trivial. Then you can prove your own
statement as a corollary of this one:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chka"><span class="kn">Corollary</span> <span class="nf">rev_append_app</span>: <span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : X) (<span class="nv">l</span> : list X),
    rev_append l [x] = rev_append l [] ++ [x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : X) (<span class="nv">l</span> : list X),
rev_append l [x] = rev_append l [] ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : X) (<span class="nv">l</span> : list X),
rev_append l [x] = rev_append l [] ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chkc"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev_append l [x] = rev_append l [] ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (rev_append_app&#39; _ _ [] [x]).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span></pre></div>
<div class="section" id="answer-xingfe123">
<h1>Answer (xingfe123)</h1>
<p>use the generalize dependent tactic like this:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chkd"><span class="kn">Lemma</span> <span class="nf">rev_append_app</span>: <span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">l1</span> : list X) (<span class="nv">x</span> : X),
    rev_append l (l1 ++ [x]) = rev_append l l1 ++ [x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">l1</span> : list X) (<span class="nv">x</span> : X),
rev_append l (l1 ++ [x]) = rev_append l l1 ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chke"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l1</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev_append l (l1 ++ [x]) = rev_append l l1 ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chkf"><span class="nb">generalize dependent</span> l1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l1</span> : list X,
rev_append l (l1 ++ [x]) = rev_append l l1 ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk10"><span class="nb">induction</span> l <span class="kr">as</span> [| h t IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l1</span> : list X,
rev_append [] (l1 ++ [x]) = rev_append [] l1 ++ [x]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list X,
rev_append t (l1 ++ [x]) = rev_append t l1 ++ [x]</span></span></span><br></div><label class="goal-separator" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk11"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l1</span> : list X,
rev_append (h :: t) (l1 ++ [x]) =
rev_append (h :: t) l1 ++ [x]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk12">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l1</span> : list X,
rev_append [] (l1 ++ [x]) = rev_append [] l1 ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk13"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev_append [] (l1 ++ [x]) = rev_append [] l1 ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk14">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list X,
rev_append t (l1 ++ [x]) = rev_append t l1 ++ [x]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l1</span> : list X,
rev_append (h :: t) (l1 ++ [x]) =
rev_append (h :: t) l1 ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="logic-auxilliry-lemma-for-tr-rev-correct-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="logic-auxilliry-lemma-for-tr-rev-correct-v-chk15"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list X,
rev_append t (l1 ++ [x]) = rev_append t l1 ++ [x]</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev_append (h :: t) (l1 ++ [x]) =
rev_append (h :: t) l1 ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (IH (h :: l1)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
</div>
</div>
</div></body>
</html>
