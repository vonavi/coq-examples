<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>Using dependent induction tactic to keep information while doing induction</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction">
<h1 class="title">Using <tt class="docutils literal">dependent induction</tt> tactic to keep information while doing induction</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/34088140">https://stackoverflow.com/q/34088140</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>I have just run into the issue of the Coq <tt class="docutils literal">induction</tt> discarding
information about constructed terms while reading a proof from <a class="reference external" href="https://www.cis.upenn.edu/~bcpierce/sf/current/Equiv.html">here</a>.</p>
<p>The authors used something like:</p>
<pre class="code coq literal-block">
<span class="nb">remember</span> <span class="o">(</span><span class="n">WHILE</span> <span class="n">b</span> <span class="n">DO</span> <span class="n">c</span> <span class="n">END</span><span class="o">)</span> <span class="kr">as</span> <span class="n">cw</span> <span class="nb">eqn</span><span class="o">:</span><span class="n">Heqcw</span><span class="o">.</span>
</pre>
<p>to rewrite a hypothesis <tt class="docutils literal">H</tt> before the actual induction <tt class="docutils literal">induction
H</tt>. I really don't like the idea of having to introduce a trivial
equality as it looks like black magic.</p>
<p>Some search here in SO shows that actually the <tt class="docutils literal">remember</tt> trick is
necessary. One answer <a class="reference external" href="https://stackoverflow.com/a/4899467/683218">here</a>, however, points out
that the new <tt class="docutils literal">dependent induction</tt> can be used to avoid the
<tt class="docutils literal">remember</tt> trick. This is nice, but the <tt class="docutils literal">dependent induction</tt>
itself now seems a bit magical.</p>
<p>I have a hard time trying to understand how <tt class="docutils literal">dependent induction</tt>
works. The <a class="reference external" href="https://coq.inria.fr/refman/Reference-Manual010.html#hevea_tactic78">documentation</a>
gives an example where <tt class="docutils literal">dependent induction</tt> is required:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk0"><span class="kn">Lemma</span> <span class="nf">le_minus</span> : <span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; <span class="mi">1</span> -&gt; n = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; <span class="mi">1</span> -&gt; n = <span class="mi">0</span></div></blockquote></div></div></small></span></pre><p>I can verify how <tt class="docutils literal">induction</tt> fails and <tt class="docutils literal">dependent induction</tt> works
in this case. But I can't use the <tt class="docutils literal">remember</tt> trick to replicate the
<tt class="docutils literal">dependent induction</tt> result.</p>
<p>What I tried so far to mimic the <tt class="docutils literal">remember</tt> trick is:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Program.Equality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk1"><span class="kn">Lemma</span> <span class="nf">le_minus</span> : <span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; <span class="mi">1</span> -&gt; n = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; <span class="mi">1</span> -&gt; n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; <span class="mi">1</span> -&gt; n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk3"><span class="nb">intros</span> n H. <span class="c">(* dependent induction H works*)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk4"><span class="nb">remember</span> (n &lt; <span class="mi">1</span>) <span class="kr">as</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>HeqH0</var><span class="hyp-type"><b>: </b><span>H0 = (n &lt; <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>H0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk5"><span class="nb">induction</span> H.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Not an inductive product.</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>HeqH0</var><span class="hyp-type"><b>: </b><span>H0 = (n &lt; <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>H0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = <span class="mi">0</span></div></blockquote></div></div></small></span></pre><p>But this doesn't work. Anyone can explain how <tt class="docutils literal">dependent induction</tt>
works here in terms of the <tt class="docutils literal">remember</tt>-ing?</p>
<hr class="docutils" />
<p><strong>A:</strong> As indicated in the documentation, dependent induction is
defined in <tt class="docutils literal">Coq.Program.Equality</tt>. You can <a class="reference external" href="https://coq.inria.fr/distrib/current/stdlib/Coq.Program.Equality.html">dig through its guts</a>
to see how it works.</p>
</div>
<div class="section" id="answer">
<h1>Answer</h1>
<p>You can do</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Program.Equality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk6"><span class="kn">Lemma</span> <span class="nf">le_minus</span> : <span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; <span class="mi">1</span> -&gt; n = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; <span class="mi">1</span> -&gt; n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; <span class="mi">1</span> -&gt; n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk8"><span class="nb">intros</span> n H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk9"><span class="nb">remember</span> <span class="mi">1</span> <span class="kr">as</span> m <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqm</var><span class="hyp-type"><b>: </b><span>m = <span class="mi">1</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chka"><span class="nb">induction</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqm</var><span class="hyp-type"><b>: </b><span>S n = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chkb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqm</var><span class="hyp-type"><b>: </b><span>S m = <span class="mi">1</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>S n &lt;= m</span></span></span><br><span><var>IHle</var><span class="hyp-type"><b>: </b><span>m = <span class="mi">1</span> -&gt; n = <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chkb"><hr></label><div class="goal-conclusion">n = <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chkc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqm</var><span class="hyp-type"><b>: </b><span>S n = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chkd"><span class="nb">inversion</span> Heqm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqm</var><span class="hyp-type"><b>: </b><span>S n = <span class="mi">1</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chke">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqm</var><span class="hyp-type"><b>: </b><span>S m = <span class="mi">1</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>S n &lt;= m</span></span></span><br><span><var>IHle</var><span class="hyp-type"><b>: </b><span>m = <span class="mi">1</span> -&gt; n = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chkf"><span class="nb">inversion</span> Heqm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqm</var><span class="hyp-type"><b>: </b><span>S m = <span class="mi">1</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>S n &lt;= m</span></span></span><br><span><var>IHle</var><span class="hyp-type"><b>: </b><span>m = <span class="mi">1</span> -&gt; n = <span class="mi">0</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>m = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk10"><span class="nb">subst</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHle</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> = <span class="mi">1</span> -&gt; n = <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>S n &lt;= <span class="mi">0</span></span></span></span><br><span><var>Heqm</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>As stated <a class="reference external" href="https://stackoverflow.com/a/4522477/1633770">here</a>, the
problem is that Coq cannot keep track of the shape of terms that
appear in the type of the thing you are doing induction on. In other
words, doing induction over the &quot;less than&quot; relation instructs Coq to
try to prove something about a generic upper bound, as opposed to the
specific one you're considering (1).</p>
<p>Notice that it is always possible to prove such goals without
<tt class="docutils literal">remember</tt> or <tt class="docutils literal">dependent induction</tt>, by generalizing your result a
little bit:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk11"><span class="kn">Lemma</span> <span class="nf">le_minus_aux</span> :
  <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>, n &lt; m -&gt;
              <span class="kr">match</span> m <span class="kr">with</span>
              | <span class="mi">1</span> =&gt; n = <span class="mi">0</span>
              | _ =&gt; <span class="kt">True</span>
              <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat,
n &lt; m -&gt; <span class="kr">match</span> m <span class="kr">with</span>
         | <span class="mi">1</span> =&gt; n = <span class="mi">0</span>
         | _ =&gt; <span class="kt">True</span>
         <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk12"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat,
n &lt; m -&gt; <span class="kr">match</span> m <span class="kr">with</span>
         | <span class="mi">1</span> =&gt; n = <span class="mi">0</span>
         | _ =&gt; <span class="kt">True</span>
         <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk13"><span class="nb">intros</span> n m H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> m <span class="kr">with</span>
| <span class="mi">1</span> =&gt; n = <span class="mi">0</span>
| _ =&gt; <span class="kt">True</span>
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk14"><span class="nb">destruct</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> n <span class="kr">with</span>
| <span class="mi">0</span> =&gt; n = <span class="mi">0</span>
| S _ =&gt; <span class="kt">True</span>
<span class="kr">end</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk15" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>S n &lt;= m</span></span></span><br></div><label class="goal-separator" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk15"><hr></label><div class="goal-conclusion"><span class="kr">match</span> m <span class="kr">with</span>
| <span class="mi">0</span> =&gt; n = <span class="mi">0</span>
| S _ =&gt; <span class="kt">True</span>
<span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk16">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> n <span class="kr">with</span>
| <span class="mi">0</span> =&gt; n = <span class="mi">0</span>
| S _ =&gt; <span class="kt">True</span>
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> n; <span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk17">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>S n &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> m <span class="kr">with</span>
| <span class="mi">0</span> =&gt; n = <span class="mi">0</span>
| S _ =&gt; <span class="kt">True</span>
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> H; <span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk18"><span class="kn">Lemma</span> <span class="nf">le_minus</span> : <span class="kr">forall</span> <span class="nv">n</span>, n &lt; <span class="mi">1</span> -&gt; n = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; <span class="mi">1</span> -&gt; n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk19"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; <span class="mi">1</span> -&gt; n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="using-dependent-induction-tactic-to-keep-information-while-doing-induction-v-chk1a"><span class="nb">intros</span> n H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (le_minus_aux n <span class="mi">1</span> H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
</div>
</div>
</div></body>
</html>
