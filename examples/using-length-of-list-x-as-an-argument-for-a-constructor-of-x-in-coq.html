<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Using length of list X as an argument for a constructor of X in Coq</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="using-length-of-list-x-as-an-argument-for-a-constructor-of-x-in-coq">
<h1 class="title">Using length of list <span class="docutils literal">X</span> as an argument for a constructor of <span class="docutils literal">X</span> in Coq</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/26835278">https://stackoverflow.com/q/26835278</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>The title is not very informative, so let me explain.</p>
<p>I'm trying to formalize what it means to be a term in first-order
logic. Here is the textbook definition of terms of an arbitrary
language <span class="docutils literal">L</span>:</p>
<ol class="arabic simple">
<li><p>Each variable or constant is a term.</p></li>
<li><p>If <span class="docutils literal">n &gt;= 1</span>, <span class="docutils literal">f</span> is an <span class="docutils literal">n</span>-ary function of <span class="docutils literal">L</span>, and <span class="docutils literal">t1 ... tn</span> are terms of <span class="docutils literal">L</span>, then <span class="docutils literal">f t1 ... tn</span> is a term of
<span class="docutils literal">L</span>.</p></li>
</ol>
<p>I have already defined variables, constants, functions, and languages
as <span class="docutils literal">var</span>, <span class="docutils literal">const</span>, <span class="docutils literal">func</span>, and <span class="docutils literal">lang</span>. I also have functions
<span class="docutils literal">f_arity</span> and <span class="docutils literal">L_funcs</span> that returns the arity of a function and
the ensemble of all functions in a language, respectively. So giving
an inductive definition of terms should be pretty straightforward:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-length-of-list-x-as-an-argument-for-a-constructor-of-x-in-coq-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="using-length-of-list-x-as-an-argument-for-a-constructor-of-x-in-coq-v-chk0"><span class="kn">Inductive</span> <span class="nf">term</span> (<span class="nv">L</span> : lang) : <span class="kt">Type</span> :=
| t_v : var -&gt; term L
| t_c : const -&gt; term L
| t_f : <span class="kr">forall</span> (<span class="nv">f</span> : func) (<span class="nv">l</span> : list (term L)),
    length l = f_arity f -&gt;
    In f (L_funcs L) -&gt; term L.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Non strictly positive occurrence of <span class="s2">&quot;term&quot;</span> <span class="kr">in</span>
 <span class="s2">&quot;forall (f : func) (l : list (term L)),</span>
<span class="s2">  length l = f_arity f -&gt; In f (L_funcs L) -&gt; term L&quot;</span>.</blockquote></div></div></small></span></pre><p>But it doesn't work. Instead, I get this error message.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="using-length-of-list-x-as-an-argument-for-a-constructor-of-x-in-coq-v-chk1" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
Non strictly positive occurrence of <span class="s2">&quot;term&quot;</span> <span class="kr">in</span>
 <span class="s2">&quot;forall (f : func) (l : list (term L)),</span>
<span class="s2">  length l = f_arity f -&gt; In f (L_funcs L) -&gt; term L&quot;</span>.</blockquote></div></div></small></span></pre><p>I have a vague idea of what's going on here. The constructor <span class="docutils literal">t_f</span>
has an argument <span class="docutils literal">length l = f_arity</span>, which Coq doesn't like because
it has <span class="docutils literal">term L</span> on the left side of an arrow. But I think Coq is
being overly cautious here, because it lets me do pretty much the same
thing if I tweak the types a bit. I could, for instance, define a
custom list type <span class="docutils literal">listN</span> indexed by its size, so that <span class="docutils literal">list X n</span>
would be a list of <span class="docutils literal">X</span> with <span class="docutils literal">n</span> elements. Then I would have</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-length-of-list-x-as-an-argument-for-a-constructor-of-x-in-coq-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="using-length-of-list-x-as-an-argument-for-a-constructor-of-x-in-coq-v-chk2"><span class="kn">Inductive</span> <span class="nf">term</span> (<span class="nv">L</span> : lang) : <span class="kt">Type</span> :=
| t_v : var -&gt; term L
| t_c : const -&gt; term L
| t_f : <span class="kr">forall</span> (<span class="nv">f</span> : func) (<span class="nv">l</span> : listN (term L) (f_arity f)),
    In f (L_funcs L) -&gt; term L.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Non strictly positive occurrence of <span class="s2">&quot;term&quot;</span> <span class="kr">in</span>
 <span class="s2">&quot;forall f : func,</span>
<span class="s2">  listN (term L) (f_arity f) -&gt;</span>
<span class="s2">  In f (L_funcs L) -&gt; term L&quot;</span>.</blockquote></div></div></small></span></pre><p>But I don't want to go this way, because it is ad-hoc, and makes all
the useful list libraries unusable. So I'm looking for a way to
convince Coq that what I'm trying to do is perfectly safe, so it will
accept <span class="docutils literal">length l = f_arity f</span> as a constructor argument. Is there a
way to do this?</p>
</section>
<section id="answer">
<h2>Answer</h2>
<p>This is a nice problem indeed, I hadn't encountered it in this form
before.</p>
<p>Quite frankly, unfortunately, I don't see a way of getting Coq to
accept your definition as is. Here are some options for mitigating
this problem:</p>
<ol class="arabic">
<li><p>Use a separate inductive predicate for term well-formedness.
Manipulating terms will be much more convenient, because you won't
have to worry about the length constraints when writing your
functions. On the other hand, you will have to reason about
well-formedness separately when proving anything about it. Thus,
you would have something like</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">term</span> (<span class="nv">L</span> : lang) :=
| t_v : var -&gt; term L
| t_c : const -&gt; term L
| t_f (f : func) (ts : list (term L)) : term L.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">wf_term</span> (<span class="nv">L</span> : lang) : term L -&gt; <span class="kt">Prop</span> :=
| wf_v v : wf_term L (t_v L v)
| wf_c c : wf_term L (t_c L c)
| wf_f f ts :
  In f (L_funcs L) -&gt; Forall (wf_term L) ts -&gt;
  length ts = f_arity f -&gt; wf_term L (t_f L f ts).</span></span></pre></li>
<li><p>Use a dependently typed encoding for term. You can add e.g. a
<span class="docutils literal">nat</span> parameter to <span class="docutils literal">term</span> for expressing how many arguments are
&quot;missing&quot;, which would give you something like</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">term</span> <span class="nv">L</span> : nat -&gt; <span class="kt">Type</span> :=
| t_v : var -&gt; term L <span class="mi">0</span>
| t_c : const -&gt; term L <span class="mi">0</span>
| t_f f : In f (L_funcs L) -&gt; term L (f_arity f)
| t_a n (t : term L (S n)) (t : term L <span class="mi">0</span>) : term L n.</span></span></pre><p>This might not be what you want, since you don't get the list of
arguments to manipulate, but it might be helpful.</p>
</li>
<li><p>Use a &quot;bad&quot; encoding with a length-indexed list, and use auxiliary
types (&quot;views&quot;) and functions to make this &quot;bad&quot; definition more
convenient to use. You define <span class="docutils literal">term</span> like in your second
definition, but then define a new <span class="docutils literal">term'</span> on top of it, like</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">term&#39;</span> <span class="nv">L</span> : <span class="kt">Type</span> :=
| t_v&#39; : var -&gt; term&#39; L
| t_c&#39; : const -&gt; term&#39; L
| t_f&#39; f (ts : list (term L)) :
  In f (L_funcs L) -&gt; length ts = f_arity f -&gt; term&#39; L.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-length-of-list-x-as-an-argument-for-a-constructor-of-x-in-coq-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="using-length-of-list-x-as-an-argument-for-a-constructor-of-x-in-coq-v-chk3"><span class="kn">Definition</span> <span class="nf">term_view</span> <span class="nv">L</span> (<span class="nv">t</span> : term L) : term&#39; L. <span class="c">(* ... *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L</var><span class="hyp-type"><b>: </b><span>lang</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term L</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">term&#39; L</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Wrapper around the original constructor *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="using-length-of-list-x-as-an-argument-for-a-constructor-of-x-in-coq-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="using-length-of-list-x-as-an-argument-for-a-constructor-of-x-in-coq-v-chk4"><span class="kn">Definition</span> <span class="nf">t_f&#39;&#39;</span> <span class="nv">L</span> <span class="nv">f</span> <span class="nv">ts</span> :
  In f (L_funcs L) -&gt; @length lang ts = f_arity f -&gt; term L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L</var><span class="hyp-type"><b>: </b><span>lang</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>func</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>list lang</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In f (L_funcs L) -&gt; length ts = f_arity f -&gt; term L</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* ... *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span></span></pre></li>
</ol>
<p>You can even define custom induction/recursion principles that work
directly with <span class="docutils literal">t_f''</span> instead of <span class="docutils literal">t_f</span>, effectively hiding the
annoying details of your original definition.</p>
</section>
</div>
</main>
</div></body>
</html>
