<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>A simple case of universe inconsistency</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="a-simple-case-of-universe-inconsistency">
<h1 class="title">A simple case of universe inconsistency</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/51029234">https://stackoverflow.com/q/51029234</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>I can define the following inductive type:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">T</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span> :=
| c1 : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>), A -&gt; T A
| c2 : T unit.</span></span></pre><p>But then the command <span class="docutils literal">Check (c1 (T nat))</span> fails with the message:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="a-simple-case-of-universe-inconsistency-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="a-simple-case-of-universe-inconsistency-v-chk0"><span class="kn">Check</span> (c1 (T nat)).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The term <span class="s2">&quot;T nat&quot;</span> has type <span class="s2">&quot;Type@{max(Set,T.u1+1)}&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type <span class="s2">&quot;Type@{T.u1}&quot;</span>
(universe inconsistency: Cannot enforce T.u1 &lt;
T.u1 because T.u1 = T.u1).</blockquote></div></div></small></span></pre><p>How can I tweak the above inductive definition so that <span class="docutils literal">c1 (T nat)</span>
does not cause a universe inconsistency, and without setting universe
polymorphism on?</p>
<p>The following works, but I would prefer a solution without adding
equality:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">T</span> (<span class="nv">A</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
| c1 : A -&gt; T A
| c2&#39; : A = unit -&gt; T A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c2</span> : T unit := c2&#39; unit eq_refl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="a-simple-case-of-universe-inconsistency-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="a-simple-case-of-universe-inconsistency-v-chk1"><span class="kn">Check</span> (c1 (T nat)).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">c1 (T nat)
     : T nat -&gt; T (T nat)</blockquote></div></div></small></span></pre></section>
<section id="answer">
<h2>Answer</h2>
<p>Let me first answer the question of why we get the universe
inconsistency in the first place.</p>
<p>Universe inconsistencies are the errors that Coq reports to avoid
proofs of <span class="docutils literal">False</span> via Russell's paradox, which results from
considering the set of all sets which do not contain themselves.</p>
<p>There's a variant which is more convenient to formalize in type theory
called Hurken's Paradox; see <a class="reference external" href="https://coq.inria.fr/library/Coq.Logic.Hurkens.html">Coq.Logic.Hurkens</a> for more
details. There is a specialization of Hurken's paradox which proves
that no type can retract to a smaller type. That is, given</p>
<pre class="code coq literal-block"><code><span class="n">U</span> <span class="o">:=</span> <span class="kt">Type</span><span class="o">&#64;{</span><span class="n">u</span><span class="o">}</span>
<span class="n">A</span> <span class="o">:</span> <span class="n">U</span>
<span class="n">down</span> <span class="o">:</span> <span class="n">U</span> <span class="o">-&gt;</span> <span class="n">A</span>
<span class="n">up</span> <span class="o">:</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">U</span>
<span class="n">up_down</span> <span class="o">:</span> <span class="kr">forall</span> <span class="o">(</span><span class="nv">X</span><span class="o">:</span><span class="n">U</span><span class="o">),</span> <span class="n">up</span> <span class="o">(</span><span class="n">down</span> <span class="n">X</span><span class="o">)</span> <span class="o">=</span> <span class="n">X</span></code></pre>
<p>we can prove <span class="docutils literal">False</span>.</p>
<hr class="docutils" />
<p>This is almost exactly the setup of your <span class="docutils literal">Inductive</span> type.
Annotating your type with universes, you start with</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">T</span> : <span class="kt">Type</span>@{i} -&gt; <span class="kt">Type</span>@{j} :=
| c1 : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>@{i}), A -&gt; T A
| c2 : T unit.</span></span></pre><p>Note that we can invert this inductive; we may write</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c1&#39;</span> (<span class="nv">A</span> : <span class="kt">Type</span>@{i}) (<span class="nv">v</span> : T A) : A :=
  <span class="kr">match</span> v <span class="kr">with</span>
  | c1 A x =&gt; x
  | c2 =&gt; tt
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="a-simple-case-of-universe-inconsistency-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="a-simple-case-of-universe-inconsistency-v-chk2"><span class="kn">Lemma</span> <span class="nf">c1&#39;_c1</span> (<span class="nv">A</span> : <span class="kt">Type</span>@{i}) : <span class="kr">forall</span> <span class="nv">v</span>, c1&#39; A (c1 A v) = v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">v</span> : A, c1&#39; A (c1 A v) = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="a-simple-case-of-universe-inconsistency-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="a-simple-case-of-universe-inconsistency-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">v</span> : A, c1&#39; A (c1 A v) = v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Suppose, for a moment, that <span class="docutils literal">c1 (T nat)</span> typechecked. Since <span class="docutils literal">T nat : <span class="pre">Type&#64;{j}</span></span>, this would require <span class="docutils literal">j &lt;= i</span>. If it gave us that <span class="docutils literal">j &lt; i</span>, then we would be set. We could write <span class="docutils literal">c1 <span class="pre">Type&#64;{j}</span></span>. And this is
exactly the setup for the variant of Hurken's that I mentioned above!
We could define</p>
<pre class="code coq literal-block"><code><span class="n">u</span> <span class="o">=</span> <span class="n">j</span>
<span class="n">U</span> <span class="o">:=</span> <span class="kt">Type</span><span class="o">&#64;{</span><span class="n">j</span><span class="o">}</span>
<span class="n">A</span> <span class="o">:=</span> <span class="n">T</span> <span class="kt">Type</span><span class="o">&#64;{</span><span class="n">j</span><span class="o">}</span>
<span class="n">down</span> <span class="o">:</span> <span class="n">U</span> <span class="o">-&gt;</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">c1</span> <span class="kt">Type</span><span class="o">&#64;{</span><span class="n">j</span><span class="o">}</span>
<span class="n">up</span> <span class="o">:</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">U</span> <span class="o">:=</span> <span class="n">c1'</span> <span class="kt">Type</span><span class="o">&#64;{</span><span class="n">j</span><span class="o">}</span>
<span class="n">up_down</span> <span class="o">:=</span> <span class="n">c1'_c1</span> <span class="kt">Type</span><span class="o">&#64;{</span><span class="n">j</span><span class="o">}</span></code></pre>
<p>and hence prove <span class="docutils literal">False</span>.</p>
<p>Coq needs to implement a rule for avoiding this paradox. As described
<a class="reference external" href="https://github.com/coq/coq/issues/7929#issuecomment-400376700">here</a>,
the rule is that for each (non-parameter) argument to a constructor of
an inductive, if the type of the argument has a sort in universe
<span class="docutils literal">u</span>, then the universe of the inductive is constrained to be <span class="docutils literal">&gt;= u</span>. In this case, this is stricter than Coq needs to be. As mentioned
by SkySkimmer <a class="reference external" href="https://github.com/coq/coq/issues/7929#issuecomment-400384621">here</a>,
Coq could recognize arguments which appear directly in locations which
are indices of the inductive, and disregard those in the same way that
it disregards parameters.</p>
<hr class="docutils" />
<p>So, to finally answer your question, I believe the following are your
only options:</p>
<ol class="arabic simple">
<li><p>You can <span class="docutils literal">Set Universe Polymorphism</span> so that in <span class="docutils literal">T (T nat)</span>,
your two <span class="docutils literal">T</span>s take different universe arguments. (Equivalently,
you can write <span class="docutils literal">Polymorphic Inductive</span>.)</p></li>
<li><p>You can take advantage of how Coq treats parameters of inductive
types specially, which mandates using equality in your case. (The
requirement of using equality is a general property of going from
indexed inductive types to parameterized inductives types---from
moving arguments from after the <span class="docutils literal">:</span> to before it.)</p></li>
<li><p>You can pass Coq the flag <span class="docutils literal"><span class="pre">-type-in-type</span></span> to entirely disable
universe checking.</p></li>
<li><p>You can <a class="reference external" href="https://github.com/coq/coq/issues/7929">fix bug #7929</a>,
which I reported as part of digging into this question, to make Coq
handle arguments of constructors which appear in index-position in
the inductive in the same way it handles parameters of inductive
types.</p></li>
<li><p>(You can find another edge case of the system, and manage to trick
Coq into ignoring the universes you want to slip past it, and
probably find a proof of <span class="docutils literal">False</span> in the process. (Possibly
involving module subtyping, see, e.g., <a class="reference external" href="https://github.com/coq/coq/issues/7695">this recent bug in modules
with universes</a>.))</p></li>
</ol>
</section>
</div>
</main>
</div></body>
</html>
