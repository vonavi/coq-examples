<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>What is difference between destruct and case_eq tactics in Coq?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="what-is-difference-between-destruct-and-case-eq-tactics-in-coq">
<h1 class="title">What is difference between <span class="docutils literal">destruct</span> and <span class="docutils literal">case_eq</span> tactics in Coq?</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/46440349">https://stackoverflow.com/q/46440349</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>I understood <span class="docutils literal">destruct</span> as it breaks an inductive definition into
its constructors. I recently saw <span class="docutils literal">case_eq</span> and I couldn't understand
what it does differently?</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="what-is-difference-between-destruct-and-case-eq-tactics-in-coq-v-chk0" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M.t nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> M.find (elt:=nat) n m <span class="kr">with</span>
| Some _ =&gt; true
| None =&gt; false
<span class="kr">end</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cc n (M.add k k m) = true</div></blockquote></div></div></small></span></pre><p>In the above context, if I do destruct <span class="docutils literal">M.find n m</span> it breaks <span class="docutils literal">H</span>
into true and false whereas <span class="docutils literal">case_eq (M.find n m)</span> leaves <span class="docutils literal">H</span>
intact and adds separate proposition <span class="docutils literal">M.find <span class="pre">(elt:=nat)</span> n m = Some v</span>, which I can rewrite to get same effect as destruct.</p>
<p>Can someone please explain me the difference between the two tactics
and when which one should be used?</p>
<hr class="docutils" />
<p><strong>A:</strong> Check this link
<a class="reference external" href="https://stackoverflow.com/questions/6823301/how-to-do-cases-with-an-inductive-type-in-coq/6828451#6828451">https://stackoverflow.com/questions/6823301/how-to-do-cases-with-an-inductive-type-in-coq/6828451#6828451</a></p>
</section>
<section id="answer">
<h2>Answer</h2>
<p>The first basic tactic in the family of <span class="docutils literal">destruct</span> and <span class="docutils literal">case_eq</span>
is called <span class="docutils literal">case</span>. This tactic modifies only the conclusion. When you
type <span class="docutils literal">case A</span> and <span class="docutils literal">A</span> has a type <span class="docutils literal">T</span> which is inductive, the
system replaces <span class="docutils literal">A</span> in the goal's conclusion by instances of all the
constructors of type <span class="docutils literal">T</span>, adding universal quantifications for the
arguments of these constructors, if needed. This creates as many goals
as there are constructors in type <span class="docutils literal">T</span>. The formula <span class="docutils literal">A</span> disappears
from the goal and if there is any information about <span class="docutils literal">A</span> in an
hypothesis, the link between this information and all the new
constructors that replace it in the conclusion gets lost. In spite of
this, <span class="docutils literal">case</span> is an important primitive tactic.</p>
<p>Loosing the link between information in the hypotheses and instances
of <span class="docutils literal">A</span> in the conclusion is a big problem in practice, so developers
came up with two solutions: <span class="docutils literal">case_eq</span> and <span class="docutils literal">destruct</span>.</p>
<p>Personally, when writing the Coq'Art book, I proposed that we write a
simple tactic on top of <span class="docutils literal">case</span> that keeps a link between <span class="docutils literal">A</span> and
the various constructor instances in the form of an equality. This is
the tactic now called <span class="docutils literal">case_eq</span>. It does the same thing as <span class="docutils literal">case</span>
but adds an extra implication in the goal, where the premise of the
implication is an equality of the form <span class="docutils literal">A = ...</span> and where <span class="docutils literal">...</span>
is an instance of each constructor.</p>
<p>At about the same time, the tactic <span class="docutils literal">destruct</span> was proposed. Instead
of limiting the effect of replacement in the goal's conclusion,
<span class="docutils literal">destruct</span> replaces all instances of <span class="docutils literal">A</span> appearing in the
hypotheses with instances of constructors of type <span class="docutils literal">T</span>. In a sense,
this is cleaner because it avoids relying on the extra concept of
equality, but it is still incomplete because the expression <span class="docutils literal">A</span> may
be a compound expression <span class="docutils literal">f B</span>, and if <span class="docutils literal">B</span> appears in the
hypothesis but not <span class="docutils literal">f B</span> the link between <span class="docutils literal">A</span> and <span class="docutils literal">B</span> will still
be lost.</p>
<section id="illustration">
<h3>Illustration</h3>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">my_pred</span> (<span class="nv">n</span> : nat) := <span class="kr">match</span> n <span class="kr">with</span> <span class="mi">0</span> =&gt; <span class="mi">0</span> | S p =&gt; p <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="what-is-difference-between-destruct-and-case-eq-tactics-in-coq-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="what-is-difference-between-destruct-and-case-eq-tactics-in-coq-v-chk1"><span class="kn">Lemma</span> <span class="nf">example</span> <span class="nv">n</span> : n &lt;= <span class="mi">1</span> -&gt; my_pred n &lt;= <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= <span class="mi">1</span> -&gt; my_pred n &lt;= <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="what-is-difference-between-destruct-and-case-eq-tactics-in-coq-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="what-is-difference-between-destruct-and-case-eq-tactics-in-coq-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= <span class="mi">1</span> -&gt; my_pred n &lt;= <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="what-is-difference-between-destruct-and-case-eq-tactics-in-coq-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="what-is-difference-between-destruct-and-case-eq-tactics-in-coq-v-chk3"><span class="nb">case_eq</span> (my_pred n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">my_pred n = <span class="mi">0</span> -&gt; n &lt;= <span class="mi">1</span> -&gt; <span class="mi">0</span> &lt;= <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="what-is-difference-between-destruct-and-case-eq-tactics-in-coq-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="what-is-difference-between-destruct-and-case-eq-tactics-in-coq-v-chk4"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n0</span> : nat,
my_pred n = S n0 -&gt; n &lt;= <span class="mi">1</span> -&gt; S n0 &lt;= <span class="mi">0</span></div></blockquote></div></div></div></small></span></pre><p>Gives the two goals</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="what-is-difference-between-destruct-and-case-eq-tactics-in-coq-v-chk5" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">my_pred n = <span class="mi">0</span> -&gt; n &lt;= <span class="mi">1</span> -&gt; <span class="mi">0</span> &lt;= <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="what-is-difference-between-destruct-and-case-eq-tactics-in-coq-v-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="what-is-difference-between-destruct-and-case-eq-tactics-in-coq-v-chk6"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n0</span> : nat,
my_pred n = S n0 -&gt; n &lt;= <span class="mi">1</span> -&gt; S n0 &lt;= <span class="mi">0</span></div></blockquote></div></div></div></small></span></pre><p>the extra equality is very useful here.</p>
<p>In <a class="reference external" href="https://stackoverflow.com/q/46434503/1809211">this question</a> I
suggested that the developer use <span class="docutils literal">case_eq (a == b)</span> when <span class="docutils literal">(a == b)</span> has type <span class="docutils literal">bool</span> because this type is inductive and not very
informative (constructors have no argument). But when <span class="docutils literal">(a == b)</span> has
type <span class="docutils literal">{a = b} + {a &lt;&gt; b}</span> (which is the case for the <span class="docutils literal">string_dec</span>
function) the constructors have arguments that are proofs of
interesting properties and the extra universal quantification for the
arguments of the constructors are enough to give the relevant
information, in this case <span class="docutils literal">a = b</span> in a first goal and <span class="docutils literal">a &lt;&gt; b</span> in
a second goal.</p>
<hr class="docutils" />
<p><strong>A:</strong> Note that <span class="docutils literal">destruct</span> has a variant <span class="docutils literal">destruct H eqn:H0</span>
which also remembers an equality.</p>
<p><strong>A:</strong> Also note that there's a simple wrapper <span class="docutils literal">destruct_with_eqn H</span>, which automatically generates a fresh name for the equality.</p>
</section>
</section>
</div>
</main>
</div></body>
</html>
