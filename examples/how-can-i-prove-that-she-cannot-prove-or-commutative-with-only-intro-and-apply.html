<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>How can I prove that she cannot prove Or_commutative with only intro and apply?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply">
<h1 class="title">How can I prove that she cannot prove <tt class="docutils literal">Or_commutative</tt> with only intro and apply?</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/51871265">https://stackoverflow.com/q/51871265</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>This question is related to a strategic game (bargaining, protocol,
crypto, ...) setting I investigate during holidays where players are
Coq users.</p>
<p>Some of them have limited reasoning capabilities such as for example
being only able to intro and apply an hypothesis or a lemma they were
given.</p>
<p>Some others may have access to <tt class="docutils literal">tauto</tt>.</p>
<p>In contrast, some rational players have unlimited reasoning
capabilities and know other players' type. Rational players can
therefore reflect on what other players can prove or not and build
their decision on it for their next move in the game.</p>
<p>Non-rational players have never access to CIC terms. I therefore
restrict their Ltac grammar to a consistent but smaller fragment. I
also restrict their list of atomic tactics. For example I would not
allow a variant of apply with patterns or other which opens the door
to CIC terms.</p>
<p>In the case of this question, it is simply a finite sequence of
vanilla intro and apply tactics separated by a dot.</p>
<p>To summarize, a player's type is defined by an Ltac grammar subset, a
list of atomic tactics and a bag of lemmas given at the start of the
game.</p>
<p>Here is the most verbose (smallest steps) proof of a tautology:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk0"><span class="kn">Lemma</span> <span class="nf">Or_commutative</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P \/ Q -&gt; Q \/ P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P \/ Q -&gt; Q \/ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P \/ Q -&gt; Q \/ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk2"><span class="nb">intro</span> P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P \/ Q -&gt; Q \/ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk3"><span class="nb">intro</span> Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P \/ Q -&gt; Q \/ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk4"><span class="nb">intro</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P \/ Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q \/ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk5"><span class="nb">elim</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P \/ Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P -&gt; Q \/ P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P \/ Q</span></span></span><br></div><label class="goal-separator" for="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk6"><hr></label><div class="goal-conclusion">Q -&gt; Q \/ P</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk7"><span class="nb">intro</span> HP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P \/ Q</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q \/ P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P \/ Q</span></span></span><br></div><label class="goal-separator" for="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk8"><hr></label><div class="goal-conclusion">Q -&gt; Q \/ P</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chk9"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P \/ Q</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chka" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P \/ Q</span></span></span><br></div><label class="goal-separator" for="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chka"><hr></label><div class="goal-conclusion">Q -&gt; Q \/ P</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chkb"><span class="nb">apply</span> HP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P \/ Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q -&gt; Q \/ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chkc"><span class="nb">intro</span> HQ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P \/ Q</span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q \/ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chkd"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P \/ Q</span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> HQ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>It is clear that we need <tt class="docutils literal">elim</tt>, <tt class="docutils literal">right</tt> and <tt class="docutils literal">left</tt> tactics.
<tt class="docutils literal">intro</tt> and <tt class="docutils literal">apply</tt> are not sufficient.</p>
<p>Question: how can I prove that she cannot prove <tt class="docutils literal">Or_commutative</tt>
with only <tt class="docutils literal">intro</tt> and <tt class="docutils literal">apply</tt>?</p>
<pre class="code coq literal-block">
<span class="kn">Goal</span> <span class="n">cannot_prove_or_commutative_with_IAs</span> <span class="o">:</span> <span class="o">????</span>
<span class="kn">Proof</span><span class="o">.</span>
<span class="c">(* Here I want to show that no sequence of vanilla intro and apply
   tactics can solve the goal *)</span>

<span class="c">(* I may define a structure of proof that is a sequence of intro and
   apply and show that after step 3, it will fail or will not change
   the judgment. How would I do that? *)</span>

<span class="c">(* Or should I go to the definitions of intro an apply and show that
   they cannot handle OR terms? *)</span>

<span class="c">(* Or should I investigate plugins to reflect on tactics? I heard of
   Mtac2 recently *)</span>
<span class="kn">Qed</span><span class="o">.</span>
</pre>
</div>
<div class="section" id="answer">
<h1>Answer</h1>
<p>To state this theorem, you need to define a Coq data type that
captures the syntax of propositions you want to work with and
associated inference rules. This can encompass as much of Coq as you
are willing to formalize. To state your commutativity result, all we
need is a simple propositional logic with disjunction and implication.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">prop</span> : <span class="kt">Type</span> :=
| Atomic  : nat -&gt; prop <span class="c">(* Basic propositions *)</span>
| Or      : prop -&gt; prop -&gt; prop
| Implies : prop -&gt; prop -&gt; prop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">commutativity</span> :=
  Implies (Or (Atomic <span class="mi">0</span>) (Atomic <span class="mi">1</span>)) (Or (Atomic <span class="mi">1</span>) (Atomic <span class="mi">0</span>)).</span></span></pre><p>We can give a semantics to this logic, tying it back to the notion of
truth that comes with Coq; <tt class="docutils literal">assn</tt> is used to interpret atomic
propositions:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">sem</span> (<span class="nv">assn</span> : nat -&gt; <span class="kt">Prop</span>) (<span class="nv">P</span> : prop) :=
  <span class="kr">match</span> P <span class="kr">with</span>
  | Atomic x =&gt; assn x
  | Or P Q =&gt; sem assn P \/ sem assn Q
  | Implies P Q =&gt; sem assn P -&gt; sem assn Q
  <span class="kr">end</span>.</span></span></pre><p>Instead of working with tactics, it is easier and more commonplace to
formalize proofs using an entailment relation, which states when a
theorem can proved from a list of assumptions. The following
definition gives all the useful rules for the above fragment:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Lists.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">entails</span> : list prop -&gt; prop -&gt; <span class="kt">Type</span> :=
| Ax : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">G</span>, In P G -&gt; entails G P
| OrIL : <span class="kr">forall</span> <span class="nv">G</span> <span class="nv">P</span> <span class="nv">Q</span>, entails G P -&gt; entails G (Or P Q)
| OrIR : <span class="kr">forall</span> <span class="nv">G</span> <span class="nv">P</span> <span class="nv">Q</span>, entails G Q -&gt; entails G (Or P Q)
| OrE  : <span class="kr">forall</span> <span class="nv">G</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span>,
    entails (P :: G) R -&gt; entails (Q :: G) R -&gt;
    entails G (Or P Q) -&gt; entails G R
| ImpliesI : <span class="kr">forall</span> <span class="nv">G</span> <span class="nv">P</span> <span class="nv">Q</span>,
    entails (P :: G) Q -&gt; entails G (Implies P Q)
| ImpliesE : <span class="kr">forall</span> <span class="nv">G</span> <span class="nv">P</span> <span class="nv">Q</span>,
    entails G (Implies P Q) -&gt; entails G P -&gt; entails G Q.</span></span></pre><p>It should be possible to prove a soundness theorem, saying that the
proofs built from these inference rules yield valid theorems:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chke"><span class="kn">Theorem</span> <span class="nf">soundness</span> <span class="nv">assn</span> <span class="nv">G</span> <span class="nv">P</span> :
  entails G P -&gt; Forall (sem assn) G -&gt; sem assn P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>assn</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>list prop</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>prop</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">entails G P -&gt; Forall (sem assn) G -&gt; sem assn P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>Only allowing <tt class="docutils literal">intros</tt> and <tt class="docutils literal">apply</tt> would amount to ruling out uses
of <tt class="docutils literal">OrE</tt>, which we can enforce with a boolean predicate:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">no_destruct</span> {<span class="nv">G</span> <span class="nv">P</span>} (<span class="nv">pf</span> : entails G P) : bool :=
  <span class="kr">match</span> pf <span class="kr">with</span>
  | Ax _ _ _ =&gt; true
  | OrIL _ _ _ pf =&gt; no_destruct pf
  | OrIR _ _ _ pf =&gt; no_destruct pf
  | OrE _ _ _ _ _ _ _ =&gt; false
  | ImpliesI _ _ _ pf =&gt; no_destruct pf
  | ImpliesE _ _ _ pf1 pf2 =&gt; no_destruct pf1 &amp;&amp; no_destruct pf2
  <span class="kr">end</span>.</span></span></pre><p>You can finally state your metatheorem: any proof of commutativity
must use the <tt class="docutils literal">OrE</tt> rule:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply-v-chkf"><span class="kn">Theorem</span> <span class="nf">no_commutativity</span> (<span class="nv">pf</span> : entails nil commutativity) :
  no_destruct pf = false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>pf</var><span class="hyp-type"><b>: </b><span>entails nil commutativity</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_destruct pf = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>On top of my head, I do not know exactly how this proof would proceed.
One possibility could be to give your restricted logic a non-standard
interpretation which validates all inference rules, except for
<tt class="docutils literal">OrE</tt>, and where <tt class="docutils literal">Or</tt> is not commutative.</p>
</div>
</div>
</div>
</div></body>
</html>
