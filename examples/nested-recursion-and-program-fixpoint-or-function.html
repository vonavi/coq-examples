<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Nested recursion and Program Fixpoint or Function</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="nested-recursion-and-program-fixpoint-or-function">
<h1 class="title">Nested recursion and <span class="docutils literal">Program Fixpoint</span> or <span class="docutils literal">Function</span></h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/46838928">https://stackoverflow.com/q/46838928</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>I'd like to define the following function using <span class="docutils literal">Program Fixpoint</span>
or <span class="docutils literal">Function</span> in Coq:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Lists.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Program.Wf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Recdef.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Tree</span> := Node : nat -&gt; list Tree -&gt; Tree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">height</span> (<span class="nv">t</span> : Tree) : nat :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | Node x ts =&gt; S (fold_right Nat.max <span class="mi">0</span> (map height ts))
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Fixpoint</span> <span class="nf">mapTree</span> (<span class="nv">f</span> : nat -&gt; nat) (<span class="nv">t</span> : Tree)
        {<span class="nv">measure</span> (height t)} : Tree :=
  <span class="kr">match</span> t <span class="kr">with</span>
    Node x ts =&gt; Node (f x) (map (<span class="kr">fun</span> <span class="nv">t</span> =&gt; mapTree f t) ts)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk0"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>mapTree</var><span class="hyp-type"><b>: </b><span>(nat -&gt; nat) -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : Tree,
height t &lt; height (Node x ts) -&gt; Tree</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t &lt; height (Node x ts)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span></span></pre><p>Unfortunately, at this point I have a proof obligation <span class="docutils literal">height t &lt; height (Node x ts)</span> without knowing that <span class="docutils literal">t</span> is a member of <span class="docutils literal">ts</span>.</p>
<p>Similarly with <span class="docutils literal">Function</span> instead of <span class="docutils literal">Program Fixpoint</span>, only that
<span class="docutils literal">Function</span> detects the problem and aborts the definition:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk1" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">the term <span class="kr">fun</span> <span class="nv">t</span> : Tree =&gt; mapTree0 f t can not contain a recursive call to mapTree0</blockquote></div></div></small></span></pre><p>I would expect to get a proof obligation of <span class="docutils literal">In t ts <span class="pre">-&gt;</span> height t &lt; height (Node x ts)</span>.</p>
<p>Is there a way of getting that that does not involve restructuring the
function definition? (I know work-arounds that require inlining the
definition of <span class="docutils literal">map</span> here, for example – I'd like to avoid these.)</p>
<section id="isabelle">
<h3>Isabelle</h3>
<p>To justify that expectation, let me show what happens when I do the
same in Isabelle, using the <span class="docutils literal">function</span> command, which is (AFAIK)
related to Coq's <span class="docutils literal">Function</span> command:</p>
<pre class="code isabelle literal-block"><code><span class="k">theory</span><span class="w"> </span><span class="n">Tree</span><span class="w"> </span><span class="kp">imports</span><span class="w"> </span><span class="n">Main</span><span class="w"> </span><span class="k">begin</span><span class="w">

</span><span class="k">datatype</span><span class="w"> </span><span class="n">Tree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><s>&quot;Tree list&quot;</s><span class="w">

</span><span class="k">fun</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="kp">where</span><span class="w">
  </span><s>&quot;height (Node _ ts) = Suc (foldr max (map height ts) 0)&quot;</s><span class="w">

</span><span class="kn">function</span><span class="w"> </span><span class="n">mapTree</span><span class="w"> </span><span class="kp">where</span><span class="w">
  </span><s>&quot;mapTree f (Node x ts) = Node (f x) (map (λ t. mapTree f t) ts)&quot;</s><span class="w">
</span><span class="k">by</span><span class="w"> </span><span class="n">pat_completeness</span><span class="w"> </span><span class="n">auto</span><span class="w">

</span><span class="kn">termination</span><span class="w">
</span><span class="k">proof</span><span class="w"> </span><span class="o">(</span><span class="n">relation</span><span class="w"> </span><s>&quot;measure (λ(f, t). height t)&quot;</s><span class="o">)</span><span class="w">
  </span><span class="k">show</span><span class="w"> </span><s>&quot;wf (measure (λ(f, t). height t))&quot;</s><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">auto</span><span class="w">
</span><span class="k">next</span><span class="w">
  </span><span class="k">fix</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><s>&quot;nat ⇒ nat&quot;</s><span class="w"> </span><span class="kp">and</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="kp">and</span><span class="w"> </span><span class="n">ts</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><s>&quot;Tree list&quot;</s><span class="w"> </span><span class="kp">and</span><span class="w"> </span><span class="n">t</span><span class="w">
  </span><span class="k">assume</span><span class="w"> </span><s>&quot;t ∈ set ts&quot;</s><span class="w">
  </span><span class="k">thus</span><span class="w"> </span><s>&quot;((f, t), (f, Node x ts))  ∈ measure (λ(f, t). height t)&quot;</s><span class="w">
    </span><span class="k">by</span><span class="w"> </span><span class="o">(</span><span class="n">induction</span><span class="w"> </span><span class="n">ts</span><span class="o">)</span><span class="w"> </span><span class="n">auto</span><span class="w">
</span><span class="k">qed</span></code></pre>
<p>In the termination proof, I get the assumption <span class="docutils literal">t ∈ set ts</span>.</p>
<p>Note that Isabelle does not require a manual termination proof here,
and the following definition works just fine:</p>
<pre class="code isabelle literal-block"><code><span class="k">fun</span><span class="w"> </span><span class="n">mapTree</span><span class="w"> </span><span class="kp">where</span><span class="w">
  </span><s>&quot;mapTree f (Node x ts) = Node (f x) (map (λ t. mapTree f t) ts)&quot;</s></code></pre>
<p>This works because the <span class="docutils literal">map</span> function has a &quot;congruence lemma&quot; of
the form</p>
<pre class="code isabelle literal-block"><code><s>&quot;xs = ys ⟹ (⋀x. x ∈ set ys ⟹ f x = g x) ⟹ map f xs = map g ys&quot;</s></code></pre>
<p>that the <span class="docutils literal">function</span> command uses to find out that the termination
proof only needs to consider <span class="docutils literal">t ∈ set ts</span>.</p>
<p>If such a lemma is not available, e.g. because I define</p>
<pre class="code isabelle literal-block"><code><span class="k">definition</span><span class="w"> </span><s>&quot;map' = map&quot;</s></code></pre>
<p>and use that in <span class="docutils literal">mapTree</span>, I get the same unprovable proof
obligation as in Coq. I can make it work again by declaring a
congruence lemma for <span class="docutils literal">map'</span>, e.g. using</p>
<pre class="code isabelle literal-block"><code><span class="k">declare</span><span class="w"> </span><span class="n">map_cong</span><span class="o">[</span><span class="n">folded</span><span class="w"> </span><span class="n">map'_def</span><span class="o">,</span><span class="n">fundef_cong</span><span class="o">]</span></code></pre>
</section>
</section>
<section id="answer-arthur-azevedo-de-amorim">
<h2>Answer (Arthur Azevedo De Amorim)</h2>
<p>In this case, you actually do not need well-founded recursion in its
full generality:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Lists.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">tree</span> := Node : nat -&gt; list tree -&gt; tree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">map_tree</span> (<span class="nv">f</span> : nat -&gt; nat) (<span class="nv">t</span> : tree) : tree :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | Node x ts =&gt; Node (f x) (map (<span class="kr">fun</span> <span class="nv">t</span> =&gt; map_tree f t) ts)
  <span class="kr">end</span>.</span></span></pre><p>Coq is able to figure out by itself that recursive calls to
<span class="docutils literal">map_tree</span> are performed on strict subterms. However, proving
anything about this function is difficult, as the induction principle
generated for <span class="docutils literal">tree</span> is not useful:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk2" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">tree_ind
     : <span class="kr">forall</span> <span class="nv">P</span> : tree -&gt; <span class="kt">Prop</span>,
       (<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list tree), P (Node n l)) -&gt;
       <span class="kr">forall</span> <span class="nv">t</span> : tree, P t</blockquote></div></div></small></span></pre><p>This is essentially the same problem you described earlier. Luckily,
we can fix the issue by proving our own induction principle with a
proof term.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Lists.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unset Elimination Schemes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">tree</span> := Node : nat -&gt; list tree -&gt; tree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Elimination Schemes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">tree_ind</span>
         (<span class="nv">P</span> : tree -&gt; <span class="kt">Prop</span>)
         (<span class="nv">IH</span> : <span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">ts</span> : list tree),
             fold_right (<span class="kr">fun</span> <span class="nv">t</span> =&gt; and (P t)) <span class="kt">True</span> ts -&gt;
             P (Node n ts))
         (<span class="nv">t</span> : tree) : P t :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | Node n ts =&gt;
      <span class="kr">let fix</span> <span class="nv">loop</span> <span class="nv">ts</span> :=
        <span class="kr">match</span> ts <span class="kr">return</span> fold_right (<span class="kr">fun</span> <span class="nv">t&#39;</span> =&gt; <span class="kn">and</span> (P t&#39;)) <span class="kt">True</span> ts <span class="kr">with</span>
        | [] =&gt; I
        | t&#39; :: ts&#39; =&gt; conj (tree_ind P IH t&#39;) (loop ts&#39;)
        <span class="kr">end</span> <span class="kr">in</span>
      IH n ts (loop ts)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">map_tree</span> (<span class="nv">f</span> : nat -&gt; nat) (<span class="nv">t</span> : tree) : tree :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | Node x ts =&gt; Node (f x) (map (<span class="kr">fun</span> <span class="nv">t</span> =&gt; map_tree f t) ts)
  <span class="kr">end</span>.</span></span></pre><p>The <span class="docutils literal">Unset Elimination Schemes</span> command prevents Coq from generating
its default (and not useful) induction principle for <span class="docutils literal">tree</span>. The
occurrence of <span class="docutils literal">fold_right</span> on the induction hypothesis simply
expresses that the predicate <span class="docutils literal">P</span> holds of every tree <span class="docutils literal">t'</span>
appearing in <span class="docutils literal">ts</span>.</p>
<p>Here is a statement that you can prove using this induction principle:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk3"><span class="kn">Lemma</span> <span class="nf">map_tree_comp</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">t</span> :
  map_tree f (map_tree g t) = map_tree (<span class="kr">fun</span> <span class="nv">n</span> =&gt; f (g n)) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, g</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map_tree f (map_tree g t) =
map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, g</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map_tree f (map_tree g t) =
map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk5"><span class="nb">induction</span> t <span class="kr">as</span> [n ts IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, g</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>list tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fold_right
  (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt;
   <span class="kn">and</span>
     (map_tree f (map_tree g t) =
      map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t)) <span class="kt">True</span>
  ts</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map_tree f (map_tree g (Node n ts)) =
map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) (Node n ts)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk6"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, g</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>list tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fold_right
  (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt;
   <span class="kn">and</span>
     (map_tree f (map_tree g t) =
      map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t)) <span class="kt">True</span>
  ts</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Node (f (g n))
  (map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree f t)
     (map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree g t) ts)) =
Node (f (g n))
  (map
     (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt;
      map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t) ts)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk7"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, g</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>list tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fold_right
  (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt;
   <span class="kn">and</span>
     (map_tree f (map_tree g t) =
      map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t)) <span class="kt">True</span>
  ts</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree f t)
  (map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree g t) ts) =
map
  (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t)
  ts</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk8"><span class="nb">induction</span> ts <span class="kr">as</span> [|t&#39; ts&#39; IHts]; <span class="kp">try</span> <span class="bp">easy</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, g</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>tree</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>list tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fold_right
  (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt;
   <span class="kn">and</span>
     (map_tree f (map_tree g t) =
      map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t)) <span class="kt">True</span>
  (t&#39; :: ts&#39;)</span></span></span><br><span><var>IHts</var><span class="hyp-type"><b>: </b><span>fold_right
  (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt;
   <span class="kn">and</span>
     (map_tree f (map_tree g t) =
      map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t))
  <span class="kt">True</span> ts&#39; -&gt;
map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree f t)
  (map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree g t) ts&#39;) =
map
  (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt;
   map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t) ts&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree f t)
  (map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree g t) (t&#39; :: ts&#39;)) =
map
  (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t)
  (t&#39; :: ts&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk9"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, g</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>tree</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>list tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>map_tree f (map_tree g t&#39;) =
map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t&#39; /\
fold_right
  (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt;
   <span class="kn">and</span>
     (map_tree f (map_tree g t) =
      map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t)) <span class="kt">True</span>
  ts&#39;</span></span></span><br><span><var>IHts</var><span class="hyp-type"><b>: </b><span>fold_right
  (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt;
   <span class="kn">and</span>
     (map_tree f (map_tree g t) =
      map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t))
  <span class="kt">True</span> ts&#39; -&gt;
map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree f t)
  (map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree g t) ts&#39;) =
map
  (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt;
   map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t) ts&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map_tree f (map_tree g t&#39;)
:: map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree f t)
     (map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree g t) ts&#39;) =
map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t&#39;
:: map
     (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt;
      map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t) ts&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chka"><span class="nb">destruct</span> IH <span class="kr">as</span> [IHt&#39; IHts&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, g</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>tree</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>list tree</span></span></span><br><span><var>IHt'</var><span class="hyp-type"><b>: </b><span>map_tree f (map_tree g t&#39;) =
map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t&#39;</span></span></span><br><span><var>IHts'</var><span class="hyp-type"><b>: </b><span>fold_right
  (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt;
   <span class="kn">and</span>
     (map_tree f (map_tree g t) =
      map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t))
  <span class="kt">True</span> ts&#39;</span></span></span><br><span><var>IHts</var><span class="hyp-type"><b>: </b><span>fold_right
  (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt;
   <span class="kn">and</span>
     (map_tree f (map_tree g t) =
      map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t))
  <span class="kt">True</span> ts&#39; -&gt;
map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree f t)
  (map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree g t) ts&#39;) =
map
  (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt;
   map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t) ts&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map_tree f (map_tree g t&#39;)
:: map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree f t)
     (map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree g t) ts&#39;) =
map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t&#39;
:: map
     (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt;
      map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t) ts&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chkb"><span class="nb">specialize</span> (IHts IHts&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, g</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>tree</span></span></span><br><span><var>ts'</var><span class="hyp-type"><b>: </b><span>list tree</span></span></span><br><span><var>IHt'</var><span class="hyp-type"><b>: </b><span>map_tree f (map_tree g t&#39;) =
map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t&#39;</span></span></span><br><span><var>IHts'</var><span class="hyp-type"><b>: </b><span>fold_right
  (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt;
   <span class="kn">and</span>
     (map_tree f (map_tree g t) =
      map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t))
  <span class="kt">True</span> ts&#39;</span></span></span><br><span><var>IHts</var><span class="hyp-type"><b>: </b><span>map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree f t)
  (map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree g t) ts&#39;) =
map
  (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt;
   map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t) ts&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map_tree f (map_tree g t&#39;)
:: map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree f t)
     (map (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt; map_tree g t) ts&#39;) =
map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t&#39;
:: map
     (<span class="kr">fun</span> <span class="nv">t</span> : tree =&gt;
      map_tree (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f (g n)) t) ts&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHt&#39;, &lt;- IHts.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></section>
<section id="answer-joachim-breitner">
<h2>Answer (Joachim Breitner)</h2>
<p>In general, it might be advisable to avoid this problem. But if one
really wants to obtain the proof obligation that Isabelle gives you,
here is a way:</p>
<p>In Isabelle, we can give an external lemma that stats that <span class="docutils literal">map</span>
applies its arguments only to members of the given list. In Coq, we
cannot do this in an external lemma, but we can do it in the type. So
instead of the normal type of map</p>
<pre class="code coq literal-block"><code><span class="k">forall</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">list</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">list</span> <span class="n">B</span></code></pre>
<p>we want the type to say &quot;f is only ever applied to elements of the list&quot;:</p>
<pre class="code coq literal-block"><code><span class="k">forall</span> <span class="n">A</span> <span class="n">B</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">),</span> <span class="o">(</span><span class="k">forall</span> <span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">In</span> <span class="n">x</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">list</span> <span class="n">B</span></code></pre>
<p>(It requires reordering the argument so that the type of <span class="docutils literal">f</span> can
mention <span class="docutils literal">xs</span>).</p>
<p>Writing this function is not trivial, and I found it easier to use a
proof script:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chkc"><span class="kn">Definition</span> <span class="nf">map</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">xs</span> : list A) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, In x xs -&gt; B) : list B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In x xs -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In x xs -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chke"><span class="nb">induction</span> xs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In x [] -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In x (a :: xs) -&gt; B</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, In x xs -&gt; B) -&gt; list B</span></span></span><br></div><label class="goal-separator" for="nested-recursion-and-program-fixpoint-or-function-v-chkf"><hr></label><div class="goal-conclusion">list B</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk10">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In x [] -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk11">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In x (a :: xs) -&gt; B</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, In x xs -&gt; B) -&gt; list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk12"><span class="nb">refine</span> (f a _ :: IHxs _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In x (a :: xs) -&gt; B</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, In x xs -&gt; B) -&gt; list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In a (a :: xs)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk13" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In x (a :: xs) -&gt; B</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, In x xs -&gt; B) -&gt; list B</span></span></span><br></div><label class="goal-separator" for="nested-recursion-and-program-fixpoint-or-function-v-chk13"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, In x xs -&gt; B</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk14">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In x (a :: xs) -&gt; B</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, In x xs -&gt; B) -&gt; list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In a (a :: xs)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk15"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In x (a :: xs) -&gt; B</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, In x xs -&gt; B) -&gt; list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk16">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In x (a :: xs) -&gt; B</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, In x xs -&gt; B) -&gt; list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, In x xs -&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk17"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In x (a :: xs) -&gt; B</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, In x xs -&gt; B) -&gt; list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In x xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk18"><span class="nb">eapply</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In x (a :: xs) -&gt; B</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, In x xs -&gt; B) -&gt; list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In x xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In <span class="nl">?x</span> (a :: xs)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk19"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, In x (a :: xs) -&gt; B</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, In x xs -&gt; B) -&gt; list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In x xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In <span class="nl">?x</span> xs</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>But you can also write it &quot;by hand&quot;:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">map</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">xs</span> : list A) :
  <span class="kr">forall</span> (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, In x xs -&gt; B), list B :=
  <span class="kr">match</span> xs <span class="kr">with</span>
  | [] =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; []
  | x :: xs =&gt;
      <span class="kr">fun</span> <span class="nv">f</span> =&gt; f x (or_introl eq_refl) :: map xs (<span class="kr">fun</span> <span class="nv">y</span> <span class="nv">h</span> =&gt; f y (or_intror h))
  <span class="kr">end</span>.</span></span></pre><p>In either case, the result is nice: I can use this function in
<span class="docutils literal">mapTree</span>, i.e.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Fixpoint</span> <span class="nf">mapTree</span> (<span class="nv">f</span> : nat -&gt; nat) (<span class="nv">t</span> : Tree)
        {<span class="nv">measure</span> (height t)} : Tree :=
  <span class="kr">match</span> t <span class="kr">with</span>
    Node x ts =&gt; Node (f x) (map ts (<span class="kr">fun</span> <span class="nv">t</span> <span class="nv">_</span> =&gt; mapTree f t))
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk1a"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>mapTree</var><span class="hyp-type"><b>: </b><span>(nat -&gt; nat) -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : Tree,
height t &lt; height (Node x ts) -&gt; Tree</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In t ts</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t &lt; height (Node x ts)</div></blockquote></div></div></small></span></pre><p>and I don't have to do anything with the new argument to <span class="docutils literal">f</span>, but it
shows up in the the termination proof obligation, as <span class="docutils literal">In t ts <span class="pre">-&gt;</span> height t &lt; height (Node x ts)</span> as desired. So I can prove that and
define <span class="docutils literal">mapTree</span>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk1b"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>mapTree</var><span class="hyp-type"><b>: </b><span>(nat -&gt; nat) -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : Tree,
height t &lt; height (Node x ts) -&gt; Tree</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In t ts</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t &lt;
S (fold_right Nat.max <span class="mi">0</span> (List.map height ts))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk1c"><span class="nb">apply</span> Lt.le_lt_n_Sm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>mapTree</var><span class="hyp-type"><b>: </b><span>(nat -&gt; nat) -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : Tree,
height t &lt; height (Node x ts) -&gt; Tree</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In t ts</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t &lt;= fold_right Nat.max <span class="mi">0</span> (List.map height ts)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk1d"><span class="nb">clear</span> mapTree.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In t ts</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t &lt;= fold_right Nat.max <span class="mi">0</span> (List.map height ts)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk1e"><span class="nb">induction</span> ts; <span class="nb">inversion_clear</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHts</var><span class="hyp-type"><b>: </b><span>In t ts -&gt;
height t &lt;=
fold_right Nat.max <span class="mi">0</span> (List.map height ts)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t &lt;=
fold_right Nat.max <span class="mi">0</span> (List.map height (a :: ts))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk1f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHts</var><span class="hyp-type"><b>: </b><span>In t ts -&gt;
height t &lt;=
fold_right Nat.max <span class="mi">0</span> (List.map height ts)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In t ts</span></span></span><br></div><label class="goal-separator" for="nested-recursion-and-program-fixpoint-or-function-v-chk1f"><hr></label><div class="goal-conclusion">height t &lt;=
fold_right Nat.max <span class="mi">0</span> (List.map height (a :: ts))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk20">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHts</var><span class="hyp-type"><b>: </b><span>In t ts -&gt;
height t &lt;=
fold_right Nat.max <span class="mi">0</span> (List.map height ts)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t &lt;=
fold_right Nat.max <span class="mi">0</span> (List.map height (a :: ts))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk21"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHts</var><span class="hyp-type"><b>: </b><span>In t ts -&gt;
height t &lt;=
fold_right Nat.max <span class="mi">0</span> (List.map height ts)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t &lt;=
fold_right Nat.max <span class="mi">0</span> (List.map height (t :: ts))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> PeanoNat.Nat.le_max_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk22">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHts</var><span class="hyp-type"><b>: </b><span>In t ts -&gt;
height t &lt;=
fold_right Nat.max <span class="mi">0</span> (List.map height ts)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In t ts</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">height t &lt;=
fold_right Nat.max <span class="mi">0</span> (List.map height (a :: ts))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nested-recursion-and-program-fixpoint-or-function-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="nested-recursion-and-program-fixpoint-or-function-v-chk23"><span class="nb">rewrite</span> IHts <span class="bp">by</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ts</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHts</var><span class="hyp-type"><b>: </b><span>In t ts -&gt;
height t &lt;=
fold_right Nat.max <span class="mi">0</span> (List.map height ts)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In t ts</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fold_right Nat.max <span class="mi">0</span> (List.map height ts) &lt;=
fold_right Nat.max <span class="mi">0</span> (List.map height (a :: ts))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> PeanoNat.Nat.le_max_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>It only works with <span class="docutils literal">Program Fixpoint</span>, not with <span class="docutils literal">Function</span>,
unfortunately.</p>
</section>
<section id="answer-matthieu-sozeau">
<h2>Answer (Matthieu Sozeau)</h2>
<p>You can now do this with Equations and get the right elimination
principle automatically, using either <a class="reference external" href="http://mattam82.github.io/Coq-Equations/examples/Examples.nested_mut_rec.html">structural nested recursion</a>
or <a class="reference external" href="http://mattam82.github.io/Coq-Equations/examples/Examples.RoseTree.html">well-founded recursion</a>.</p>
</section>
</div>
</main>
</div></body>
</html>
