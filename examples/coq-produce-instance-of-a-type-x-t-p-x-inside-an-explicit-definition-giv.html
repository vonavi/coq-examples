<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Coq produce instance of a type {x : T | P x} inside an explicit definition given an x of type T</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-given-an-x-of-type-t">
<h1 class="title">Coq produce instance of a type <span class="docutils literal">{x : T | P x}</span> inside an explicit definition given an <span class="docutils literal">x</span> of type <span class="docutils literal">T</span></h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://proofassistants.stackexchange.com/q/885">https://proofassistants.stackexchange.com/q/885</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>I'm trying to formalize a simple type system in Coq as an exercise.</p>
<p>I have a type <span class="docutils literal">Item</span> and a type <span class="docutils literal">{x : Item | IsNormal Item}</span>. If
<span class="docutils literal">Sort</span> is a constructor of <span class="docutils literal">Item</span> and <span class="docutils literal">Sort</span> satisfies
<span class="docutils literal">IsNormal</span>, what's the most natural way to produce an instance of
<span class="docutils literal">{x : Item | IsNormal Item}</span> where the <span class="docutils literal">Item</span> in question is
<span class="docutils literal">Sort</span>?</p>
<hr class="docutils" />
<p>I have an inductive type called <span class="docutils literal">Item</span> which might be a read of a
free variable (in this case a free variable is an <span class="docutils literal">N</span>).</p>
<p>I want to introduce a distinction between terms that are headed by a
variable read and terms that are definitely not headed by a variable.</p>
<p>I'm trying to use <span class="docutils literal">sig types</span> for this (see <a class="reference external" href="https://proofassistants.stackexchange.com/a/731">this answer</a> and <a class="reference external" href="https://coq.inria.fr/library/Coq.Init.Specif.html">this link</a>).</p>
<p>The thing I am having problems with is this definition. (I also tried
a shorter version with <span class="docutils literal">match x with | Read x' =&gt; env x' | _ =&gt; x end</span> as the body)</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk0"><span class="kn">Definition</span> <span class="nf">in_env</span> (<span class="nv">env</span> : nat -&gt; NormalItem) (<span class="nv">x</span> : Item) : NormalItem :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Read x&#39; =&gt; env x&#39;
  | <span class="kn">Sort</span> =&gt; <span class="kn">Sort</span>
  | N =&gt; N
  | T =&gt; T
  | Nat n =&gt; Nat n
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">In environment
env : nat -&gt; NormalItem
x : Item
The term <span class="s2">&quot;Sort&quot;</span> has type <span class="s2">&quot;Item&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type <span class="s2">&quot;NormalItem&quot;</span>.</blockquote></div></div></small></span></pre><p><span class="docutils literal">NormalItem</span> is defined as <span class="docutils literal">{ x : Item | IsNormal x }</span>, where
<span class="docutils literal">IsNormal</span> picks out the members of <span class="docutils literal">Item</span> that are not headed by
<span class="docutils literal">Read</span>.</p>
<p>This definition doesn't type check (error shown below).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk1" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
In environment
env : nat -&gt; NormalItem
x : Item
The term <span class="s2">&quot;Sort&quot;</span> has type <span class="s2">&quot;Item&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type <span class="s2">&quot;NormalItem&quot;</span>.</blockquote></div></div></small></span></pre><p>I think this is because <span class="docutils literal">Sort</span> needs to instead be a pair consisting
of an <span class="docutils literal">Item</span> and a proof that the item in question satisfies
<span class="docutils literal">isNormal</span>. I cannot figure out, however, how to write such a thing.</p>
<section id="appendix-a">
<h3>Appendix A</h3>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Arith.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Specif.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> nat_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Item</span> : <span class="kt">Type</span> :=
| <span class="kn">Sort</span> : Item
| N : Item
| T : Item
| Nat : nat -&gt; Item
| Read : nat -&gt; Item.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">IsNormal</span> (<span class="nv">a</span> : Item) : <span class="kt">Prop</span> :=
  <span class="kr">match</span> a <span class="kr">with</span>
  | Read _ =&gt; <span class="kt">False</span>
  | _ =&gt; <span class="kt">True</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">NormalItem</span> : <span class="kt">Type</span> := { x : Item | IsNormal x }.</span></span></pre></section>
</section>
<section id="answer-meven-lennon-bertrand">
<h2>Answer (Meven Lennon-Bertrand)</h2>
<p>If you look at how <span class="docutils literal">{ x : A | P }</span> is defined (for instance using
<span class="docutils literal">Locate &quot;{&quot;</span>. to find out it's a notation for <span class="docutils literal">sig</span> and <span class="docutils literal">Print sig</span>. to see the definition of <span class="docutils literal">sig</span>), you can see that to
construct an inhabitant of <span class="docutils literal">NormalItem</span> you indeed need to provide a
pair (or, rather, two arguments) to the unique constructor <span class="docutils literal">exists</span>
of <span class="docutils literal">sig</span>.</p>
<p>There are two ways to do this. The first one is to simply alter your
definition to the following (I took the liberty of factoring out the
branches as you suggested)</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">in_env</span> (<span class="nv">env</span> : nat -&gt; NormalItem) (<span class="nv">x</span> : Item) : NormalItem :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Read x&#39; =&gt; env x&#39;
  | y =&gt; exist _ y I
  <span class="kr">end</span>.</span></span></pre><p>here <span class="docutils literal">I</span> is the only constructor of <span class="docutils literal">True</span>, to which <span class="docutils literal">IsNormal y</span> reduces to in those branches.</p>
<p>Now this works on this simple example because the proof you have to
write by hand is very simple, but often you want to do a &quot;mixed&quot;
definition, where you give some part of it in a direct way, but write
down proofs interactively. You can do this by hand, relying on the
<span class="docutils literal">refine</span> tactic:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk2"><span class="kn">Definition</span> <span class="nf">in_env&#39;</span> (<span class="nv">env</span> : nat -&gt; NormalItem) (<span class="nv">x</span> : Item) : NormalItem.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>nat -&gt; NormalItem</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NormalItem</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>nat -&gt; NormalItem</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NormalItem</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk4"><span class="nb">refine</span> (
      <span class="kr">match</span> x <span class="kr">with</span>
      | Read x&#39; =&gt; env x&#39;
      | <span class="kn">Sort</span> =&gt; exist _ <span class="kn">Sort</span> _
      | N =&gt; exist _ N _
      | T =&gt; exist _ T _
      | Nat n =&gt; exist _ (Nat n) _
      <span class="kr">end</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>nat -&gt; NormalItem</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsNormal <span class="kn">Sort</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>nat -&gt; NormalItem</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Item</span></span></span><br></div><label class="goal-separator" for="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk5"><hr></label><div class="goal-conclusion">IsNormal N</div></blockquote><input class="alectryon-extra-goal-toggle" id="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>nat -&gt; NormalItem</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Item</span></span></span><br></div><label class="goal-separator" for="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk6"><hr></label><div class="goal-conclusion">IsNormal T</div></blockquote><input class="alectryon-extra-goal-toggle" id="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>nat -&gt; NormalItem</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Item</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk7"><hr></label><div class="goal-conclusion">IsNormal (Nat n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">cbn</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>However, doing this by hand can get quite tedious quite fast. Happily,
<a class="reference external" href="https://coq.inria.fr/refman/addendum/program.html">Program</a> and
<a class="reference external" href="https://coq.inria.fr/refman/addendum/program.html">Equations</a> can
help making this kind of definitions more natural.</p>
</section>
<section id="answer-andrej-bauer">
<h2>Answer (Andrej Bauer)</h2>
<p>It is very unlikely that you really want to organize your
formalization using predicates such as <span class="docutils literal">IsNormal</span>. Instead you
should define types that already carry precisely the correct
information and use those.</p>
<p>I am guessing what you are doing, so for a better answer, please
explain in your question what the Grand Plan of your formalization is.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">NormalItem</span> :=
| <span class="kn">Sort</span> : NormalItem
| N : NormalItem
| T : NormalItem
| Nat : nat -&gt; NormalItem.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Item</span> : <span class="kt">Type</span> :=
| Normal : NormalItem -&gt; Item
| Read : nat -&gt; Item.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">in_env</span> (<span class="nv">env</span> : nat -&gt; NormalItem) (<span class="nv">x</span> : Item) : NormalItem :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Read x&#39; =&gt; env x&#39;
  | Normal y =&gt; y
  <span class="kr">end</span>.</span></span></pre></section>
</div>
</main>
</div></body>
</html>
