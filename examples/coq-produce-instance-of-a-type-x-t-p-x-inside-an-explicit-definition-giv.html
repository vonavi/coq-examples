<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>Coq produce instance of a type {x : T | P x} inside an explicit definition given an x of type T</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-given-an-x-of-type-t">
<h1 class="title">Coq produce instance of a type <tt class="docutils literal">{x : T | P x}</tt> inside an explicit definition given an <tt class="docutils literal">x</tt> of type <tt class="docutils literal">T</tt></h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://proofassistants.stackexchange.com/q/885">https://proofassistants.stackexchange.com/q/885</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>I'm trying to formalize a simple type system in Coq as an exercise.</p>
<p>I have a type <tt class="docutils literal">Item</tt> and a type <tt class="docutils literal">{x : Item | IsNormal Item}</tt>. If
<tt class="docutils literal">Sort</tt> is a constructor of <tt class="docutils literal">Item</tt> and <tt class="docutils literal">Sort</tt> satisfies
<tt class="docutils literal">IsNormal</tt>, what's the most natural way to produce an instance of
<tt class="docutils literal">{x : Item | IsNormal Item}</tt> where the <tt class="docutils literal">Item</tt> in question is
<tt class="docutils literal">Sort</tt>?</p>
<hr class="docutils" />
<p>I have an inductive type called <tt class="docutils literal">Item</tt> which might be a read of a
free variable (in this case a free variable is an <tt class="docutils literal">N</tt>).</p>
<p>I want to introduce a distinction between terms that are headed by a
variable read and terms that are definitely not headed by a variable.</p>
<p>I'm trying to use <tt class="docutils literal">sig types</tt> for this (see <a class="reference external" href="https://proofassistants.stackexchange.com/a/731">this answer</a> and <a class="reference external" href="https://coq.inria.fr/library/Coq.Init.Specif.html">this link</a>).</p>
<p>The thing I am having problems with is this definition. (I also tried
a shorter version with <tt class="docutils literal">match x with | Read x' =&gt; env x' | _ =&gt; x
end</tt> as the body)</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk0"><span class="kn">Definition</span> <span class="nf">in_env</span> (<span class="nv">env</span> : nat -&gt; NormalItem) (<span class="nv">x</span> : Item) : NormalItem :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Read x&#39; =&gt; env x&#39;
  | <span class="kn">Sort</span> =&gt; <span class="kn">Sort</span>
  | N =&gt; N
  | T =&gt; T
  | Nat n =&gt; Nat n
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">In environment
env : nat -&gt; NormalItem
x : Item
The term <span class="s2">&quot;Sort&quot;</span> has type <span class="s2">&quot;Item&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type <span class="s2">&quot;NormalItem&quot;</span>.</blockquote></div></div></small></span></pre><p><tt class="docutils literal">NormalItem</tt> is defined as <tt class="docutils literal">{ x : Item | IsNormal x }</tt>, where
<tt class="docutils literal">IsNormal</tt> picks out the members of <tt class="docutils literal">Item</tt> that are not headed by
<tt class="docutils literal">Read</tt>.</p>
<p>This definition doesn't type check (error shown below).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk1" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
In environment
env : nat -&gt; NormalItem
x : Item
The term <span class="s2">&quot;Sort&quot;</span> has type <span class="s2">&quot;Item&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type <span class="s2">&quot;NormalItem&quot;</span>.</blockquote></div></div></small></span></pre><p>I think this is because <tt class="docutils literal">Sort</tt> needs to instead be a pair consisting
of an <tt class="docutils literal">Item</tt> and a proof that the item in question satisfies
<tt class="docutils literal">isNormal</tt>. I cannot figure out, however, how to write such a thing.</p>
<div class="section" id="appendix-a">
<h2>Appendix A</h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Arith.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Specif.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> nat_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Item</span> : <span class="kt">Type</span> :=
| <span class="kn">Sort</span> : Item
| N : Item
| T : Item
| Nat : nat -&gt; Item
| Read : nat -&gt; Item.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">IsNormal</span> (<span class="nv">a</span> : Item) : <span class="kt">Prop</span> :=
  <span class="kr">match</span> a <span class="kr">with</span>
  | Read _ =&gt; <span class="kt">False</span>
  | _ =&gt; <span class="kt">True</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">NormalItem</span> : <span class="kt">Type</span> := { x : Item | IsNormal x }.</span></span></pre></div>
</div>
<div class="section" id="answer-meven-lennon-bertrand">
<h1>Answer (Meven Lennon-Bertrand)</h1>
<p>If you look at how <tt class="docutils literal">{ x : A | P }</tt> is defined (for instance using
<tt class="docutils literal">Locate &quot;{&quot;</tt>. to find out it's a notation for <tt class="docutils literal">sig</tt> and <tt class="docutils literal">Print
sig</tt>. to see the definition of <tt class="docutils literal">sig</tt>), you can see that to
construct an inhabitant of <tt class="docutils literal">NormalItem</tt> you indeed need to provide a
pair (or, rather, two arguments) to the unique constructor <tt class="docutils literal">exists</tt>
of <tt class="docutils literal">sig</tt>.</p>
<p>There are two ways to do this. The first one is to simply alter your
definition to the following (I took the liberty of factoring out the
branches as you suggested)</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">in_env</span> (<span class="nv">env</span> : nat -&gt; NormalItem) (<span class="nv">x</span> : Item) : NormalItem :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Read x&#39; =&gt; env x&#39;
  | y =&gt; exist _ y I
  <span class="kr">end</span>.</span></span></pre><p>here <tt class="docutils literal">I</tt> is the only constructor of <tt class="docutils literal">True</tt>, to which <tt class="docutils literal">IsNormal
y</tt> reduces to in those branches.</p>
<p>Now this works on this simple example because the proof you have to
write by hand is very simple, but often you want to do a &quot;mixed&quot;
definition, where you give some part of it in a direct way, but write
down proofs interactively. You can do this by hand, relying on the
<tt class="docutils literal">refine</tt> tactic:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk2"><span class="kn">Definition</span> <span class="nf">in_env&#39;</span> (<span class="nv">env</span> : nat -&gt; NormalItem) (<span class="nv">x</span> : Item) : NormalItem.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>nat -&gt; NormalItem</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NormalItem</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>nat -&gt; NormalItem</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NormalItem</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk4"><span class="nb">refine</span> (
      <span class="kr">match</span> x <span class="kr">with</span>
      | Read x&#39; =&gt; env x&#39;
      | <span class="kn">Sort</span> =&gt; exist _ <span class="kn">Sort</span> _
      | N =&gt; exist _ N _
      | T =&gt; exist _ T _
      | Nat n =&gt; exist _ (Nat n) _
      <span class="kr">end</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>nat -&gt; NormalItem</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsNormal <span class="kn">Sort</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>nat -&gt; NormalItem</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Item</span></span></span><br></div><label class="goal-separator" for="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk5"><hr></label><div class="goal-conclusion">IsNormal N</div></blockquote><input class="alectryon-extra-goal-toggle" id="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>nat -&gt; NormalItem</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Item</span></span></span><br></div><label class="goal-separator" for="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk6"><hr></label><div class="goal-conclusion">IsNormal T</div></blockquote><input class="alectryon-extra-goal-toggle" id="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>nat -&gt; NormalItem</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Item</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv-v-chk7"><hr></label><div class="goal-conclusion">IsNormal (Nat n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">cbn</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>However, doing this by hand can get quite tedious quite fast. Happily,
<a class="reference external" href="https://coq.inria.fr/refman/addendum/program.html">Program</a> and
<a class="reference external" href="https://coq.inria.fr/refman/addendum/program.html">Equations</a> can
help making this kind of definitions more natural.</p>
</div>
<div class="section" id="answer-andrej-bauer">
<h1>Answer (Andrej Bauer)</h1>
<p>It is very unlikely that you really want to organize your
formalization using predicates such as <tt class="docutils literal">IsNormal</tt>. Instead you
should define types that already carry precisely the correct
information and use those.</p>
<p>I am guessing what you are doing, so for a better answer, please
explain in your question what the Grand Plan of your formalization is.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">NormalItem</span> :=
| <span class="kn">Sort</span> : NormalItem
| N : NormalItem
| T : NormalItem
| Nat : nat -&gt; NormalItem.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Item</span> : <span class="kt">Type</span> :=
| Normal : NormalItem -&gt; Item
| Read : nat -&gt; Item.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">in_env</span> (<span class="nv">env</span> : nat -&gt; NormalItem) (<span class="nv">x</span> : Item) : NormalItem :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Read x&#39; =&gt; env x&#39;
  | Normal y =&gt; y
  <span class="kr">end</span>.</span></span></pre></div>
</div>
</div>
</div></body>
</html>
