<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>Proofs of structural properties of arguments in match in coq</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="proofs-of-structural-properties-of-arguments-in-match-in-coq">
<h1 class="title">Proofs of structural properties of arguments in match in coq</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/questions/66064683/proofs-of-structural-properties-of-arguments-in-match-in-coq">https://stackoverflow.com/questions/66064683/proofs-of-structural-properties-of-arguments-in-match-in-coq</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>I would like to write a safe zip function in coq that accepts the
argument length equality as an argument.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="proofs-of-structural-properties-of-arguments-in-match-in-coq-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="proofs-of-structural-properties-of-arguments-in-match-in-coq-v-chk0"><span class="kn">Fixpoint</span> <span class="nf">zip</span> {<span class="nv">b</span> <span class="nv">a</span>:<span class="kt">Type</span>} (<span class="nv">l1</span> : list a) (<span class="nv">l2</span> : list b)
     (<span class="nv">proof</span> : length l1 = length l2) : list (a * b) :=
  <span class="kr">match</span> l1,l2 <span class="kr">with</span>
  | nil, nil =&gt; nil
  | cons a a&#39;, cons b b&#39; =&gt; cons (a, b) (zip a&#39; b&#39;)
  | _, _ =&gt; _ <span class="c">(* never reached *)</span>
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">In environment
zip : <span class="kr">forall</span> (<span class="nv">b</span> <span class="nv">a</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> : list a) (<span class="nv">l2</span> : list b),
      length l1 = length l2 -&gt; list (a * b)
b : <span class="kt">Type</span>
a : <span class="kt">Type</span>
l1 : list a
l2 : list b
proof : length l1 = length l2
a0 : a
a&#39; : list a
b0 : b
b&#39; : list b
The term <span class="s2">&quot;zip b a a&#39; b&#39;&quot;</span> has type
 <span class="s2">&quot;length a&#39; = length b&#39; -&gt; list (a * b)&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type <span class="s2">&quot;list (a * b)&quot;</span>.</blockquote></div></div></small></span></pre><p>what is the general approach to this kind of problem? I would
appreciate comments and resources on using refinement types in the
context of coq functions generally.</p>
</div>
<div class="section" id="answer">
<h1>Answer</h1>
<p>Here is the best approach to this particular problem, in my opinion:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Lists.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">zip_pre</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">xs</span> : list A) (<span class="nv">ys</span> : list B) : list (A * B) :=
  <span class="kr">match</span> xs, ys <span class="kr">with</span>
  | x :: xs, y :: ys =&gt; (x, y) :: zip_pre xs ys
  | _, _ =&gt; []
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">zip</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">xs</span> : list A) (<span class="nv">ys</span> : list B) (<span class="nv">_</span> : length xs = length ys) :=
  zip_pre xs ys.</span></span></pre><p>In words, we first define a version of <tt class="docutils literal">zip</tt> that does not care
about lengths, and then we use that to define the function you're
looking for.</p>
<p>This might feel like cheating; after all, the <tt class="docutils literal">zip</tt> function doesn't
even use its proof argument! Here is another version that is perhaps
closer to what you were originally looking for:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">zip&#39;</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">xs</span> : list A) (<span class="nv">ys</span> : list B) :
  length xs = length ys -&gt; list (A * B) :=
  <span class="kr">match</span> xs, ys <span class="kr">with</span>
  | x :: xs, y :: ys =&gt;
    <span class="kr">fun</span> <span class="nv">H</span> : S (length xs) = S (length ys) =&gt;
      (x, y) :: zip&#39; xs ys <span class="kp">ltac</span>:(<span class="bp">congruence</span>)
  | [], [] =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; []
  | x :: xs, [] =&gt; <span class="kr">fun</span> <span class="nv">H</span> : S (length xs) = <span class="mi">0</span> =&gt; <span class="kp">ltac</span>:(<span class="bp">easy</span>)
  | [], y :: ys =&gt; <span class="kr">fun</span> <span class="nv">H</span> : <span class="mi">0</span> = S (length ys) =&gt; <span class="kp">ltac</span>:(<span class="bp">easy</span>)
  <span class="kr">end</span>.</span></span></pre><p>Unlike <tt class="docutils literal">zip</tt>, <tt class="docutils literal">zip'</tt> uses its proof argument in two ways. In the
contradictory cases, it invokes some tactic code (<tt class="docutils literal"><span class="pre">ltac:(easy)</span></tt>) to
argue that this case cannot arise. In the recursive case, it needs to
find a proof of <tt class="docutils literal">length xs = length ys</tt> to apply the recursive call;
for this, it uses the <tt class="docutils literal">congruence</tt> tacitc.</p>
<p>Why is <tt class="docutils literal">zip</tt> better than <tt class="docutils literal">zip'</tt>? Its code is shorter and easier to
read. In particular, note how <tt class="docutils literal">zip'</tt> has a match returning a
function. This idiom, known as the <em>convoy pattern</em>, is needed
whenever we need to refine the type of an argument in a pattern
matching branch. Actually, <tt class="docutils literal">zip'</tt> is even worse than what you might
think, because the tactics that discharge the proof obligations
generate code. Try printing <tt class="docutils literal">zip'</tt> to see what the definition really
looks like! Sadly, this ugliness is not just cosmetic: these more
complicated definitions are much harder to reason about. For instance,
it is possible to prove that <tt class="docutils literal">zip</tt> and <tt class="docutils literal">zip'</tt> always produce the
same outputs. Try it to see how fun it is!</p>
<p>To be fair, there are Coq plugins that make it easier to write this
sort of code (e.g. the <a class="reference external" href="https://github.com/mattam82/Coq-Equations">Equations</a> plugin). But at the end
of the day they will still generate code that is equivalent to
<tt class="docutils literal">zip'</tt>. And in this case, the length hypothesis doesn't buy us much.</p>
<p>In general, one is better off avoiding dependent types in Coq, unless
there is a strong argument that justifies the additional complexity.
For instance, in the case of <tt class="docutils literal">zip</tt>, suppose that you have some code
that uses a lot of different lists of the same length n. You might
want to argue that <tt class="docutils literal">zip</tt> has an inverse:</p>
<pre class="code coq literal-block">
<span class="kr">let</span> <span class="nv">xys</span> <span class="o">:=</span> <span class="n">zip</span> <span class="n">xs</span> <span class="n">ys</span> <span class="kr">in</span>
<span class="o">(</span><span class="n">map</span> <span class="n">fst</span> <span class="n">xys</span><span class="o">,</span> <span class="n">map</span> <span class="n">snd</span> <span class="n">xys</span><span class="o">)</span> <span class="o">=</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">).</span>
</pre>
<p>It is not possible to prove this result unless we know that <tt class="docutils literal">xs</tt> and
<tt class="docutils literal">ys</tt> have the same length. We can add an additional hypothesis to
our lemma, or we can work with length-indexed lists. Here is one
possible definition:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">vec</span> <span class="nv">A</span> <span class="nv">n</span> := {l : list A | length l = n}.</span></span></pre><p>The <tt class="docutils literal">{.. | ..}</tt> is Coq's notation for refinement, or subset types.
We can then repackage some of the functions over lists to work over
<tt class="docutils literal">vec</tt>. For instance, we can show that <tt class="docutils literal">map</tt> takes <tt class="docutils literal">vec A n</tt> to
<tt class="docutils literal">vec B n</tt>. This approach pays off if you don't use many functions
that require you to change the length index <tt class="docutils literal">n</tt>, because in those
cases you need to reason about the equality of complicated length
expressions on types, which Coq is not very good at. For <tt class="docutils literal">vec</tt> in
particular, I would recommend you to have a look at the <tt class="docutils literal">tuple</tt>
library of mathcomp (available <a class="reference external" href="https://math-comp.github.io/htmldoc/mathcomp.ssreflect.tuple.html">here</a>),
which provides a good example of how this pattern can be used at
scale.</p>
<p><strong>Edit</strong></p>
<ul class="simple">
<li>More on the <tt class="docutils literal">easy</tt> tactic:
<a class="reference external" href="https://coq.inria.fr/refman/proofs/automatic-tactics/auto.html#coq:tacn.easy">https://coq.inria.fr/refman/proofs/automatic-tactics/auto.html#coq:tacn.easy</a></li>
<li>Calling tactic code to build terms:
<a class="reference external" href="https://coq.github.io/doc/V8.11.1/refman/language/gallina-extensions.html#solving-existential-variables-using-tactics">https://coq.github.io/doc/V8.11.1/refman/language/gallina-extensions.html#solving-existential-variables-using-tactics</a></li>
</ul>
</div>
</div>
</div>
</div></body>
</html>
