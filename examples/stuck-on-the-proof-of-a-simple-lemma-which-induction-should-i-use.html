<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Stuck on the proof of a simple Lemma: which induction should I use?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use">
<h1 class="title">Stuck on the proof of a simple Lemma: which induction should I use?</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/73018759">https://stackoverflow.com/q/73018759</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>I have the following structures:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">instr</span> : <span class="kt">Set</span> :=
| Select    : nat -&gt; instr
| Backspace : instr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">prog</span> := list instr.</span></span></pre><p>and the following function:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">Forward</span> (<span class="nv">input</span> <span class="nv">output</span> : list nat) : option prog :=
  <span class="kr">match</span> input <span class="kr">with</span>
  | nil =&gt; <span class="kr">match</span> output <span class="kr">with</span>
           | nil =&gt; Some nil
           | y :: r =&gt; None
           <span class="kr">end</span>
  | x :: rest =&gt;
      <span class="kr">match</span> output <span class="kr">with</span>
      | nil =&gt; <span class="kr">match</span> rest <span class="kr">with</span>
               | nil =&gt; None
               | xx :: rrest =&gt; <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
                                | Some pp =&gt; Some (Select x :: Backspace :: pp)
                                | None =&gt; None
                                <span class="kr">end</span>
               <span class="kr">end</span>
      | y :: r =&gt; <span class="kr">if</span> beq_nat x y <span class="kr">then</span>
                    <span class="kr">match</span> Forward rest r <span class="kr">with</span>
                    | Some pp =&gt; Some (Select x :: pp)
                    | None =&gt; None
                    <span class="kr">end</span>
                  <span class="kr">else</span>
                    <span class="kr">match</span> rest <span class="kr">with</span>
                    | nil =&gt; None
                    | xx :: rrest =&gt;
                        <span class="kr">match</span> Forward rrest output <span class="kr">with</span>
                        | Some pp =&gt; Some (Select x :: Backspace :: pp)
                        | None =&gt; None
                        <span class="kr">end</span>
                    <span class="kr">end</span>
      <span class="kr">end</span>
  <span class="kr">end</span>.</span></span></pre><p>Now I'd like to prove this simple Lemma:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk0"><span class="kn">Lemma</span> <span class="nf">app_forward</span> :
  <span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog) (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output</span> : list nat),
    Forward input1 output = Some p -&gt;
    Forward input2 nil = Some p&#39; -&gt;
    Forward (input1 ++ input2) output = Some (p ++ p&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog) (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward input1 output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (input1 ++ input2) output = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>Note: As mentioned in the answer bellow, the more general form of the
lemma is false:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk1"><span class="kn">Lemma</span> <span class="nf">not_app_forward</span> :
  <span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog) (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output1</span> <span class="nv">output2</span> : list nat),
    Forward input1 output1 = Some p -&gt;
    Forward input2 output2 = Some p&#39; -&gt;
    Forward (input1 ++ input2) (output1 ++ output2) = Some (p ++ p&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog)
  (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output1</span> <span class="nv">output2</span> : list nat),
Forward input1 output1 = Some p -&gt;
Forward input2 output2 = Some p&#39; -&gt;
Forward (input1 ++ input2) (output1 ++ output2) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>Whatever induction principle I use, I'm stuck.</p>
<p>For example, I've tried this induction pattern:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk2"><span class="kn">Definition</span> <span class="nf">list_pair_induction</span> {<span class="nv">A</span> : <span class="kt">Type</span>} :
  <span class="kr">forall</span> (<span class="nv">P</span> : list A -&gt; <span class="kt">Prop</span>),
    P nil -&gt;
    (<span class="kr">forall</span> <span class="nv">a</span>, P (a :: nil)) -&gt;
    (<span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">tl</span>, P tl -&gt; P (a :: b :: tl)) -&gt;
    <span class="kr">forall</span> <span class="nv">l</span>, P l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : list A -&gt; <span class="kt">Prop</span>,
P nil -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)) -&gt;
(<span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
 P tl -&gt; P (a :: b :: tl)) -&gt; <span class="kr">forall</span> <span class="nv">l</span> : list A, P l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : list A -&gt; <span class="kt">Prop</span>,
P nil -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)) -&gt;
(<span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
 P tl -&gt; P (a :: b :: tl)) -&gt; <span class="kr">forall</span> <span class="nv">l</span> : list A, P l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk4"><span class="nb">intros</span> P Pn P1 Prec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P tl -&gt; P (a :: b :: tl)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk5"><span class="kr">fix</span> tsli <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk6"><span class="nb">intros</span> [| x l].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk7"><hr></label><div class="goal-conclusion">P (x :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Pn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (x :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka"><span class="nb">generalize</span> (tsli l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P l -&gt; P (x :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chkb"><span class="nb">destruct</span> l <span class="kr">as</span> [| y tl]; <span class="nb">intros</span> Pl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (x :: nil)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tl</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P (y :: tl)</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chkc"><hr></label><div class="goal-conclusion">P (x :: y :: tl)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chkd">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (x :: nil)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (P1 x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chke">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tl</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P (y :: tl)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (x :: y :: tl)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chkf"><span class="nb">apply</span> Prec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tl</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P (y :: tl)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P tl</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (tsli tl).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>But I didn't manage to finalize the proof. There must be something
obvious I don't see. Can't someone help me with this proof?</p>
</section>
<section id="answer">
<h2>Answer</h2>
<p>There are two problems with your question. The first one is that the
statement you want to prove is false, here is a proof of a counter
example.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk10"><span class="kn">Lemma</span> <span class="nf">not_app_forward</span> :
  not
    (<span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog) (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output1</span> <span class="nv">output2</span> : list nat),
        Forward input1 output1 = Some p -&gt;
        Forward input2 output2 = Some p&#39; -&gt;
        Forward (input1 ++ input2) (output1 ++ output2) = Some (p ++ p&#39;)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">~
(<span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog)
   (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output1</span> <span class="nv">output2</span> : list nat),
 Forward input1 output1 = Some p -&gt;
 Forward input2 output2 = Some p&#39; -&gt;
 Forward (input1 ++ input2) (output1 ++ output2) =
 Some (p ++ p&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">~
(<span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog)
   (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output1</span> <span class="nv">output2</span> : list nat),
 Forward input1 output1 = Some p -&gt;
 Forward input2 output2 = Some p&#39; -&gt;
 Forward (input1 ++ input2) (output1 ++ output2) =
 Some (p ++ p&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk12"><span class="nb">intros</span> abs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>abs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog) (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output1</span> <span class="nv">output2</span> : list nat),
Forward input1 output1 = Some p -&gt;
Forward input2 output2 = Some p&#39; -&gt;
Forward (input1 ++ input2) (output1 ++ output2) = Some (p ++ p&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk13"><span class="nb">assert</span>
    (tmp := abs (Select <span class="mi">1</span> :: Backspace :: nil) (Select <span class="mi">1</span> :: Select <span class="mi">2</span> :: nil)
                (<span class="mi">1</span> :: <span class="mi">2</span> :: nil) (<span class="mi">1</span> :: <span class="mi">2</span> :: nil) nil (<span class="mi">1</span> :: <span class="mi">2</span> :: nil)
                refl_equal refl_equal).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>abs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog) (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output1</span> <span class="nv">output2</span> : list nat),
Forward input1 output1 = Some p -&gt;
Forward input2 output2 = Some p&#39; -&gt;
Forward (input1 ++ input2) (output1 ++ output2) = Some (p ++ p&#39;)</span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>Forward ((<span class="mi">1</span> :: <span class="mi">2</span> :: nil) ++ <span class="mi">1</span> :: <span class="mi">2</span> :: nil) (nil ++ <span class="mi">1</span> :: <span class="mi">2</span> :: nil) =
Some ((Select <span class="mi">1</span> :: Backspace :: nil) ++ Select <span class="mi">1</span> :: Select <span class="mi">2</span> :: nil)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk14"><span class="nb">compute</span> <span class="kr">in</span> tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>abs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog) (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output1</span> <span class="nv">output2</span> : list nat),
Forward input1 output1 = Some p -&gt;
Forward input2 output2 = Some p&#39; -&gt;
Forward (input1 ++ input2) (output1 ++ output2) = Some (p ++ p&#39;)</span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>Some (Select <span class="mi">1</span> :: Select <span class="mi">2</span> :: Select <span class="mi">1</span> :: Backspace :: nil) =
Some (Select <span class="mi">1</span> :: Backspace :: Select <span class="mi">1</span> :: Select <span class="mi">2</span> :: nil)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">discriminate</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>So, contrary to your claim, this is not a simple lemma.</p>
<p>The second problem is that the function has a complicated shape and
the proof by induction is difficult to organize. I cover this aspect
just below.</p>
<p>From the structure of the function <span class="docutils literal">Forward</span>, it is natural that you
should perform your proof by induction over the <span class="docutils literal">input</span> argument,
because it is the argument where recursive calls occur on a subterm.
However the proof is made complicated by the fact that recursive calls
happen not only on direct subterms (as in <span class="docutils literal">Forward rest ...</span>) but
also in subterms of subterms (as in <span class="docutils literal">Forward rrest ...</span>).</p>
<p>There are several ways out of this difficulty, but all require some
amount of explanation or learning.</p>
<ol class="arabic">
<li><p>One way is to use the <span class="docutils literal">Equations</span> plugin to Coq and redefine your
<span class="docutils literal">Forward</span> function using Equations. You can then use functional
induction to solve your problem: this will use an induction
principle that especially tailored to your problem.</p></li>
<li><p>A second way is to build a tailored induction principle by hand.
Here is an attempt.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk15"><span class="kn">Definition</span> <span class="nf">two_step_list_induction</span> {<span class="nv">A</span> : <span class="kt">Type</span>} :
  <span class="kr">forall</span> (<span class="nv">P</span> : list A -&gt; <span class="kt">Prop</span>),
    P nil -&gt;
    (<span class="kr">forall</span> <span class="nv">a</span>, P (a :: nil)) -&gt;
    (<span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">tl</span>,
        P (b :: tl) -&gt; P tl -&gt; P (a :: b :: tl)) -&gt;
    <span class="kr">forall</span> <span class="nv">l</span>, P l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : list A -&gt; <span class="kt">Prop</span>,
P nil -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)) -&gt;
(<span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
 P (b :: tl) -&gt; P tl -&gt; P (a :: b :: tl)) -&gt;
<span class="kr">forall</span> <span class="nv">l</span> : list A, P l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : list A -&gt; <span class="kt">Prop</span>,
P nil -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)) -&gt;
(<span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
 P (b :: tl) -&gt; P tl -&gt; P (a :: b :: tl)) -&gt;
<span class="kr">forall</span> <span class="nv">l</span> : list A, P l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk17"><span class="nb">intros</span> P Pn P1 Prec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P (b :: tl) -&gt; P tl -&gt; P (a :: b :: tl)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk18"><span class="kr">fix</span> tsli <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P (b :: tl) -&gt; P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk19"><span class="nb">intros</span> [| x l].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P (b :: tl) -&gt; P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk1a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P (b :: tl) -&gt; P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk1a"><hr></label><div class="goal-conclusion">P (x :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk1b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P (b :: tl) -&gt; P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Pn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk1c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P (b :: tl) -&gt; P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (x :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk1d"><span class="nb">generalize</span> (tsli l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P (b :: tl) -&gt; P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P l -&gt; P (x :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk1e"><span class="nb">destruct</span> l <span class="kr">as</span> [| y tl]; <span class="nb">intros</span> Pl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P (b :: tl) -&gt; P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (x :: nil)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk1f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P (b :: tl) -&gt; P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tl</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P (y :: tl)</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk1f"><hr></label><div class="goal-conclusion">P (x :: y :: tl)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk20">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P (b :: tl) -&gt; P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (x :: nil)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (P1 x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk21">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>Pn</var><span class="hyp-type"><b>: </b><span>P nil</span></span></span><br><span><var>P1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (a :: nil)</span></span></span><br><span><var>Prec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">tl</span> : list A),
P (b :: tl) -&gt; P tl -&gt; P (a :: b :: tl)</span></span></span><br><span><var>tsli</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, P l</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tl</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P (y :: tl)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (x :: y :: tl)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Prec; [<span class="bp">assumption</span> | <span class="bp">exact</span> (tsli tl)].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>You can then start your proof with a command of the following
shape:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk22"><span class="kn">Lemma</span> <span class="nf">app_forward</span> :
  <span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog) (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output1</span> <span class="nv">output2</span> : list nat),
    Forward input1 output1 = Some p -&gt;
    Forward input2 output2 = Some p&#39; -&gt;
    Forward (input1 ++ input2) (output1 ++ output2) = Some (p ++ p&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog)
  (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output1</span> <span class="nv">output2</span> : list nat),
Forward input1 output1 = Some p -&gt;
Forward input2 output2 = Some p&#39; -&gt;
Forward (input1 ++ input2) (output1 ++ output2) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk23"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog)
  (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output1</span> <span class="nv">output2</span> : list nat),
Forward input1 output1 = Some p -&gt;
Forward input2 output2 = Some p&#39; -&gt;
Forward (input1 ++ input2) (output1 ++ output2) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk24"><span class="nb">intros</span> p p&#39; input1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">input2</span> <span class="nv">output1</span> <span class="nv">output2</span> : list nat,
Forward input1 output1 = Some p -&gt;
Forward input2 output2 = Some p&#39; -&gt;
Forward (input1 ++ input2) (output1 ++ output2) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk25"><span class="nb">revert</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output1</span> <span class="nv">output2</span> : list nat),
Forward input1 output1 = Some p -&gt;
Forward input2 output2 = Some p&#39; -&gt;
Forward (input1 ++ input2) (output1 ++ output2) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk26"><span class="nb">induction</span> input1 <span class="kr">as</span> [| a | a b tl Ih1 Ih2] <span class="nb">using</span> two_step_list_induction.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output1</span> <span class="nv">output2</span> : list nat),
Forward nil output1 = Some p -&gt;
Forward input2 output2 = Some p&#39; -&gt;
Forward (nil ++ input2) (output1 ++ output2) =
Some (p ++ p&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk27" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk27"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output1</span> <span class="nv">output2</span> : list nat),
Forward (a :: nil) output1 = Some p -&gt;
Forward input2 output2 = Some p&#39; -&gt;
Forward ((a :: nil) ++ input2) (output1 ++ output2) =
Some (p ++ p&#39;)</div></blockquote><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tl</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog)
  (<span class="nv">input2</span> <span class="nv">output1</span> <span class="nv">output2</span> : list nat),
Forward (b :: tl) output1 = Some p -&gt;
Forward input2 output2 = Some p&#39; -&gt;
Forward ((b :: tl) ++ input2)
  (output1 ++ output2) = 
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog)
  (<span class="nv">input2</span> <span class="nv">output1</span> <span class="nv">output2</span> : list nat),
Forward tl output1 = Some p -&gt;
Forward input2 output2 = Some p&#39; -&gt;
Forward (tl ++ input2) (output1 ++ output2) =
Some (p ++ p&#39;)</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk28"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output1</span> <span class="nv">output2</span> : list nat),
Forward (a :: b :: tl) output1 = Some p -&gt;
Forward input2 output2 = Some p&#39; -&gt;
Forward ((a :: b :: tl) ++ input2)
  (output1 ++ output2) = 
Some (p ++ p&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>But, as I already said, the lemma you want to prove is actually
false, so there is no way this proof will ever work and I cannot
illustrate that the proposed approach is going to work.</p>
<p>EDIT: Now that the original question has been corrected, here is a
full correction to the original question:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk29"><span class="kn">Lemma</span> <span class="nf">app_forward</span> : <span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog) (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output</span> : list nat),
    Forward input1 output = Some p -&gt;
    Forward input2 nil = Some p&#39; -&gt;
    Forward (input1 ++ input2) output = Some (p ++ p&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog) (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward input1 output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (input1 ++ input2) output = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk2a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog) (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward input1 output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (input1 ++ input2) output = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk2b"><span class="nb">intros</span> p p&#39; input1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">input2</span> <span class="nv">output</span> : list nat,
Forward input1 output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (input1 ++ input2) output = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk2c"><span class="nb">revert</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward input1 output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (input1 ++ input2) output = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk2d"><span class="nb">induction</span> input1 <span class="kr">as</span> [| x | x xx rrest Ih1 Ih2] <span class="nb">using</span> two_step_list_induction.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward nil output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (nil ++ input2) output = Some (p ++ p&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk2e"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (x :: nil) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: nil) ++ input2) output = Some (p ++ p&#39;)</div></blockquote><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk2f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (x :: xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk30">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward nil output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (nil ++ input2) output = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk31"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
<span class="kr">match</span> output <span class="kr">with</span>
| nil =&gt; Some nil
| _ :: _ =&gt; None
<span class="kr">end</span> = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward input2 output = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk32"><span class="nb">intros</span> p input2 [| no1 output].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p', p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some nil = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward input2 nil = Some (p ++ p&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk33" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p', p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>no1</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>output</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk33"><hr></label><div class="goal-conclusion">None = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward input2 (no1 :: output) = Some (p ++ p&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk34">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p', p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some nil = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward input2 nil = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk35"><span class="nb">intros</span> [= p_is_nil].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p', p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>p_is_nil</var><span class="hyp-type"><b>: </b><span>nil = p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward input2 nil = Some p&#39; -&gt;
Forward input2 nil = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk36"><span class="nb">rewrite</span> &lt;- p_is_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p', p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>p_is_nil</var><span class="hyp-type"><b>: </b><span>nil = p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward input2 nil = Some p&#39; -&gt;
Forward input2 nil = Some (nil ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk37"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p', p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>p_is_nil</var><span class="hyp-type"><b>: </b><span>nil = p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward input2 nil = Some p&#39; -&gt;
Forward input2 nil = Some p&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk38">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p', p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>no1</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>output</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">None = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward input2 (no1 :: output) = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">discriminate</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk39">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (x :: nil) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: nil) ++ input2) output = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk3a"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
<span class="kr">match</span> output <span class="kr">with</span>
| nil =&gt; None
| y :: r =&gt;
    <span class="kr">if</span> x =? y
    <span class="kr">then</span>
     <span class="kr">match</span>
       <span class="kr">match</span> r <span class="kr">with</span>
       | nil =&gt; Some nil
       | _ :: _ =&gt; None
       <span class="kr">end</span>
     <span class="kr">with</span>
     | Some pp =&gt; Some (Select x :: pp)
     | None =&gt; None
     <span class="kr">end</span>
    <span class="kr">else</span> None
<span class="kr">end</span> = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
<span class="kr">match</span> output <span class="kr">with</span>
| nil =&gt;
    <span class="kr">match</span> input2 <span class="kr">with</span>
    | nil =&gt; None
    | _ :: rrest =&gt;
        <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
        | Some pp =&gt;
            Some (Select x :: Backspace :: pp)
        | None =&gt; None
        <span class="kr">end</span>
    <span class="kr">end</span>
| y :: r =&gt;
    <span class="kr">if</span> x =? y
    <span class="kr">then</span>
     <span class="kr">match</span> Forward input2 r <span class="kr">with</span>
     | Some pp =&gt; Some (Select x :: pp)
     | None =&gt; None
     <span class="kr">end</span>
    <span class="kr">else</span>
     <span class="kr">match</span> input2 <span class="kr">with</span>
     | nil =&gt; None
     | _ :: rrest =&gt;
         <span class="kr">match</span> Forward rrest output <span class="kr">with</span>
         | Some pp =&gt;
             Some (Select x :: Backspace :: pp)
         | None =&gt; None
         <span class="kr">end</span>
     <span class="kr">end</span>
<span class="kr">end</span> = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk3b"><span class="nb">destruct</span> output <span class="kr">as</span> [| y r]; <span class="nb">simpl</span>; <span class="kp">try</span> <span class="bp">discriminate</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> x =? y
 <span class="kr">then</span>
  <span class="kr">match</span>
    <span class="kr">match</span> r <span class="kr">with</span>
    | nil =&gt; Some nil
    | _ :: _ =&gt; None
    <span class="kr">end</span>
  <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: pp)
  | None =&gt; None
  <span class="kr">end</span>
 <span class="kr">else</span> None) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
(<span class="kr">if</span> x =? y
 <span class="kr">then</span>
  <span class="kr">match</span> Forward input2 r <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: pp)
  | None =&gt; None
  <span class="kr">end</span>
 <span class="kr">else</span>
  <span class="kr">match</span> input2 <span class="kr">with</span>
  | nil =&gt; None
  | _ :: rrest =&gt;
      <span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
      | Some pp =&gt; Some (Select x :: Backspace :: pp)
      | None =&gt; None
      <span class="kr">end</span>
  <span class="kr">end</span>) = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk3c"><span class="nb">destruct</span> (x =? y); <span class="kp">try</span> <span class="bp">discriminate</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  <span class="kr">match</span> r <span class="kr">with</span>
  | nil =&gt; Some nil
  | _ :: _ =&gt; None
  <span class="kr">end</span>
<span class="kr">with</span>
| Some pp =&gt; Some (Select x :: pp)
| None =&gt; None
<span class="kr">end</span> = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
<span class="kr">match</span> Forward input2 r <span class="kr">with</span>
| Some pp =&gt; Some (Select x :: pp)
| None =&gt; None
<span class="kr">end</span> = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk3d"><span class="nb">destruct</span> r <span class="kr">as</span> [| no12 output1]; <span class="nb">simpl</span>; <span class="kp">try</span> <span class="bp">discriminate</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: nil) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
<span class="kr">match</span> Forward input2 nil <span class="kr">with</span>
| Some pp =&gt; Some (Select x :: pp)
| None =&gt; None
<span class="kr">end</span> = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">intros</span> [= pval] v2; <span class="nb">rewrite</span> &lt;- pval, v2; <span class="nb">simpl</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk3e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (x :: xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk3f"><span class="nb">intros</span> p input2 output.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2, output</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward (x :: xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk40"><span class="nb">destruct</span> output <span class="kr">as</span> [| y r].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward (x :: xx :: rrest) nil = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) nil =
Some (p ++ p&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk41" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk41"><hr></label><div class="goal-conclusion">Forward (x :: xx :: rrest) (y :: r) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk42">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward (x :: xx :: rrest) nil = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) nil =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk43"><span class="nb">simpl</span> (Forward (x :: xx :: rrest) nil).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
| Some pp =&gt; Some (Select x :: Backspace :: pp)
| None =&gt; None
<span class="kr">end</span> = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) nil =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk44"><span class="nb">destruct</span> (Forward rrest nil) <span class="kr">as</span> [v |] <span class="nb">eqn</span>:vtl; <span class="kp">try</span> <span class="bp">discriminate</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>vtl</var><span class="hyp-type"><b>: </b><span>Forward rrest nil = Some v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: Backspace :: v) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) nil =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk45"><span class="nb">intros</span> [= pval] p&#39;val.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>vtl</var><span class="hyp-type"><b>: </b><span>Forward rrest nil = Some v</span></span></span><br><span><var>pval</var><span class="hyp-type"><b>: </b><span>Select x :: Backspace :: v = p</span></span></span><br><span><var>p'val</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) nil =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk46"><span class="nb">assert</span> (tmp := Ih2 _ _ _ vtl p&#39;val).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>vtl</var><span class="hyp-type"><b>: </b><span>Forward rrest nil = Some v</span></span></span><br><span><var>pval</var><span class="hyp-type"><b>: </b><span>Select x :: Backspace :: v = p</span></span></span><br><span><var>p'val</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>Forward (rrest ++ input2) nil = Some (v ++ p&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) nil =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk47"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>vtl</var><span class="hyp-type"><b>: </b><span>Forward rrest nil = Some v</span></span></span><br><span><var>pval</var><span class="hyp-type"><b>: </b><span>Select x :: Backspace :: v = p</span></span></span><br><span><var>p'val</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>Forward (rrest ++ input2) nil = Some (v ++ p&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> Forward (rrest ++ input2) nil <span class="kr">with</span>
| Some pp =&gt; Some (Select x :: Backspace :: pp)
| None =&gt; None
<span class="kr">end</span> = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk48"><span class="nb">rewrite</span> tmp, &lt;- pval.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>vtl</var><span class="hyp-type"><b>: </b><span>Forward rrest nil = Some v</span></span></span><br><span><var>pval</var><span class="hyp-type"><b>: </b><span>Select x :: Backspace :: v = p</span></span></span><br><span><var>p'val</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>Forward (rrest ++ input2) nil = Some (v ++ p&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: Backspace :: v ++ p&#39;) =
Some ((Select x :: Backspace :: v) ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk49">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward (x :: xx :: rrest) (y :: r) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk4a"><span class="nb">change</span> (Forward (x :: xx :: rrest) (y :: r)) <span class="kr">with</span>
        (<span class="kr">if</span> x =? y <span class="kr">then</span> <span class="kr">match</span> Forward (xx :: rrest) r <span class="kr">with</span>
                        | Some pp =&gt; Some (Select x :: pp)
                        | None =&gt; None <span class="kr">end</span>
         <span class="kr">else</span> <span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
              | Some pp =&gt; Some (Select x :: Backspace :: pp)
              | None =&gt; None
              <span class="kr">end</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> x =? y
 <span class="kr">then</span>
  <span class="kr">match</span> Forward (xx :: rrest) r <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: pp)
  | None =&gt; None
  <span class="kr">end</span>
 <span class="kr">else</span>
  <span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: Backspace :: pp)
  | None =&gt; None
  <span class="kr">end</span>) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk4b"><span class="nb">destruct</span> (Forward (xx :: rrest) r) <span class="kr">as</span> [vrest |] <span class="nb">eqn</span>:eqnrest.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> x =? y
 <span class="kr">then</span> Some (Select x :: vrest)
 <span class="kr">else</span>
  <span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: Backspace :: pp)
  | None =&gt; None
  <span class="kr">end</span>) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk4c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = None</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk4c"><hr></label><div class="goal-conclusion">(<span class="kr">if</span> x =? y
 <span class="kr">then</span> None
 <span class="kr">else</span>
  <span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: Backspace :: pp)
  | None =&gt; None
  <span class="kr">end</span>) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk4d">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> x =? y
 <span class="kr">then</span> Some (Select x :: vrest)
 <span class="kr">else</span>
  <span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: Backspace :: pp)
  | None =&gt; None
  <span class="kr">end</span>) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk4e"><span class="nb">destruct</span> (x =? y) <span class="nb">eqn</span>:xeqy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: vrest) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk4f"><hr></label><div class="goal-conclusion"><span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
| Some pp =&gt; Some (Select x :: Backspace :: pp)
| None =&gt; None
<span class="kr">end</span> = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk50">--</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: vrest) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk51"><span class="nb">intros</span> [= vp ] v2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br><span><var>vp</var><span class="hyp-type"><b>: </b><span>Select x :: vrest = p</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk52"><span class="nb">rewrite</span> &lt;- vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br><span><var>vp</var><span class="hyp-type"><b>: </b><span>Select x :: vrest = p</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some ((Select x :: vrest) ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk53"><span class="nb">clear</span> vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some ((Select x :: vrest) ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk54"><span class="nb">generalize</span> (Ih1 _ _ _ eqnrest v2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((xx :: rrest) ++ input2) r =
Some (vrest ++ p&#39;) -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some ((Select x :: vrest) ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk55"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> r <span class="kr">with</span>
| nil =&gt;
    <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
    | nil =&gt; None
    | _ :: rrest =&gt;
        <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
        | Some pp =&gt;
            Some (Select xx :: Backspace :: pp)
        | None =&gt; None
        <span class="kr">end</span>
    <span class="kr">end</span>
| y :: r0 =&gt;
    <span class="kr">if</span> xx =? y
    <span class="kr">then</span>
     <span class="kr">match</span> Forward (rrest ++ input2) r0 <span class="kr">with</span>
     | Some pp =&gt; Some (Select xx :: pp)
     | None =&gt; None
     <span class="kr">end</span>
    <span class="kr">else</span>
     <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
     | nil =&gt; None
     | _ :: rrest =&gt;
         <span class="kr">match</span> Forward rrest r <span class="kr">with</span>
         | Some pp =&gt;
             Some (Select xx :: Backspace :: pp)
         | None =&gt; None
         <span class="kr">end</span>
     <span class="kr">end</span>
<span class="kr">end</span> = Some (vrest ++ p&#39;) -&gt;
(<span class="kr">if</span> x =? y
 <span class="kr">then</span>
  <span class="kr">match</span>
    <span class="kr">match</span> r <span class="kr">with</span>
    | nil =&gt;
        <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
        | nil =&gt; None
        | _ :: rrest =&gt;
            <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
            | Some pp =&gt;
                Some (Select xx :: Backspace :: pp)
            | None =&gt; None
            <span class="kr">end</span>
        <span class="kr">end</span>
    | y :: r0 =&gt;
        <span class="kr">if</span> xx =? y
        <span class="kr">then</span>
         <span class="kr">match</span> Forward (rrest ++ input2) r0 <span class="kr">with</span>
         | Some pp =&gt; Some (Select xx :: pp)
         | None =&gt; None
         <span class="kr">end</span>
        <span class="kr">else</span>
         <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
         | nil =&gt; None
         | _ :: rrest =&gt;
             <span class="kr">match</span> Forward rrest r <span class="kr">with</span>
             | Some pp =&gt;
                 Some (Select xx :: Backspace :: pp)
             | None =&gt; None
             <span class="kr">end</span>
         <span class="kr">end</span>
    <span class="kr">end</span>
  <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: pp)
  | None =&gt; None
  <span class="kr">end</span>
 <span class="kr">else</span>
  <span class="kr">match</span> Forward (rrest ++ input2) (y :: r) <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: Backspace :: pp)
  | None =&gt; None
  <span class="kr">end</span>) = Some (Select x :: vrest ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk56"><span class="nb">rewrite</span> xeqy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> r <span class="kr">with</span>
| nil =&gt;
    <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
    | nil =&gt; None
    | _ :: rrest =&gt;
        <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
        | Some pp =&gt;
            Some (Select xx :: Backspace :: pp)
        | None =&gt; None
        <span class="kr">end</span>
    <span class="kr">end</span>
| y :: r0 =&gt;
    <span class="kr">if</span> xx =? y
    <span class="kr">then</span>
     <span class="kr">match</span> Forward (rrest ++ input2) r0 <span class="kr">with</span>
     | Some pp =&gt; Some (Select xx :: pp)
     | None =&gt; None
     <span class="kr">end</span>
    <span class="kr">else</span>
     <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
     | nil =&gt; None
     | _ :: rrest =&gt;
         <span class="kr">match</span> Forward rrest r <span class="kr">with</span>
         | Some pp =&gt;
             Some (Select xx :: Backspace :: pp)
         | None =&gt; None
         <span class="kr">end</span>
     <span class="kr">end</span>
<span class="kr">end</span> = Some (vrest ++ p&#39;) -&gt;
<span class="kr">match</span>
  <span class="kr">match</span> r <span class="kr">with</span>
  | nil =&gt;
      <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
      | nil =&gt; None
      | _ :: rrest =&gt;
          <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
          | Some pp =&gt;
              Some (Select xx :: Backspace :: pp)
          | None =&gt; None
          <span class="kr">end</span>
      <span class="kr">end</span>
  | y :: r0 =&gt;
      <span class="kr">if</span> xx =? y
      <span class="kr">then</span>
       <span class="kr">match</span> Forward (rrest ++ input2) r0 <span class="kr">with</span>
       | Some pp =&gt; Some (Select xx :: pp)
       | None =&gt; None
       <span class="kr">end</span>
      <span class="kr">else</span>
       <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
       | nil =&gt; None
       | _ :: rrest =&gt;
           <span class="kr">match</span> Forward rrest r <span class="kr">with</span>
           | Some pp =&gt;
               Some (Select xx :: Backspace :: pp)
           | None =&gt; None
           <span class="kr">end</span>
       <span class="kr">end</span>
  <span class="kr">end</span>
<span class="kr">with</span>
| Some pp =&gt; Some (Select x :: pp)
| None =&gt; None
<span class="kr">end</span> = Some (Select x :: vrest ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk57"><span class="nb">intros</span> it.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br><span><var>it</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> r <span class="kr">with</span>
| nil =&gt;
    <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
    | nil =&gt; None
    | _ :: rrest =&gt;
        <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
        | Some pp =&gt;
            Some (Select xx :: Backspace :: pp)
        | None =&gt; None
        <span class="kr">end</span>
    <span class="kr">end</span>
| y :: r0 =&gt;
    <span class="kr">if</span> xx =? y
    <span class="kr">then</span>
     <span class="kr">match</span> Forward (rrest ++ input2) r0 <span class="kr">with</span>
     | Some pp =&gt; Some (Select xx :: pp)
     | None =&gt; None
     <span class="kr">end</span>
    <span class="kr">else</span>
     <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
     | nil =&gt; None
     | _ :: rrest =&gt;
         <span class="kr">match</span> Forward rrest r <span class="kr">with</span>
         | Some pp =&gt;
             Some (Select xx :: Backspace :: pp)
         | None =&gt; None
         <span class="kr">end</span>
     <span class="kr">end</span>
<span class="kr">end</span> = Some (vrest ++ p&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  <span class="kr">match</span> r <span class="kr">with</span>
  | nil =&gt;
      <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
      | nil =&gt; None
      | _ :: rrest =&gt;
          <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
          | Some pp =&gt;
              Some (Select xx :: Backspace :: pp)
          | None =&gt; None
          <span class="kr">end</span>
      <span class="kr">end</span>
  | y :: r0 =&gt;
      <span class="kr">if</span> xx =? y
      <span class="kr">then</span>
       <span class="kr">match</span> Forward (rrest ++ input2) r0 <span class="kr">with</span>
       | Some pp =&gt; Some (Select xx :: pp)
       | None =&gt; None
       <span class="kr">end</span>
      <span class="kr">else</span>
       <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
       | nil =&gt; None
       | _ :: rrest =&gt;
           <span class="kr">match</span> Forward rrest r <span class="kr">with</span>
           | Some pp =&gt;
               Some (Select xx :: Backspace :: pp)
           | None =&gt; None
           <span class="kr">end</span>
       <span class="kr">end</span>
  <span class="kr">end</span>
<span class="kr">with</span>
| Some pp =&gt; Some (Select x :: pp)
| None =&gt; None
<span class="kr">end</span> = Some (Select x :: vrest ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk58"><span class="nb">rewrite</span> it.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br><span><var>it</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> r <span class="kr">with</span>
| nil =&gt;
    <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
    | nil =&gt; None
    | _ :: rrest =&gt;
        <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
        | Some pp =&gt;
            Some (Select xx :: Backspace :: pp)
        | None =&gt; None
        <span class="kr">end</span>
    <span class="kr">end</span>
| y :: r0 =&gt;
    <span class="kr">if</span> xx =? y
    <span class="kr">then</span>
     <span class="kr">match</span> Forward (rrest ++ input2) r0 <span class="kr">with</span>
     | Some pp =&gt; Some (Select xx :: pp)
     | None =&gt; None
     <span class="kr">end</span>
    <span class="kr">else</span>
     <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
     | nil =&gt; None
     | _ :: rrest =&gt;
         <span class="kr">match</span> Forward rrest r <span class="kr">with</span>
         | Some pp =&gt;
             Some (Select xx :: Backspace :: pp)
         | None =&gt; None
         <span class="kr">end</span>
     <span class="kr">end</span>
<span class="kr">end</span> = Some (vrest ++ p&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: vrest ++ p&#39;) =
Some (Select x :: vrest ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk59">--</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
| Some pp =&gt; Some (Select x :: Backspace :: pp)
| None =&gt; None
<span class="kr">end</span> = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk5a"><span class="nb">destruct</span> (Forward rrest (y :: r)) <span class="kr">as</span> [v |] <span class="nb">eqn</span>:eqnrrest;
             <span class="kp">try</span> <span class="bp">discriminate</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: Backspace :: v) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk5b"><span class="nb">intros</span> [= vp] v2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>vp</var><span class="hyp-type"><b>: </b><span>Select x :: Backspace :: v = p</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk5c"><span class="nb">rewrite</span> &lt;- vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>vp</var><span class="hyp-type"><b>: </b><span>Select x :: Backspace :: v = p</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some ((Select x :: Backspace :: v) ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk5d"><span class="nb">clear</span> vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some ((Select x :: Backspace :: v) ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk5e"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> x =? y
 <span class="kr">then</span>
  <span class="kr">match</span>
    <span class="kr">match</span> r <span class="kr">with</span>
    | nil =&gt;
        <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
        | nil =&gt; None
        | _ :: rrest =&gt;
            <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
            | Some pp =&gt;
                Some (Select xx :: Backspace :: pp)
            | None =&gt; None
            <span class="kr">end</span>
        <span class="kr">end</span>
    | y :: r0 =&gt;
        <span class="kr">if</span> xx =? y
        <span class="kr">then</span>
         <span class="kr">match</span> Forward (rrest ++ input2) r0 <span class="kr">with</span>
         | Some pp =&gt; Some (Select xx :: pp)
         | None =&gt; None
         <span class="kr">end</span>
        <span class="kr">else</span>
         <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
         | nil =&gt; None
         | _ :: rrest =&gt;
             <span class="kr">match</span> Forward rrest r <span class="kr">with</span>
             | Some pp =&gt;
                 Some (Select xx :: Backspace :: pp)
             | None =&gt; None
             <span class="kr">end</span>
         <span class="kr">end</span>
    <span class="kr">end</span>
  <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: pp)
  | None =&gt; None
  <span class="kr">end</span>
 <span class="kr">else</span>
  <span class="kr">match</span> Forward (rrest ++ input2) (y :: r) <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: Backspace :: pp)
  | None =&gt; None
  <span class="kr">end</span>) = Some (Select x :: Backspace :: v ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk5f"><span class="nb">rewrite</span> xeqy, (Ih2 _ _ _ eqnrrest v2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: Backspace :: v ++ p&#39;) =
Some (Select x :: Backspace :: v ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk60">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> x =? y
 <span class="kr">then</span> None
 <span class="kr">else</span>
  <span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: Backspace :: pp)
  | None =&gt; None
  <span class="kr">end</span>) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk61"><span class="nb">destruct</span> (x =? y) <span class="nb">eqn</span>:xeqy; <span class="kp">try</span> <span class="bp">discriminate</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = None</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
| Some pp =&gt; Some (Select x :: Backspace :: pp)
| None =&gt; None
<span class="kr">end</span> = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk62"><span class="nb">destruct</span> (Forward rrest (y :: r)) <span class="kr">as</span> [v |] <span class="nb">eqn</span>:eqnrrest;
          <span class="kp">try</span> <span class="bp">discriminate</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = None</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: Backspace :: v) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk63"><span class="nb">intros</span> [= vp] v2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = None</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>vp</var><span class="hyp-type"><b>: </b><span>Select x :: Backspace :: v = p</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk64"><span class="nb">rewrite</span> &lt;- vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = None</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>vp</var><span class="hyp-type"><b>: </b><span>Select x :: Backspace :: v = p</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some ((Select x :: Backspace :: v) ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk65"><span class="nb">clear</span> vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = None</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some ((Select x :: Backspace :: v) ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk66"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = None</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> x =? y
 <span class="kr">then</span>
  <span class="kr">match</span>
    <span class="kr">match</span> r <span class="kr">with</span>
    | nil =&gt;
        <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
        | nil =&gt; None
        | _ :: rrest =&gt;
            <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
            | Some pp =&gt;
                Some (Select xx :: Backspace :: pp)
            | None =&gt; None
            <span class="kr">end</span>
        <span class="kr">end</span>
    | y :: r0 =&gt;
        <span class="kr">if</span> xx =? y
        <span class="kr">then</span>
         <span class="kr">match</span> Forward (rrest ++ input2) r0 <span class="kr">with</span>
         | Some pp =&gt; Some (Select xx :: pp)
         | None =&gt; None
         <span class="kr">end</span>
        <span class="kr">else</span>
         <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
         | nil =&gt; None
         | _ :: rrest =&gt;
             <span class="kr">match</span> Forward rrest r <span class="kr">with</span>
             | Some pp =&gt;
                 Some (Select xx :: Backspace :: pp)
             | None =&gt; None
             <span class="kr">end</span>
         <span class="kr">end</span>
    <span class="kr">end</span>
  <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: pp)
  | None =&gt; None
  <span class="kr">end</span>
 <span class="kr">else</span>
  <span class="kr">match</span> Forward (rrest ++ input2) (y :: r) <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: Backspace :: pp)
  | None =&gt; None
  <span class="kr">end</span>) = Some (Select x :: Backspace :: v ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk67"><span class="nb">rewrite</span> xeqy, (Ih2 _ _ _ eqnrrest v2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>Ih2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward rrest output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (rrest ++ input2) output =
Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = None</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: Backspace :: v ++ p&#39;) =
Some (Select x :: Backspace :: v ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>A few comments on this solution:</p>
<ul class="simple">
<li><p>The code posted in the original function contains 3 recursive
calls, one where the argument is the immediate sublist (<span class="docutils literal">rest</span>)
and 2 where the argument is the second sublist (<span class="docutils literal">rest</span>). The
first one is handled by induction hypothesis <span class="docutils literal">Ih1</span> and the
other are handled by induction hypothesis <span class="docutils literal">Ih2</span>. For a reason I
have no time to investigate, my proof needs 4 uses of induction
hypotheses instead of 3. This means that there is probably some
duplication.</p></li>
<li><p>Sometimes, the <span class="docutils literal">simpl</span> tactic is too eager to unroll the
recursive definition until it can no longer do anything. To
counterbalance this bias of the <span class="docutils literal">simpl</span> tactic, I had to
perform one of the <em>unrolling steps</em> by hand, without relying on
<span class="docutils literal">simpl</span>. This unrolling step is performed by the <span class="docutils literal">change</span>
tactic call that appears in the middle of the script.</p></li>
<li><p>Everytime that there is a recursive call in your function, the
result is later analyzed by a <span class="docutils literal">match</span> construct. To account for
this, the proof perform case analysis on the results of recursive
calls and uses the <span class="docutils literal">destruct ... <span class="pre">eqn:...</span></span> variant of the
<span class="docutils literal">destruct</span> tactic to perform this analysis.</p></li>
<li><p>Aside from these advanced techniques, the proof is just guided by
the interaction with Coq.</p></li>
</ul>
<p>This proof script was verified with coq-8.15 with the <span class="docutils literal">List</span> and
<span class="docutils literal">ZArith</span> modules imported.</p>
</li>
<li><p>You can avoid constructing a tailored induction principle by
relying on much more powerful well founded induction. This will
give you a more general induction hypothesis, which can be used for
a much wider set of recursive arguments (even arguments that are
not structural subterms of the initial first list). Here is the
full script:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Wellfounded.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk68"><span class="kn">Lemma</span> <span class="nf">app_forward2</span> : <span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog) (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output</span> : list nat),
    Forward input1 output = Some p -&gt;
    Forward input2 nil = Some p&#39; -&gt;
    Forward (input1 ++ input2) output = Some (p ++ p&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog) (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward input1 output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (input1 ++ input2) output = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk69"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> <span class="nv">p&#39;</span> : prog) (<span class="nv">input1</span> <span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward input1 output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (input1 ++ input2) output = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk6a"><span class="nb">intros</span> p p&#39; input1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">input2</span> <span class="nv">output</span> : list nat,
Forward input1 output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (input1 ++ input2) output = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk6b"><span class="nb">revert</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward input1 output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (input1 ++ input2) output = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk6c"><span class="nb">induction</span> input1 <span class="kr">as</span> [input1 Ih]
                        <span class="nb">using</span>
                        (well_founded_ind
                           (wf_inverse_image (list nat) nat lt (@length nat) lt_wf)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length input1 -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward input1 output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (input1 ++ input2) output = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk6d"><span class="nb">destruct</span> input1 <span class="kr">as</span> [| x [| xx rrest]] <span class="nb">eqn</span>:input1eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = nil</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length nil -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward nil output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (nil ++ input2) output = Some (p ++ p&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk6e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: nil</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: nil) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk6e"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (x :: nil) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: nil) ++ input2) output = Some (p ++ p&#39;)</div></blockquote><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk6f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk6f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (x :: xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk70">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = nil</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length nil -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward nil output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (nil ++ input2) output = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk71"><span class="nb">intros</span> p input2 [| no1 output].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = nil</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length nil -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward nil nil = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (nil ++ input2) nil = Some (p ++ p&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk72" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = nil</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length nil -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>no1</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>output</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk72"><hr></label><div class="goal-conclusion">Forward nil (no1 :: output) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (nil ++ input2) (no1 :: output) =
Some (p ++ p&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk73">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = nil</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length nil -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward nil nil = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (nil ++ input2) nil = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk74"><span class="nb">intros</span> [= p_is_nil].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = nil</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length nil -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>p_is_nil</var><span class="hyp-type"><b>: </b><span>nil = p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward input2 nil = Some p&#39; -&gt;
Forward (nil ++ input2) nil = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk75"><span class="nb">rewrite</span> &lt;- p_is_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = nil</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length nil -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>p_is_nil</var><span class="hyp-type"><b>: </b><span>nil = p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward input2 nil = Some p&#39; -&gt;
Forward (nil ++ input2) nil = Some (nil ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk76"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = nil</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length nil -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>p_is_nil</var><span class="hyp-type"><b>: </b><span>nil = p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward input2 nil = Some p&#39; -&gt;
Forward input2 nil = Some p&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk77">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = nil</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length nil -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>no1</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>output</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward nil (no1 :: output) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (nil ++ input2) (no1 :: output) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">discriminate</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk78">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: nil</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: nil) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (x :: nil) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: nil) ++ input2) output = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk79"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: nil</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: nil) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
<span class="kr">match</span> output <span class="kr">with</span>
| nil =&gt; None
| y :: r =&gt;
    <span class="kr">if</span> x =? y
    <span class="kr">then</span>
     <span class="kr">match</span>
       <span class="kr">match</span> r <span class="kr">with</span>
       | nil =&gt; Some nil
       | _ :: _ =&gt; None
       <span class="kr">end</span>
     <span class="kr">with</span>
     | Some pp =&gt; Some (Select x :: pp)
     | None =&gt; None
     <span class="kr">end</span>
    <span class="kr">else</span> None
<span class="kr">end</span> = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
<span class="kr">match</span> output <span class="kr">with</span>
| nil =&gt;
    <span class="kr">match</span> input2 <span class="kr">with</span>
    | nil =&gt; None
    | _ :: rrest =&gt;
        <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
        | Some pp =&gt;
            Some (Select x :: Backspace :: pp)
        | None =&gt; None
        <span class="kr">end</span>
    <span class="kr">end</span>
| y :: r =&gt;
    <span class="kr">if</span> x =? y
    <span class="kr">then</span>
     <span class="kr">match</span> Forward input2 r <span class="kr">with</span>
     | Some pp =&gt; Some (Select x :: pp)
     | None =&gt; None
     <span class="kr">end</span>
    <span class="kr">else</span>
     <span class="kr">match</span> input2 <span class="kr">with</span>
     | nil =&gt; None
     | _ :: rrest =&gt;
         <span class="kr">match</span> Forward rrest output <span class="kr">with</span>
         | Some pp =&gt;
             Some (Select x :: Backspace :: pp)
         | None =&gt; None
         <span class="kr">end</span>
     <span class="kr">end</span>
<span class="kr">end</span> = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk7a"><span class="nb">destruct</span> output <span class="kr">as</span> [| y r]; <span class="nb">simpl</span>; <span class="kp">try</span> <span class="bp">discriminate</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: nil</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: nil) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> x =? y
 <span class="kr">then</span>
  <span class="kr">match</span>
    <span class="kr">match</span> r <span class="kr">with</span>
    | nil =&gt; Some nil
    | _ :: _ =&gt; None
    <span class="kr">end</span>
  <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: pp)
  | None =&gt; None
  <span class="kr">end</span>
 <span class="kr">else</span> None) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
(<span class="kr">if</span> x =? y
 <span class="kr">then</span>
  <span class="kr">match</span> Forward input2 r <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: pp)
  | None =&gt; None
  <span class="kr">end</span>
 <span class="kr">else</span>
  <span class="kr">match</span> input2 <span class="kr">with</span>
  | nil =&gt; None
  | _ :: rrest =&gt;
      <span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
      | Some pp =&gt; Some (Select x :: Backspace :: pp)
      | None =&gt; None
      <span class="kr">end</span>
  <span class="kr">end</span>) = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk7b"><span class="nb">destruct</span> (x =? y); <span class="kp">try</span> <span class="bp">discriminate</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: nil</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: nil) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  <span class="kr">match</span> r <span class="kr">with</span>
  | nil =&gt; Some nil
  | _ :: _ =&gt; None
  <span class="kr">end</span>
<span class="kr">with</span>
| Some pp =&gt; Some (Select x :: pp)
| None =&gt; None
<span class="kr">end</span> = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
<span class="kr">match</span> Forward input2 r <span class="kr">with</span>
| Some pp =&gt; Some (Select x :: pp)
| None =&gt; None
<span class="kr">end</span> = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk7c"><span class="nb">destruct</span> r <span class="kr">as</span> [| no12 output1]; <span class="nb">simpl</span>; <span class="kp">try</span> <span class="bp">discriminate</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: nil</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: nil) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: nil) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
<span class="kr">match</span> Forward input2 nil <span class="kr">with</span>
| Some pp =&gt; Some (Select x :: pp)
| None =&gt; None
<span class="kr">end</span> = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">intros</span> [= pval] v2; <span class="nb">rewrite</span> &lt;- pval, v2; <span class="nb">simpl</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk7d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward (x :: xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk7e"><span class="nb">intros</span> p input2 output.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2, output</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward (x :: xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk7f"><span class="nb">assert</span> (rrestlt : length rrest &lt; length (x :: xx :: rrest)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2, output</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length rrest &lt; length (x :: xx :: rrest)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk80" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2, output</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk80"><hr></label><div class="goal-conclusion">Forward (x :: xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk81">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2, output</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length rrest &lt; length (x :: xx :: rrest)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">simpl</span>; <span class="nb">auto with</span> arith.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk82">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2, output</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward (x :: xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk83"><span class="nb">assert</span> (restlt : length (xx :: rrest) &lt; length (x :: xx :: rrest)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2, output</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (xx :: rrest) &lt; length (x :: xx :: rrest)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk84" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2, output</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk84"><hr></label><div class="goal-conclusion">Forward (x :: xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk85">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2, output</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (xx :: rrest) &lt; length (x :: xx :: rrest)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">simpl</span>; <span class="nb">auto with</span> arith.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk86">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2, output</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward (x :: xx :: rrest) output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) output =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk87"><span class="nb">destruct</span> output <span class="kr">as</span> [| y r].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward (x :: xx :: rrest) nil = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) nil =
Some (p ++ p&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk88" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk88"><hr></label><div class="goal-conclusion">Forward (x :: xx :: rrest) (y :: r) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk89">--</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward (x :: xx :: rrest) nil = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) nil =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk8a"><span class="nb">simpl</span> (Forward (x :: xx :: rrest) nil).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
| Some pp =&gt; Some (Select x :: Backspace :: pp)
| None =&gt; None
<span class="kr">end</span> = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) nil =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk8b"><span class="nb">destruct</span> (Forward rrest nil) <span class="kr">as</span> [v |] <span class="nb">eqn</span>:vtl; <span class="kp">try</span> <span class="bp">discriminate</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>vtl</var><span class="hyp-type"><b>: </b><span>Forward rrest nil = Some v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: Backspace :: v) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) nil =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk8c"><span class="nb">intros</span> [= pval] p&#39;val.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>vtl</var><span class="hyp-type"><b>: </b><span>Forward rrest nil = Some v</span></span></span><br><span><var>pval</var><span class="hyp-type"><b>: </b><span>Select x :: Backspace :: v = p</span></span></span><br><span><var>p'val</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) nil =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk8d"><span class="nb">assert</span> (tmp := Ih _ rrestlt _ _ _ vtl p&#39;val).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>vtl</var><span class="hyp-type"><b>: </b><span>Forward rrest nil = Some v</span></span></span><br><span><var>pval</var><span class="hyp-type"><b>: </b><span>Select x :: Backspace :: v = p</span></span></span><br><span><var>p'val</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>Forward (rrest ++ input2) nil = Some (v ++ p&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) nil =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk8e"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>vtl</var><span class="hyp-type"><b>: </b><span>Forward rrest nil = Some v</span></span></span><br><span><var>pval</var><span class="hyp-type"><b>: </b><span>Select x :: Backspace :: v = p</span></span></span><br><span><var>p'val</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>Forward (rrest ++ input2) nil = Some (v ++ p&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> Forward (rrest ++ input2) nil <span class="kr">with</span>
| Some pp =&gt; Some (Select x :: Backspace :: pp)
| None =&gt; None
<span class="kr">end</span> = Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk8f"><span class="nb">rewrite</span> tmp, &lt;- pval.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>vtl</var><span class="hyp-type"><b>: </b><span>Forward rrest nil = Some v</span></span></span><br><span><var>pval</var><span class="hyp-type"><b>: </b><span>Select x :: Backspace :: v = p</span></span></span><br><span><var>p'val</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>Forward (rrest ++ input2) nil = Some (v ++ p&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: Backspace :: v ++ p&#39;) =
Some ((Select x :: Backspace :: v) ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk90">--</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward (x :: xx :: rrest) (y :: r) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk91"><span class="nb">change</span> (Forward (x :: xx :: rrest) (y :: r)) <span class="kr">with</span>
             (<span class="kr">if</span> x =? y <span class="kr">then</span> <span class="kr">match</span> Forward (xx :: rrest) r <span class="kr">with</span>
                             | Some pp =&gt; Some (Select x :: pp)
                             | None =&gt; None <span class="kr">end</span>
              <span class="kr">else</span> <span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
                   | Some pp =&gt; Some (Select x :: Backspace :: pp)
                   | None =&gt; None
                   <span class="kr">end</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> x =? y
 <span class="kr">then</span>
  <span class="kr">match</span> Forward (xx :: rrest) r <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: pp)
  | None =&gt; None
  <span class="kr">end</span>
 <span class="kr">else</span>
  <span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: Backspace :: pp)
  | None =&gt; None
  <span class="kr">end</span>) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk92"><span class="nb">destruct</span> (Forward (xx :: rrest) r) <span class="kr">as</span> [vrest |] <span class="nb">eqn</span>:eqnrest.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> x =? y
 <span class="kr">then</span> Some (Select x :: vrest)
 <span class="kr">else</span>
  <span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: Backspace :: pp)
  | None =&gt; None
  <span class="kr">end</span>) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk93" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = None</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk93"><hr></label><div class="goal-conclusion">(<span class="kr">if</span> x =? y
 <span class="kr">then</span> None
 <span class="kr">else</span>
  <span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: Backspace :: pp)
  | None =&gt; None
  <span class="kr">end</span>) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk94">++</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> x =? y
 <span class="kr">then</span> Some (Select x :: vrest)
 <span class="kr">else</span>
  <span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: Backspace :: pp)
  | None =&gt; None
  <span class="kr">end</span>) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk95"><span class="nb">destruct</span> (x =? y) <span class="nb">eqn</span>:xeqy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: vrest) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk96" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br></div><label class="goal-separator" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk96"><hr></label><div class="goal-conclusion"><span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
| Some pp =&gt; Some (Select x :: Backspace :: pp)
| None =&gt; None
<span class="kr">end</span> = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk97">**</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: vrest) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk98"><span class="nb">intros</span> [= vp] v2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br><span><var>vp</var><span class="hyp-type"><b>: </b><span>Select x :: vrest = p</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk99"><span class="nb">rewrite</span> &lt;- vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br><span><var>vp</var><span class="hyp-type"><b>: </b><span>Select x :: vrest = p</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some ((Select x :: vrest) ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk9a"><span class="nb">clear</span> vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some ((Select x :: vrest) ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                 </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk9b"><span class="nb">generalize</span> (Ih _ restlt _ _ _ eqnrest v2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((xx :: rrest) ++ input2) r =
Some (vrest ++ p&#39;) -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some ((Select x :: vrest) ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk9c"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> r <span class="kr">with</span>
| nil =&gt;
    <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
    | nil =&gt; None
    | _ :: rrest =&gt;
        <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
        | Some pp =&gt;
            Some (Select xx :: Backspace :: pp)
        | None =&gt; None
        <span class="kr">end</span>
    <span class="kr">end</span>
| y :: r0 =&gt;
    <span class="kr">if</span> xx =? y
    <span class="kr">then</span>
     <span class="kr">match</span> Forward (rrest ++ input2) r0 <span class="kr">with</span>
     | Some pp =&gt; Some (Select xx :: pp)
     | None =&gt; None
     <span class="kr">end</span>
    <span class="kr">else</span>
     <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
     | nil =&gt; None
     | _ :: rrest =&gt;
         <span class="kr">match</span> Forward rrest r <span class="kr">with</span>
         | Some pp =&gt;
             Some (Select xx :: Backspace :: pp)
         | None =&gt; None
         <span class="kr">end</span>
     <span class="kr">end</span>
<span class="kr">end</span> = Some (vrest ++ p&#39;) -&gt;
(<span class="kr">if</span> x =? y
 <span class="kr">then</span>
  <span class="kr">match</span>
    <span class="kr">match</span> r <span class="kr">with</span>
    | nil =&gt;
        <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
        | nil =&gt; None
        | _ :: rrest =&gt;
            <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
            | Some pp =&gt;
                Some (Select xx :: Backspace :: pp)
            | None =&gt; None
            <span class="kr">end</span>
        <span class="kr">end</span>
    | y :: r0 =&gt;
        <span class="kr">if</span> xx =? y
        <span class="kr">then</span>
         <span class="kr">match</span> Forward (rrest ++ input2) r0 <span class="kr">with</span>
         | Some pp =&gt; Some (Select xx :: pp)
         | None =&gt; None
         <span class="kr">end</span>
        <span class="kr">else</span>
         <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
         | nil =&gt; None
         | _ :: rrest =&gt;
             <span class="kr">match</span> Forward rrest r <span class="kr">with</span>
             | Some pp =&gt;
                 Some (Select xx :: Backspace :: pp)
             | None =&gt; None
             <span class="kr">end</span>
         <span class="kr">end</span>
    <span class="kr">end</span>
  <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: pp)
  | None =&gt; None
  <span class="kr">end</span>
 <span class="kr">else</span>
  <span class="kr">match</span> Forward (rrest ++ input2) (y :: r) <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: Backspace :: pp)
  | None =&gt; None
  <span class="kr">end</span>) = Some (Select x :: vrest ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                 </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk9d"><span class="nb">rewrite</span> xeqy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> r <span class="kr">with</span>
| nil =&gt;
    <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
    | nil =&gt; None
    | _ :: rrest =&gt;
        <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
        | Some pp =&gt;
            Some (Select xx :: Backspace :: pp)
        | None =&gt; None
        <span class="kr">end</span>
    <span class="kr">end</span>
| y :: r0 =&gt;
    <span class="kr">if</span> xx =? y
    <span class="kr">then</span>
     <span class="kr">match</span> Forward (rrest ++ input2) r0 <span class="kr">with</span>
     | Some pp =&gt; Some (Select xx :: pp)
     | None =&gt; None
     <span class="kr">end</span>
    <span class="kr">else</span>
     <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
     | nil =&gt; None
     | _ :: rrest =&gt;
         <span class="kr">match</span> Forward rrest r <span class="kr">with</span>
         | Some pp =&gt;
             Some (Select xx :: Backspace :: pp)
         | None =&gt; None
         <span class="kr">end</span>
     <span class="kr">end</span>
<span class="kr">end</span> = Some (vrest ++ p&#39;) -&gt;
<span class="kr">match</span>
  <span class="kr">match</span> r <span class="kr">with</span>
  | nil =&gt;
      <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
      | nil =&gt; None
      | _ :: rrest =&gt;
          <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
          | Some pp =&gt;
              Some (Select xx :: Backspace :: pp)
          | None =&gt; None
          <span class="kr">end</span>
      <span class="kr">end</span>
  | y :: r0 =&gt;
      <span class="kr">if</span> xx =? y
      <span class="kr">then</span>
       <span class="kr">match</span> Forward (rrest ++ input2) r0 <span class="kr">with</span>
       | Some pp =&gt; Some (Select xx :: pp)
       | None =&gt; None
       <span class="kr">end</span>
      <span class="kr">else</span>
       <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
       | nil =&gt; None
       | _ :: rrest =&gt;
           <span class="kr">match</span> Forward rrest r <span class="kr">with</span>
           | Some pp =&gt;
               Some (Select xx :: Backspace :: pp)
           | None =&gt; None
           <span class="kr">end</span>
       <span class="kr">end</span>
  <span class="kr">end</span>
<span class="kr">with</span>
| Some pp =&gt; Some (Select x :: pp)
| None =&gt; None
<span class="kr">end</span> = Some (Select x :: vrest ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk9e"><span class="nb">intros</span> it.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br><span><var>it</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> r <span class="kr">with</span>
| nil =&gt;
    <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
    | nil =&gt; None
    | _ :: rrest =&gt;
        <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
        | Some pp =&gt;
            Some (Select xx :: Backspace :: pp)
        | None =&gt; None
        <span class="kr">end</span>
    <span class="kr">end</span>
| y :: r0 =&gt;
    <span class="kr">if</span> xx =? y
    <span class="kr">then</span>
     <span class="kr">match</span> Forward (rrest ++ input2) r0 <span class="kr">with</span>
     | Some pp =&gt; Some (Select xx :: pp)
     | None =&gt; None
     <span class="kr">end</span>
    <span class="kr">else</span>
     <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
     | nil =&gt; None
     | _ :: rrest =&gt;
         <span class="kr">match</span> Forward rrest r <span class="kr">with</span>
         | Some pp =&gt;
             Some (Select xx :: Backspace :: pp)
         | None =&gt; None
         <span class="kr">end</span>
     <span class="kr">end</span>
<span class="kr">end</span> = Some (vrest ++ p&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  <span class="kr">match</span> r <span class="kr">with</span>
  | nil =&gt;
      <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
      | nil =&gt; None
      | _ :: rrest =&gt;
          <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
          | Some pp =&gt;
              Some (Select xx :: Backspace :: pp)
          | None =&gt; None
          <span class="kr">end</span>
      <span class="kr">end</span>
  | y :: r0 =&gt;
      <span class="kr">if</span> xx =? y
      <span class="kr">then</span>
       <span class="kr">match</span> Forward (rrest ++ input2) r0 <span class="kr">with</span>
       | Some pp =&gt; Some (Select xx :: pp)
       | None =&gt; None
       <span class="kr">end</span>
      <span class="kr">else</span>
       <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
       | nil =&gt; None
       | _ :: rrest =&gt;
           <span class="kr">match</span> Forward rrest r <span class="kr">with</span>
           | Some pp =&gt;
               Some (Select xx :: Backspace :: pp)
           | None =&gt; None
           <span class="kr">end</span>
       <span class="kr">end</span>
  <span class="kr">end</span>
<span class="kr">with</span>
| Some pp =&gt; Some (Select x :: pp)
| None =&gt; None
<span class="kr">end</span> = Some (Select x :: vrest ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chk9f"><span class="nb">rewrite</span> it.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = true</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br><span><var>it</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> r <span class="kr">with</span>
| nil =&gt;
    <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
    | nil =&gt; None
    | _ :: rrest =&gt;
        <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
        | Some pp =&gt;
            Some (Select xx :: Backspace :: pp)
        | None =&gt; None
        <span class="kr">end</span>
    <span class="kr">end</span>
| y :: r0 =&gt;
    <span class="kr">if</span> xx =? y
    <span class="kr">then</span>
     <span class="kr">match</span> Forward (rrest ++ input2) r0 <span class="kr">with</span>
     | Some pp =&gt; Some (Select xx :: pp)
     | None =&gt; None
     <span class="kr">end</span>
    <span class="kr">else</span>
     <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
     | nil =&gt; None
     | _ :: rrest =&gt;
         <span class="kr">match</span> Forward rrest r <span class="kr">with</span>
         | Some pp =&gt;
             Some (Select xx :: Backspace :: pp)
         | None =&gt; None
         <span class="kr">end</span>
     <span class="kr">end</span>
<span class="kr">end</span> = Some (vrest ++ p&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: vrest ++ p&#39;) =
Some (Select x :: vrest ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka0">**</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
| Some pp =&gt; Some (Select x :: Backspace :: pp)
| None =&gt; None
<span class="kr">end</span> = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka1"><span class="nb">destruct</span> (Forward rrest (y :: r)) <span class="kr">as</span> [v |] <span class="nb">eqn</span>:eqnrrest;
                   <span class="kp">try</span> <span class="bp">discriminate</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: Backspace :: v) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                 </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka2"><span class="nb">intros</span> [= vp] v2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>vp</var><span class="hyp-type"><b>: </b><span>Select x :: Backspace :: v = p</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka3"><span class="nb">rewrite</span> &lt;- vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>vp</var><span class="hyp-type"><b>: </b><span>Select x :: Backspace :: v = p</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some ((Select x :: Backspace :: v) ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka4"><span class="nb">clear</span> vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some ((Select x :: Backspace :: v) ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                 </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka5"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> x =? y
 <span class="kr">then</span>
  <span class="kr">match</span>
    <span class="kr">match</span> r <span class="kr">with</span>
    | nil =&gt;
        <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
        | nil =&gt; None
        | _ :: rrest =&gt;
            <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
            | Some pp =&gt;
                Some (Select xx :: Backspace :: pp)
            | None =&gt; None
            <span class="kr">end</span>
        <span class="kr">end</span>
    | y :: r0 =&gt;
        <span class="kr">if</span> xx =? y
        <span class="kr">then</span>
         <span class="kr">match</span> Forward (rrest ++ input2) r0 <span class="kr">with</span>
         | Some pp =&gt; Some (Select xx :: pp)
         | None =&gt; None
         <span class="kr">end</span>
        <span class="kr">else</span>
         <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
         | nil =&gt; None
         | _ :: rrest =&gt;
             <span class="kr">match</span> Forward rrest r <span class="kr">with</span>
             | Some pp =&gt;
                 Some (Select xx :: Backspace :: pp)
             | None =&gt; None
             <span class="kr">end</span>
         <span class="kr">end</span>
    <span class="kr">end</span>
  <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: pp)
  | None =&gt; None
  <span class="kr">end</span>
 <span class="kr">else</span>
  <span class="kr">match</span> Forward (rrest ++ input2) (y :: r) <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: Backspace :: pp)
  | None =&gt; None
  <span class="kr">end</span>) = Some (Select x :: Backspace :: v ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka6"><span class="nb">rewrite</span> xeqy, (Ih _ rrestlt _ _ _ eqnrrest v2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>vrest</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = Some vrest</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: Backspace :: v ++ p&#39;) =
Some (Select x :: Backspace :: v ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka7">++</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> x =? y
 <span class="kr">then</span> None
 <span class="kr">else</span>
  <span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: Backspace :: pp)
  | None =&gt; None
  <span class="kr">end</span>) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka8"><span class="nb">destruct</span> (x =? y) <span class="nb">eqn</span>:xeqy; <span class="kp">try</span> <span class="bp">discriminate</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = None</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> Forward rrest (y :: r) <span class="kr">with</span>
| Some pp =&gt; Some (Select x :: Backspace :: pp)
| None =&gt; None
<span class="kr">end</span> = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chka9"><span class="nb">destruct</span> (Forward rrest (y :: r)) <span class="kr">as</span> [v |] <span class="nb">eqn</span>:eqnrrest;
                <span class="kp">try</span> <span class="bp">discriminate</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = None</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: Backspace :: v) = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chkaa"><span class="nb">intros</span> [= vp] v2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = None</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>vp</var><span class="hyp-type"><b>: </b><span>Select x :: Backspace :: v = p</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some (p ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chkab"><span class="nb">rewrite</span> &lt;- vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = None</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>vp</var><span class="hyp-type"><b>: </b><span>Select x :: Backspace :: v = p</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some ((Select x :: Backspace :: v) ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chkac"><span class="nb">clear</span> vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = None</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forward ((x :: xx :: rrest) ++ input2) (y :: r) =
Some ((Select x :: Backspace :: v) ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chkad"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = None</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> x =? y
 <span class="kr">then</span>
  <span class="kr">match</span>
    <span class="kr">match</span> r <span class="kr">with</span>
    | nil =&gt;
        <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
        | nil =&gt; None
        | _ :: rrest =&gt;
            <span class="kr">match</span> Forward rrest nil <span class="kr">with</span>
            | Some pp =&gt;
                Some (Select xx :: Backspace :: pp)
            | None =&gt; None
            <span class="kr">end</span>
        <span class="kr">end</span>
    | y :: r0 =&gt;
        <span class="kr">if</span> xx =? y
        <span class="kr">then</span>
         <span class="kr">match</span> Forward (rrest ++ input2) r0 <span class="kr">with</span>
         | Some pp =&gt; Some (Select xx :: pp)
         | None =&gt; None
         <span class="kr">end</span>
        <span class="kr">else</span>
         <span class="kr">match</span> rrest ++ input2 <span class="kr">with</span>
         | nil =&gt; None
         | _ :: rrest =&gt;
             <span class="kr">match</span> Forward rrest r <span class="kr">with</span>
             | Some pp =&gt;
                 Some (Select xx :: Backspace :: pp)
             | None =&gt; None
             <span class="kr">end</span>
         <span class="kr">end</span>
    <span class="kr">end</span>
  <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: pp)
  | None =&gt; None
  <span class="kr">end</span>
 <span class="kr">else</span>
  <span class="kr">match</span> Forward (rrest ++ input2) (y :: r) <span class="kr">with</span>
  | Some pp =&gt; Some (Select x :: Backspace :: pp)
  | None =&gt; None
  <span class="kr">end</span>) = Some (Select x :: Backspace :: v ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use-v-chkae"><span class="nb">rewrite</span> xeqy, (Ih _ rrestlt _ _ _ eqnrrest v2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p'</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input1</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>x, xx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>rrest</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>input1eq</var><span class="hyp-type"><b>: </b><span>input1 = x :: xx :: rrest</span></span></span><br><span><var>Ih</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
length y &lt; length (x :: xx :: rrest) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : prog) (<span class="nv">input2</span> <span class="nv">output</span> : list nat),
Forward y output = Some p -&gt;
Forward input2 nil = Some p&#39; -&gt;
Forward (y ++ input2) output = Some (p ++ p&#39;)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>input2</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>rrestlt</var><span class="hyp-type"><b>: </b><span>length rrest &lt; length (x :: xx :: rrest)</span></span></span><br><span><var>restlt</var><span class="hyp-type"><b>: </b><span>length (xx :: rrest) &lt;
length (x :: xx :: rrest)</span></span></span><br><span><var>eqnrest</var><span class="hyp-type"><b>: </b><span>Forward (xx :: rrest) r = None</span></span></span><br><span><var>xeqy</var><span class="hyp-type"><b>: </b><span>(x =? y) = false</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>prog</span></span></span><br><span><var>eqnrrest</var><span class="hyp-type"><b>: </b><span>Forward rrest (y :: r) = Some v</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Forward input2 nil = Some p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (Select x :: Backspace :: v ++ p&#39;) =
Some (Select x :: Backspace :: v ++ p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>A careful scrutiny of the script for lemma <span class="docutils literal">app_forward2</span> shows
that the script is almost the same as for <span class="docutils literal">app_forward</span>. Three
main hints:</p>
<ul class="simple">
<li><p><span class="docutils literal">well_founded_induction</span> combined with <span class="docutils literal">wf_inverse_image</span>,
<span class="docutils literal">length</span> and <span class="docutils literal">lt_wf</span> gives a general induction hypothesis
that can be use for every case where <span class="docutils literal">input1</span> is replaced with
a list that is shorter in length.</p></li>
<li><p><span class="docutils literal">destruct input1</span> replaces every instance of <span class="docutils literal">input1</span> with a
variety of cases, including the instance that appears in the
induction hypothesis.</p></li>
<li><p>all calls to induction hypotheses <span class="docutils literal">Ih1</span> and <span class="docutils literal">Ih2</span> in the
previous solution have simply been replaced by calls to <span class="docutils literal">Ih</span>,
using hypotheses <span class="docutils literal">restlt</span> and <span class="docutils literal">rrestlt</span> to guarantee length
decrease.</p></li>
</ul>
</li>
</ol>
</section>
</div>
</main>
</div></body>
</html>
