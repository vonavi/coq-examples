<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Why does this Coq Definition fail? Coq Namespace error for Inductive Type</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="why-does-this-coq-definition-fail-coq-namespace-error-for-inductive-type">
<h1 class="title">Why does this Coq <span class="docutils literal">Definition</span> fail? Coq Namespace error for Inductive Type</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/71267447">https://stackoverflow.com/q/71267447</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>I have the following Inductive Type and a test function:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">parameter</span> : <span class="kt">Type</span> :=
| Nop
| OneP : <span class="kr">forall</span> <span class="nv">A</span>, A -&gt; parameter
| TwoP : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">r</span> : nat) (<span class="nv">b</span> : A), parameter.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-this-coq-definition-fail-coq-namespace-error-for-inductive-type-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-this-coq-definition-fail-coq-namespace-error-for-inductive-type-v-chk0"><span class="kn">Check</span> (TwoP nat <span class="mi">1</span> <span class="mi">5</span>).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">TwoP nat <span class="mi">1</span> <span class="mi">5</span>
     : parameter</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-this-coq-definition-fail-coq-namespace-error-for-inductive-type-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="why-does-this-coq-definition-fail-coq-namespace-error-for-inductive-type-v-chk1"><span class="kn">Definition</span> <span class="nf">test</span> (<span class="nv">p</span> : parameter) : option (nat * nat) :=
  <span class="kr">match</span> p <span class="kr">with</span>
  | TwoP nat x y =&gt; Some (x, y)
  | _ =&gt; None
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">In environment
p : parameter
nat : <span class="kt">Type</span>
x : Datatypes.nat
y : nat
The term <span class="s2">&quot;Some (x, y)&quot;</span> has type
 <span class="s2">&quot;option (Datatypes.nat * nat)&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type
 <span class="s2">&quot;option (Datatypes.nat * Datatypes.nat)&quot;</span>.</blockquote></div></div></small></span></pre><p>The test function fails with the error:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="why-does-this-coq-definition-fail-coq-namespace-error-for-inductive-type-v-chk2" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
In environment
p : parameter
nat : <span class="kt">Type</span>
x : Datatypes.nat
y : nat
The term <span class="s2">&quot;Some (x, y)&quot;</span> has type
 <span class="s2">&quot;option (Datatypes.nat * nat)&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type
 <span class="s2">&quot;option (Datatypes.nat * Datatypes.nat)&quot;</span>.</blockquote></div></div></small></span></pre><p>I don't understand why my definition does not work. Is there a
difference between <span class="docutils literal">nat</span> and <span class="docutils literal">Datatypes.nat</span>?</p>
</section>
<section id="answer">
<h2>Answer</h2>
<p>In Coq, it is not possible to test what a type is. Consider the
following program:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-this-coq-definition-fail-coq-namespace-error-for-inductive-type-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="why-does-this-coq-definition-fail-coq-namespace-error-for-inductive-type-v-chk3"><span class="kn">Definition</span> <span class="nf">is_nat</span> (<span class="nv">A</span> : <span class="kt">Type</span>) : bool :=
  <span class="kr">match</span> A <span class="kr">with</span>
  | nat =&gt; true
  | _   =&gt; false
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Pattern <span class="s2">&quot;_&quot;</span> <span class="kr">is</span> redundant <span class="kr">in</span> this clause.</blockquote></div></div></small></span></pre><p>If you try to run this, Coq tells you that the last branch is
redundant, and rejects the definition. The issue is that <span class="docutils literal">nat</span> is
taken to be a variable name, not the <span class="docutils literal">nat</span> data type from the
standard library. Therefore, the first branch matches every type
<span class="docutils literal">A</span>, and the last branch is redundant. In your example, the pattern
<span class="docutils literal">nat</span> ends up masking the data type <span class="docutils literal">nat</span>, which is why you end up
seeing the qualified name <span class="docutils literal">Datatypes.nat</span>.</p>
<p>One way of solving this issue is to use a type of <em>codes</em> instead of
<span class="docutils literal">Type</span>. For instance:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">type</span> : <span class="kt">Type</span> :=
| Bool
| Nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">type_denote</span> <span class="nv">t</span> : <span class="kt">Type</span> :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | Bool =&gt; bool
  | Nat =&gt; nat
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">type_denote</span> : type &gt;-&gt; <span class="kt">Sortclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">parameter</span> : <span class="kt">Type</span> :=
| Nop
| OneP : <span class="kr">forall</span> (<span class="nv">A</span> : type), A -&gt; parameter
| TwoP : <span class="kr">forall</span> (<span class="nv">A</span> : type) (<span class="nv">r</span> : nat) (<span class="nv">b</span> : A), parameter.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="why-does-this-coq-definition-fail-coq-namespace-error-for-inductive-type-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="why-does-this-coq-definition-fail-coq-namespace-error-for-inductive-type-v-chk4"><span class="kn">Check</span> (TwoP Nat <span class="mi">1</span> <span class="mi">5</span>).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">TwoP Nat <span class="mi">1</span> <span class="mi">5</span>
     : parameter</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">test</span> (<span class="nv">p</span> : parameter) : option (nat * nat) :=
  <span class="kr">match</span> p <span class="kr">with</span>
  | TwoP Nat x y =&gt; Some (x, y)
  | _ =&gt; None
  <span class="kr">end</span>.</span></span></pre><p>There are two issues with this solution. First, it requires you to
anticipate all types that you will need in <span class="docutils literal">parameter</span>, and add
those in the definition of <span class="docutils literal">type</span>. Second, it forces you to program
with dependent types, which can be hard to manipulate. It might be
possible to refactor your definitions to avoid the problem of type
matching altogether, although there is no one-size-fits-all solution
-- it depends on your application.</p>
</section>
</div>
</main>
</div></body>
</html>
