<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>Can one prove an equivalent to Forall_inv for heterogeneous lists in Coq?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq">
<h1 class="title">Can one prove an equivalent to Forall_inv for heterogeneous lists in Coq?</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/questions/59178484/can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq">https://stackoverflow.com/questions/59178484/can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>Following Adam Chlipala's <a class="reference external" href="http://adam.chlipala.net/cpdt/html/Cpdt.DataStruct.html#lab57">definition</a> of
heterogeneous lists, I wanted to define an equivalent of the
<tt class="docutils literal">Forall</tt> function on normal lists. This isn't too difficult, and you
end up with two constructors as usual. Now suppose that I know that a
fact is true about every element of a non-empty list. With normal
lists, I could use <tt class="docutils literal">Forall_inv</tt> and <tt class="docutils literal">Forall_inv_tail</tt> to assert
that it's true about the head and tail of the list.</p>
<p>I'd like to prove the equivalent for <tt class="docutils literal">hForall</tt> as defined below,
starting with the head case. Looking at the source in <a class="reference external" href="https://github.com/coq/coq/blob/master/theories/Lists/List.v">Lists/List.v</a>, the
proof for normal lists is easy and runs by inversion on <tt class="docutils literal">Forall (a ::
l)</tt>. The equivalent for my <tt class="docutils literal">hForall</tt> gives a mess of dependent
variables. Am I missing something obvious?</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">hlist</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">A</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">B</span> : A -&gt; <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">hlist</span> : list A -&gt; <span class="kt">Type</span> :=
  | HNil : hlist nil
  | HCons {a : A} {ls : list A} : B a -&gt; hlist ls -&gt; hlist (a :: ls).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">hForall</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">P</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">hForall</span> : <span class="kr">forall</span> {<span class="nv">As</span> : list A}, hlist <span class="kn">As</span> -&gt; <span class="kt">Prop</span> :=
    | hForall_nil : hForall HNil
    | hForall_cons {a : A} {ls : list A} (x : B a) (hl : hlist ls)
      : P a x -&gt; hForall hl -&gt; hForall (HCons x hl).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk0"><span class="kn">Lemma</span> <span class="nf">hForall_inv</span> (<span class="nv">a</span> : A) (<span class="nv">ls</span> : list A) (<span class="nv">x</span> : B a) (<span class="nv">hl</span> : hlist ls)
      : hForall (HCons x hl) -&gt; P a x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hForall (HCons x hl) -&gt; P a x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hForall (HCons x hl) -&gt; P a x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* Help! *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">hForall</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">hlist</span>.</span></span></pre></div>
<div class="section" id="answer">
<h1>Answer</h1>
<p>Inductives indexed by indexed types lead to that kind of difficulty.</p>
<p>Alternatively, consider defining <tt class="docutils literal">hForall</tt> as a <tt class="docutils literal">Fixpoint</tt>. Then
the inversion lemma follows by just unfolding the definition.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">hForall&#39;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">P</span> : <span class="kr">forall</span> <span class="nv">a</span>, B a -&gt; <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">hlist</span> : list A -&gt; <span class="kt">Type</span> :=
  | HNil : hlist nil
  | HCons {a : A} {ls : list A} : B a -&gt; hlist ls -&gt; hlist (a :: ls).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">hForall&#39;</span> {<span class="nv">As</span> : list A} (<span class="nv">hs</span> : hlist As) : <span class="kt">Prop</span> :=
    <span class="kr">match</span> hs <span class="kr">with</span>
    | HNil =&gt; <span class="kt">True</span>
    | HCons x js =&gt; P _ x /\ hForall&#39; js
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk2"><span class="kn">Lemma</span> <span class="nf">hForall&#39;_inv</span> (<span class="nv">a</span> : A) (<span class="nv">ls</span> : list A) (<span class="nv">x</span> : B a) (<span class="nv">hl</span> : hlist ls)
    : hForall&#39; (HCons x hl) -&gt; P a x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hForall&#39; (HCons x hl) -&gt; P a x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hForall&#39; (HCons x hl) -&gt; P a x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> []; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">hForall&#39;</span>.</span></span></pre><hr class="docutils" />
<div class="section" id="appendix">
<h2>Appendix</h2>
<p>Mostly for educational purposes, here's a few ways to prove that
inversion lemma for the original inductive definition of <tt class="docutils literal">hForall</tt>
(starting from the simpler to use).</p>
<p>One solution is the <tt class="docutils literal">dependent destruction</tt> tactic, which also
automatically handles heterogeneous equalities, as opposed to
<tt class="docutils literal">destruct</tt>. It is imported from the <tt class="docutils literal">Program</tt> module:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk4"><span class="kn">Require Import</span> Program.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Use of ‚Äú<span class="kn">Require</span>‚Äù <span class="kn">inside</span> a section <span class="kr">is</span> fragile. It <span class="kr">is</span>
not recommended to use this functionality <span class="kr">in</span> finished
proof scripts. [require-<span class="kr">in</span>-section,fragile]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk5"><span class="kn">Lemma</span> <span class="nf">hForall_inv</span> (<span class="nv">a</span> : A) (<span class="nv">ls</span> : list A) (<span class="nv">x</span> : B a) (<span class="nv">hl</span> : hlist ls)
  : hForall (HCons x hl) -&gt; P a x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hForall (HCons x hl) -&gt; P a x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hForall (HCons x hl) -&gt; P a x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk7"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hForall (HCons x hl)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk8"><span class="nb">dependent destruction</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P a x</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>hForall hl</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>The (minor) catch is that it uses some axioms about heterogeneous
equality:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk9"><span class="kn">Print Assumptions</span> hForall_inv.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Section</span> <span class="nf">Variables</span>:
P
: <span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span>
B
: A -&gt; <span class="kt">Type</span>
A
: <span class="kt">Type</span>
<span class="kn">Axioms</span>:
Eqdep.Eq_rect_eq.eq_rect_eq
  : <span class="kr">forall</span> (<span class="nv">U</span> : <span class="kt">Type</span>) (<span class="nv">p</span> : U) (<span class="nv">Q</span> : U -&gt; <span class="kt">Type</span>)
      (<span class="nv">x</span> : Q p) (<span class="nv">h</span> : p = p), x = eq_rect p Q x p h
JMeq_eq : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> <span class="nv">y</span> : A), x ~= y -&gt; x = y</blockquote></div></div></small></span></pre><p>With a little more knowledge of how <tt class="docutils literal">destruct</tt> works/dependent
pattern-matching, here's a proof without axioms.</p>
<p>There are some detailed explanations of dependent pattern-matching in
CPDT, but briefly the issue is that when we do
<tt class="docutils literal">destruct</tt>/<tt class="docutils literal">inversion</tt> on <tt class="docutils literal">hForall (HCons x hl)</tt>, the index
<tt class="docutils literal">HCons x hl</tt> gets generalized before the case-split, so you get a
nonsensical case where it is replaced with <tt class="docutils literal">HNil</tt>, and a second case
with a <em>different</em> index <tt class="docutils literal">HCons x0 hl0</tt>, and a good way of
remembering the (heterogeneous) equality across that generalization is
a research-grade problem. You wouldn't need to mess with heterogeneous
equalities if the goal just got rewritten with those variables, and
indeed you can refactor the goal so that it explicitly depends on
<tt class="docutils literal">HCons x hl</tt>, instead of <tt class="docutils literal">x</tt> and <tt class="docutils literal">hl</tt> separately, which will
then be generalized by <tt class="docutils literal">destruct</tt>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chka"><span class="kn">Lemma</span> <span class="nf">hForall_inv&#39;</span> (<span class="nv">a</span> : A) (<span class="nv">ls</span> : list A) (<span class="nv">x</span> : B a) (<span class="nv">hl</span> : hlist ls)
  : hForall (HCons x hl) -&gt; P a x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hForall (HCons x hl) -&gt; P a x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hForall (HCons x hl) -&gt; P a x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chkc"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hForall (HCons x hl)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chkd"><span class="nb">change</span> (<span class="kr">match</span> HCons x hl <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
          <span class="c">(* for some reason you have to explicitly annotate the</span>
<span class="c">             return type as Prop right here *)</span>
          | HNil =&gt; <span class="kt">True</span>
          | HCons x _ =&gt; P _ x
          <span class="kr">end</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hForall (HCons x hl)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> HCons x hl <span class="kr">with</span>
| HNil =&gt; <span class="kt">True</span>
| @HCons a0 _ x _ =&gt; P a0 x
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chke"><span class="nb">destruct</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls0</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>B a0</span></span></span><br><span><var>hl0</var><span class="hyp-type"><b>: </b><span>hlist ls0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P a0 x0</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>hForall hl0</span></span></span><br></div><label class="goal-separator" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chkf"><hr></label><div class="goal-conclusion">P a0 x0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk10">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> I.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* Replace [HCons x hl] with [HNil], the goal reduces to [True].</span>
<span class="c">     (This is an unreachable case.) *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk11">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls0</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>B a0</span></span></span><br><span><var>hl0</var><span class="hyp-type"><b>: </b><span>hlist ls0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P a0 x0</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>hForall hl0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a0 x0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* Or, directly writing down the proof term. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk12"><span class="kn">Restart</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hForall (HCons x hl) -&gt; P a x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk13"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hForall (HCons x hl)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq-v-chk14"><span class="nb">refine</span> (<span class="kr">match</span> H <span class="kr">in</span> @hForall <span class="kn">As</span> hs <span class="kr">return</span>
                <span class="kr">match</span> hs <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
                | HNil =&gt; <span class="kt">True</span>
                | HCons x _ =&gt; P _ x
                <span class="kr">end</span>
          <span class="kr">with</span>
          | hForall_nil =&gt; I
          | hForall_cons _ _ _ _ =&gt; _
          <span class="kr">end</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ls</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B a</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>hlist ls</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hForall (HCons x hl)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B a0</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hlist l</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a0 b</span></span></span><br><span><var>h0</var><span class="hyp-type"><b>: </b><span>hForall h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a0 b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>The Equations plugin probably automates that properly, but I haven't
tried.</p>
</div>
</div>
</div>
</div>
</div></body>
</html>
