<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>How can I automate counting within proofs in Coq?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="how-can-i-automate-counting-within-proofs-in-coq">
<h1 class="title">How can I automate counting within proofs in Coq?</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/42662141">https://stackoverflow.com/q/42662141</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>I have a function <span class="docutils literal">count</span> that counts how many times a given
predicate is provable when applied to elements of a list. It is
defined as follows:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">T</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">dec</span> : <span class="kr">forall</span> (<span class="nv">p</span> : T -&gt; <span class="kt">Prop</span>) (<span class="nv">w</span> : T), {p w} + {~ p w}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">count</span> (<span class="nv">p</span> : T -&gt; <span class="kt">Prop</span>) (<span class="nv">l</span> : list T) := <span class="kr">match</span> l <span class="kr">with</span>
  | nil =&gt; <span class="mi">0</span>
  | cons head tail =&gt; <span class="kr">if</span> dec p head <span class="kr">then</span> <span class="mi">1</span> + count p tail <span class="kr">else</span> count p tail
<span class="kr">end</span>.</span></span></pre><p>I then use this function to state lemmas like the following:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">q</span> : T -&gt; <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">Aa</span> : q a.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">Ab</span> : q b.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">Ac</span> : ~ q c.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chk0"><span class="kn">Lemma</span> <span class="nf">example</span> : count q (cons a (cons b (cons c nil))) = <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">count q (a :: b :: c :: nil) = <span class="mi">2</span></div></blockquote></div></div></small></span></pre><p>My proofs of such lemmas tend to be quite tedious:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">count q (a :: b :: c :: nil) = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chk2"><span class="nb">unfold</span> count.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> dec q a
 <span class="kr">then</span>
  <span class="mi">1</span> +
  (<span class="kr">if</span> dec q b
   <span class="kr">then</span> <span class="mi">1</span> + (<span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>)
   <span class="kr">else</span> <span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>)
 <span class="kr">else</span>
  <span class="kr">if</span> dec q b
  <span class="kr">then</span> <span class="mi">1</span> + (<span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>)
  <span class="kr">else</span> <span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>) = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chk3"><span class="nb">assert</span> (q a); [<span class="nb">apply</span> Aa | <span class="nb">auto</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> dec q a
 <span class="kr">then</span>
  <span class="mi">1</span> +
  (<span class="kr">if</span> dec q b
   <span class="kr">then</span> <span class="mi">1</span> + (<span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>)
   <span class="kr">else</span> <span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>)
 <span class="kr">else</span>
  <span class="kr">if</span> dec q b
  <span class="kr">then</span> <span class="mi">1</span> + (<span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>)
  <span class="kr">else</span> <span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>) = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chk4"><span class="nb">assert</span> (q b); [<span class="nb">apply</span> Ab | <span class="nb">auto</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>q a</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> dec q a
 <span class="kr">then</span>
  <span class="mi">1</span> +
  (<span class="kr">if</span> dec q b
   <span class="kr">then</span> <span class="mi">1</span> + (<span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>)
   <span class="kr">else</span> <span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>)
 <span class="kr">else</span>
  <span class="kr">if</span> dec q b
  <span class="kr">then</span> <span class="mi">1</span> + (<span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>)
  <span class="kr">else</span> <span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>) = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chk5"><span class="nb">assert</span> (~ q c); [<span class="nb">apply</span> Ac | <span class="nb">auto</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>q a</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>q b</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>~ q c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> dec q a
 <span class="kr">then</span>
  <span class="mi">1</span> +
  (<span class="kr">if</span> dec q b
   <span class="kr">then</span> <span class="mi">1</span> + (<span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>)
   <span class="kr">else</span> <span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>)
 <span class="kr">else</span>
  <span class="kr">if</span> dec q b
  <span class="kr">then</span> <span class="mi">1</span> + (<span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>)
  <span class="kr">else</span> <span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>) = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chk6"><span class="nb">destruct</span> (dec q a); [<span class="nb">auto</span> | <span class="bp">contradiction</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>q a</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>q b</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>~ q c</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> +
(<span class="kr">if</span> dec q b
 <span class="kr">then</span> <span class="mi">1</span> + (<span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>)
 <span class="kr">else</span> <span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>) = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chk7"><span class="nb">destruct</span> (dec q b); [<span class="nb">auto</span> | <span class="bp">contradiction</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>q a</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>q b</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>~ q c</span></span></span><br><span><var>q0</var><span class="hyp-type"><b>: </b><span>q a</span></span></span><br><span><var>q1</var><span class="hyp-type"><b>: </b><span>q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> + (<span class="mi">1</span> + (<span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>)) = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (dec q c); [<span class="bp">contradiction</span> | <span class="nb">auto</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>What can I do to automate such tedious proofs that involve computation
with my <span class="docutils literal">count</span> function?</p>
</section>
<section id="answer-zimm-i48">
<h2>Answer (Zimm i48)</h2>
<p>This is typically the kind of cases where you are better off proving
things by reflection. See how things go smoothly (of course I modified
a bit your example to avoid all these axioms):</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">count</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">p</span> : T -&gt; bool) (<span class="nv">l</span> : list T) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; <span class="mi">0</span>
  | h :: t =&gt; <span class="kr">if</span> p h <span class="kr">then</span> S (count p t) <span class="kr">else</span> (count p t)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">T</span> := a | b | c.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">q</span> <span class="nv">x</span> :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | a =&gt; true
  | b =&gt; true
  | c =&gt; false
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chk8"><span class="kn">Lemma</span> <span class="nf">example</span> : count q [a; b; c] = <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">count q [a; b; c] = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">count q [a; b; c] = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>I realize that your definition of <span class="docutils literal">count</span> was taking a propositional
predicate on type <span class="docutils literal">T</span> (but with the assumption that all predicates
on type <span class="docutils literal">T</span> are decidable) and instead I propose to define <span class="docutils literal">count</span>
to take a boolean predicate. But you may realize that having a
decidable propositional predicate or having a boolean predicate is
actually equivalent.</p>
<p>E.g. from your axioms, I can define a function which transform any
propositional predicate into a boolean one:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">T</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">dec</span> : <span class="kr">forall</span> (<span class="nv">p</span> : T -&gt; <span class="kt">Prop</span>) (<span class="nv">w</span> : T), {p w} + {~ p w}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">prop_to_bool_predicate</span> (<span class="nv">p</span> : T -&gt; <span class="kt">Prop</span>) (<span class="nv">x</span> : T) : bool :=
  <span class="kr">if</span> dec p x <span class="kr">then</span> true <span class="kr">else</span> false.</span></span></pre><p>Of course, because there are axioms involved in your example, it won't
actually be possible to compute with the boolean predicate. But I'm
assuming that you put all these axioms for the purpose of the example
and that your actual application doesn't have them.</p>
<section id="answer-to-your-comment">
<h3>Answer to your comment</h3>
<p>As I told you, as soon as you have defined some function in terms of
an axiom (or of a <a class="reference external" href="https://coq.inria.fr/refman/language/gallina-specification-language.html#coq:cmdv.parameter">Parameter</a>
since this is the same thing), there is no way you can compute with it
anymore.</p>
<p>However, here is a solution where the decidability of propositional
predicate <span class="docutils literal">p</span> is a lemma instead. I ended the proof of the lemma
with <a class="reference external" href="https://coq.inria.fr/refman/language/gallina-specification-language.html#coq:cmdv.defined">Defined</a>
instead of <a class="reference external" href="https://coq.inria.fr/refman/language/gallina-specification-language.html#coq:cmd.qed">Qed</a>
to allow computing with it (otherwise, it wouldn't be any better than
an axiom). As you can see I also redefined the <span class="docutils literal">count</span> function to
take a predicate and a proof of its decidability. The proof by
reflection still works in that case. There is no <span class="docutils literal">bool</span> but it is
strictly equivalent.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">count</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">p</span> : T -&gt; <span class="kt">Prop</span>)
         (<span class="nv">dec</span> : <span class="kr">forall</span> (<span class="nv">w</span>: T), {p w} + {~ p w}) (<span class="nv">l</span> : list T) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; <span class="mi">0</span>
  | h :: t =&gt; <span class="kr">if</span> dec h <span class="kr">then</span> S (count p dec t) <span class="kr">else</span> count p dec t
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">T</span> := a | b | c.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">p</span> <span class="nv">x</span> := <span class="kr">match</span> x <span class="kr">with</span> | a =&gt; <span class="kt">True</span> | b =&gt; <span class="kt">True</span> | c =&gt; <span class="kt">False</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chka"><span class="kn">Lemma</span> <span class="nf">dec_p</span> : <span class="kr">forall</span> (<span class="nv">w</span> : T), {p w} + {~ p w}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">w</span> : T, {p w} + {~ p w}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">w</span> : T, {p w} + {~ p w}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> []; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chkc"><span class="kn">Lemma</span> <span class="nf">example2</span>: count p dec_p [a; b; c] = <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">count p dec_p [a; b; c] = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">count p dec_p [a; b; c] = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></section>
</section>
<section id="answer-anton-trunov">
<h2>Answer (Anton Trunov)</h2>
<p>Let's create our custom hint database and add your axioms there:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chke"><span class="kn">Hint Resolve</span> Aa : axiom_db.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The default value <span class="kr">for</span> hint locality <span class="kr">is</span> currently
<span class="s2">&quot;local&quot;</span> <span class="kr">in</span> a section <span class="kn">and</span> <span class="s2">&quot;global&quot;</span> otherwise, but <span class="kr">is</span>
scheduled to <span class="nb">change</span> <span class="kr">in</span> a future release. For the <span class="kp">time</span>
being, adding hints <span class="kn">outside</span> of sections without
specifying an explicit locality <span class="kr">is</span> therefore
deprecated. It <span class="kr">is</span> recommended to use <span class="s2">&quot;export&quot;</span> whenever
possible.
[deprecated-hint-without-locality,deprecated]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chkf"><span class="kn">Hint Resolve</span> Ab : axiom_db.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The default value <span class="kr">for</span> hint locality <span class="kr">is</span> currently
<span class="s2">&quot;local&quot;</span> <span class="kr">in</span> a section <span class="kn">and</span> <span class="s2">&quot;global&quot;</span> otherwise, but <span class="kr">is</span>
scheduled to <span class="nb">change</span> <span class="kr">in</span> a future release. For the <span class="kp">time</span>
being, adding hints <span class="kn">outside</span> of sections without
specifying an explicit locality <span class="kr">is</span> therefore
deprecated. It <span class="kr">is</span> recommended to use <span class="s2">&quot;export&quot;</span> whenever
possible.
[deprecated-hint-without-locality,deprecated]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chk10"><span class="kn">Hint Resolve</span> Ac : axiom_db.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The default value <span class="kr">for</span> hint locality <span class="kr">is</span> currently
<span class="s2">&quot;local&quot;</span> <span class="kr">in</span> a section <span class="kn">and</span> <span class="s2">&quot;global&quot;</span> otherwise, but <span class="kr">is</span>
scheduled to <span class="nb">change</span> <span class="kr">in</span> a future release. For the <span class="kp">time</span>
being, adding hints <span class="kn">outside</span> of sections without
specifying an explicit locality <span class="kr">is</span> therefore
deprecated. It <span class="kr">is</span> recommended to use <span class="s2">&quot;export&quot;</span> whenever
possible.
[deprecated-hint-without-locality,deprecated]</blockquote></div></div></small></span></pre><p>Now, the <span class="docutils literal">firstorder</span> tactic can make use of the hint database:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chk11"><span class="kn">Lemma</span> <span class="nf">example</span> : count q (cons a (cons b (cons c nil))) = <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">count q (a :: b :: c :: nil) = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chk12"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">count q (a :: b :: c :: nil) = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-can-i-automate-counting-within-proofs-in-coq-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="how-can-i-automate-counting-within-proofs-in-coq-v-chk13"><span class="nb">unfold</span> count.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> dec q a
 <span class="kr">then</span>
  <span class="mi">1</span> +
  (<span class="kr">if</span> dec q b
   <span class="kr">then</span> <span class="mi">1</span> + (<span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>)
   <span class="kr">else</span> <span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>)
 <span class="kr">else</span>
  <span class="kr">if</span> dec q b
  <span class="kr">then</span> <span class="mi">1</span> + (<span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>)
  <span class="kr">else</span> <span class="kr">if</span> dec q c <span class="kr">then</span> <span class="mi">1</span> + <span class="mi">0</span> <span class="kr">else</span> <span class="mi">0</span>) = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (dec q a), (dec q b), (dec q c); <span class="nb">firstorder with</span> axiom_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><hr class="docutils" />
<p>We can automate our solution using the following piece of Ltac:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">solve_the_probem</span> :=
  <span class="kr">match goal with</span>
    |- <span class="kp">context</span> [<span class="kr">if</span> dec <span class="nl">?q</span> <span class="nl">?x</span> <span class="kr">then</span> _ <span class="kr">else</span> _] =&gt;
      <span class="nb">destruct</span> (dec q x);
      <span class="nb">firstorder with</span> axioms_db;
      solve_the_probem
  <span class="kr">end</span>.</span></span></pre><p>Then, <span class="docutils literal">unfold count; solve_the_probem.</span> will be able to prove the
lemma.</p>
</section>
</div>
</main>
</div></body>
</html>
