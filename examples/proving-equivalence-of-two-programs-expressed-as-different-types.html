<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Proving equivalence of two programs expressed as different types</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="proving-equivalence-of-two-programs-expressed-as-different-types">
<h1 class="title">Proving equivalence of two programs expressed as different types</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/68870467">https://stackoverflow.com/q/68870467</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>I understand how to prove equivalence of two programs when they're
represented in the same datatype, from the <a class="reference external" href="https://softwarefoundations.cis.upenn.edu/plf-current/Equiv.html">first chapter of PL
Foundations</a>.
We want to show that they step to the same value.</p>
<p>How does this work when programs are represented as <em>different</em> types,
with separate step relations, e.g. when a compiler translates an AST
into an SSA IR which conceptually behaves the same but executes
differently? Another example is a program and transition system, where
there is a correspondence between program reductions and transitions.</p>
<p>Here's what I've tried. There are two languages, <span class="docutils literal">imp1</span> and
<span class="docutils literal">imp2</span>, with e.g. just a single <span class="docutils literal">Skip</span> command. I figured a good
&quot;evaluation result&quot; would be a (finite, for now) trace of actions, to
allow for concurrency. There are (multi-)step relations defined for
both which allow a finite number of skips.</p>
<p>The problem is that in the final equivalence theorem, the behaviour of
<span class="docutils literal">imp1</span> tells me nothing about the behaviour of <span class="docutils literal">imp2</span>: given that
the <span class="docutils literal">imp1</span> program takes a <span class="docutils literal">Skip</span> step, I don't know anything
about the next step of <span class="docutils literal">imp2</span>.</p>
<p>This feels really silly but what am I missing? Does there need to be
some additional relation mapping single steps of <span class="docutils literal">imp1</span> to those of
<span class="docutils literal">imp2</span>? This feels too restrictive: what if one step of <span class="docutils literal">imp1</span>
corresponds to many steps of <span class="docutils literal">imp2</span> or vice versa? Any other
resources would be welcome!</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Strings.String.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Lists.List.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">imp1</span> : <span class="kt">Type</span> :=
| Skip1 : imp1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">imp2</span> : <span class="kt">Type</span> :=
| Skip2 : imp2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">action</span> :=
| A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">step1</span> : imp1 -&gt; imp1 -&gt; action -&gt; <span class="kt">Prop</span> :=
| SkipStep1 : step1 Skip1 Skip1 A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">step2</span> : imp2 -&gt; imp2 -&gt; action -&gt; <span class="kt">Prop</span> :=
| SkipStep2 : step2 Skip2 Skip2 A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trace</span> := list action.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">multi_step1</span> : imp1 -&gt; imp1 -&gt; trace -&gt; <span class="kt">Prop</span> :=
| step1_end : <span class="kr">forall</span> <span class="nv">l</span>, multi_step1 l l []
| step1_step : <span class="kr">forall</span> <span class="nv">i1</span> <span class="nv">i2</span> <span class="nv">i3</span> <span class="nv">a1</span> <span class="nv">a2</span>,
    step1 i1 i2 a1 -&gt; multi_step1 i2 i3 a2 -&gt; multi_step1 i1 i3 (a1 :: a2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">multi_step2</span> : imp2 -&gt; imp2 -&gt; trace -&gt; <span class="kt">Prop</span> :=
| step2_end : <span class="kr">forall</span> <span class="nv">l</span>, multi_step2 l l []
| step2_step : <span class="kr">forall</span> <span class="nv">i1</span> <span class="nv">i2</span> <span class="nv">i3</span> <span class="nv">a1</span> <span class="nv">a2</span>,
    step2 i1 i2 a1 -&gt; multi_step2 i2 i3 a2 -&gt; multi_step2 i1 i3 (a1 :: a2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">compile</span> (<span class="nv">i</span> : imp1) : imp2 :=
  <span class="kr">match</span> i <span class="kr">with</span>
  | Skip1 =&gt; Skip2
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk0"><span class="kn">Theorem</span> <span class="nf">equiv</span> :
  <span class="kr">forall</span> <span class="nv">t</span> <span class="nv">i1</span> <span class="nv">i2</span> <span class="nv">j1</span> <span class="nv">j2</span>,
    multi_step1 i1 i2 t -&gt; compile i1 = j1 -&gt; multi_step2 j1 j2 t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : trace) (<span class="nv">i1</span> <span class="nv">i2</span> : imp1) (<span class="nv">j1</span> <span class="nv">j2</span> : imp2),
multi_step1 i1 i2 t -&gt;
compile i1 = j1 -&gt; multi_step2 j1 j2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : trace) (<span class="nv">i1</span> <span class="nv">i2</span> : imp1) (<span class="nv">j1</span> <span class="nv">j2</span> : imp2),
multi_step1 i1 i2 t -&gt;
compile i1 = j1 -&gt; multi_step2 j1 j2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk2"><span class="nb">intros</span> t i1 i2 j1 j2 Hstep1 Hcomp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>i1, i2</var><span class="hyp-type"><b>: </b><span>imp1</span></span></span><br><span><var>j1, j2</var><span class="hyp-type"><b>: </b><span>imp2</span></span></span><br><span><var>Hstep1</var><span class="hyp-type"><b>: </b><span>multi_step1 i1 i2 t</span></span></span><br><span><var>Hcomp</var><span class="hyp-type"><b>: </b><span>compile i1 = j1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">multi_step2 j1 j2 t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk3"><span class="nb">inversion</span> Hstep1; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i2</var><span class="hyp-type"><b>: </b><span>imp1</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>imp2</span></span></span><br><span><var>Hstep1</var><span class="hyp-type"><b>: </b><span>multi_step1 i2 i2 []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">multi_step2 (compile i2) j2 []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i1, i2</var><span class="hyp-type"><b>: </b><span>imp1</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>imp2</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>action</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>Hstep1</var><span class="hyp-type"><b>: </b><span>multi_step1 i1 i2 (a1 :: a2)</span></span></span><br><span><var>i3</var><span class="hyp-type"><b>: </b><span>imp1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>step1 i1 i3 a1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>multi_step1 i3 i2 a2</span></span></span><br></div><label class="goal-separator" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk4"><hr></label><div class="goal-conclusion">multi_step2 (compile i1) j2 (a1 :: a2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i2</var><span class="hyp-type"><b>: </b><span>imp1</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>imp2</span></span></span><br><span><var>Hstep1</var><span class="hyp-type"><b>: </b><span>multi_step1 i2 i2 []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">multi_step2 (compile i2) j2 []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk6"><span class="nb">destruct</span> i2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>j2</var><span class="hyp-type"><b>: </b><span>imp2</span></span></span><br><span><var>Hstep1</var><span class="hyp-type"><b>: </b><span>multi_step1 Skip1 Skip1 []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">multi_step2 (compile Skip1) j2 []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk7"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>j2</var><span class="hyp-type"><b>: </b><span>imp2</span></span></span><br><span><var>Hstep1</var><span class="hyp-type"><b>: </b><span>multi_step1 Skip1 Skip1 []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">multi_step2 Skip2 j2 []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span></span></pre></section>
<section id="answer">
<h2>Answer</h2>
<p>The result you are trying to prove is a typical example of a
<em>simulation</em> between two transition systems. This case is simple
enough that you can prove it directly; the missing piece in your
attempt is that you need to do induction over the proof of execution:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk8"><span class="kn">Theorem</span> <span class="nf">equiv</span> :
  <span class="kr">forall</span> <span class="nv">t</span> <span class="nv">i1</span> <span class="nv">i2</span> <span class="nv">j1</span> <span class="nv">j2</span>,
    multi_step1 i1 i2 t -&gt; compile i1 = j1 -&gt; multi_step2 j1 j2 t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : trace) (<span class="nv">i1</span> <span class="nv">i2</span> : imp1) (<span class="nv">j1</span> <span class="nv">j2</span> : imp2),
multi_step1 i1 i2 t -&gt;
compile i1 = j1 -&gt; multi_step2 j1 j2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : trace) (<span class="nv">i1</span> <span class="nv">i2</span> : imp1) (<span class="nv">j1</span> <span class="nv">j2</span> : imp2),
multi_step1 i1 i2 t -&gt;
compile i1 = j1 -&gt; multi_step2 j1 j2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chka"><span class="nb">intros</span> t i1 i2 j1 j2 Hstep1 Hcomp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>i1, i2</var><span class="hyp-type"><b>: </b><span>imp1</span></span></span><br><span><var>j1, j2</var><span class="hyp-type"><b>: </b><span>imp2</span></span></span><br><span><var>Hstep1</var><span class="hyp-type"><b>: </b><span>multi_step1 i1 i2 t</span></span></span><br><span><var>Hcomp</var><span class="hyp-type"><b>: </b><span>compile i1 = j1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">multi_step2 j1 j2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chkb"><span class="nb">induction</span> Hstep1 <span class="kr">as</span> [i1|i1 i2 i3 a1 t1 Hstep1 _ IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>j1, j2</var><span class="hyp-type"><b>: </b><span>imp2</span></span></span><br><span><var>i1</var><span class="hyp-type"><b>: </b><span>imp1</span></span></span><br><span><var>Hcomp</var><span class="hyp-type"><b>: </b><span>compile i1 = j1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">multi_step2 j1 j2 []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>j1, j2</var><span class="hyp-type"><b>: </b><span>imp2</span></span></span><br><span><var>i1, i2, i3</var><span class="hyp-type"><b>: </b><span>imp1</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>action</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>Hstep1</var><span class="hyp-type"><b>: </b><span>step1 i1 i2 a1</span></span></span><br><span><var>Hcomp</var><span class="hyp-type"><b>: </b><span>compile i1 = j1</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>compile i2 = j1 -&gt; multi_step2 j1 j2 t1</span></span></span><br></div><label class="goal-separator" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chkc"><hr></label><div class="goal-conclusion">multi_step2 j1 j2 (a1 :: t1)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chkd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>j1, j2</var><span class="hyp-type"><b>: </b><span>imp2</span></span></span><br><span><var>i1</var><span class="hyp-type"><b>: </b><span>imp1</span></span></span><br><span><var>Hcomp</var><span class="hyp-type"><b>: </b><span>compile i1 = j1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">multi_step2 j1 j2 []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chke"><span class="nb">destruct</span> i1 <span class="kr">as</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>j1, j2</var><span class="hyp-type"><b>: </b><span>imp2</span></span></span><br><span><var>Hcomp</var><span class="hyp-type"><b>: </b><span>compile Skip1 = j1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">multi_step2 j1 j2 []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chkf"><span class="nb">simpl</span> <span class="kr">in</span> Hcomp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>j1, j2</var><span class="hyp-type"><b>: </b><span>imp2</span></span></span><br><span><var>Hcomp</var><span class="hyp-type"><b>: </b><span>Skip2 = j1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">multi_step2 j1 j2 []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk10"><span class="nb">subst</span> j1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>j2</var><span class="hyp-type"><b>: </b><span>imp2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">multi_step2 Skip2 j2 []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk11"><span class="nb">destruct</span> j2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">multi_step2 Skip2 Skip2 []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk12">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>j1, j2</var><span class="hyp-type"><b>: </b><span>imp2</span></span></span><br><span><var>i1, i2, i3</var><span class="hyp-type"><b>: </b><span>imp1</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>action</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>Hstep1</var><span class="hyp-type"><b>: </b><span>step1 i1 i2 a1</span></span></span><br><span><var>Hcomp</var><span class="hyp-type"><b>: </b><span>compile i1 = j1</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>compile i2 = j1 -&gt; multi_step2 j1 j2 t1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">multi_step2 j1 j2 (a1 :: t1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk13"><span class="nb">destruct</span> Hstep1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>j1, j2</var><span class="hyp-type"><b>: </b><span>imp2</span></span></span><br><span><var>i3</var><span class="hyp-type"><b>: </b><span>imp1</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>Hcomp</var><span class="hyp-type"><b>: </b><span>compile Skip1 = j1</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>compile Skip1 = j1 -&gt; multi_step2 j1 j2 t1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">multi_step2 j1 j2 (A :: t1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk14"><span class="nb">specialize</span> (IH Hcomp).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>j1, j2</var><span class="hyp-type"><b>: </b><span>imp2</span></span></span><br><span><var>i3</var><span class="hyp-type"><b>: </b><span>imp1</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>Hcomp</var><span class="hyp-type"><b>: </b><span>compile Skip1 = j1</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>multi_step2 j1 j2 t1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">multi_step2 j1 j2 (A :: t1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk15"><span class="nb">destruct</span> j1, j2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i3</var><span class="hyp-type"><b>: </b><span>imp1</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>Hcomp</var><span class="hyp-type"><b>: </b><span>compile Skip1 = Skip2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>multi_step2 Skip2 Skip2 t1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">multi_step2 Skip2 Skip2 (A :: t1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk16"><span class="nb">econstructor</span>; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i3</var><span class="hyp-type"><b>: </b><span>imp1</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>Hcomp</var><span class="hyp-type"><b>: </b><span>compile Skip1 = Skip2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>multi_step2 Skip2 Skip2 t1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">step2 Skip2 Skip2 A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>However, complex systems require more care. The general recipe looks
as follows:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk17"><span class="kn">Variables</span> <span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>. <span class="c">(* States of two transition systems *)</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Interpreting this declaration <span class="kr">as</span> <span class="kr">if</span> a <span class="kn">global</span>
declaration prefixed <span class="bp">by</span> <span class="s2">&quot;Local&quot;</span>, i.e. <span class="kr">as</span> a <span class="kn">global</span>
declaration which shall not be available without
qualification when imported. [local-declaration,scope]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk18"><span class="kn">Variable</span> <span class="nv">A</span> : <span class="kt">Type</span>. <span class="c">(* Actions *)</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Interpreting this declaration <span class="kr">as</span> <span class="kr">if</span> a <span class="kn">global</span>
declaration prefixed <span class="bp">by</span> <span class="s2">&quot;Local&quot;</span>, i.e. <span class="kr">as</span> a <span class="kn">global</span>
declaration which shall not be available without
qualification when imported. [local-declaration,scope]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Transitions *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk19"><span class="kn">Variable</span> <span class="nv">step1</span> : X -&gt; X -&gt; list A -&gt; <span class="kt">Prop</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Interpreting this declaration <span class="kr">as</span> <span class="kr">if</span> a <span class="kn">global</span>
declaration prefixed <span class="bp">by</span> <span class="s2">&quot;Local&quot;</span>, i.e. <span class="kr">as</span> a <span class="kn">global</span>
declaration which shall not be available without
qualification when imported. [local-declaration,scope]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk1a"><span class="kn">Variable</span> <span class="nv">step2</span> : Y -&gt; Y -&gt; list A -&gt; <span class="kt">Prop</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Interpreting this declaration <span class="kr">as</span> <span class="kr">if</span> a <span class="kn">global</span>
declaration prefixed <span class="bp">by</span> <span class="s2">&quot;Local&quot;</span>, i.e. <span class="kr">as</span> a <span class="kn">global</span>
declaration which shall not be available without
qualification when imported. [local-declaration,scope]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Compilation function *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk1b"><span class="kn">Variable</span> <span class="nv">compile</span> : X -&gt; Y.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Interpreting this declaration <span class="kr">as</span> <span class="kr">if</span> a <span class="kn">global</span>
declaration prefixed <span class="bp">by</span> <span class="s2">&quot;Local&quot;</span>, i.e. <span class="kr">as</span> a <span class="kn">global</span>
declaration which shall not be available without
qualification when imported. [local-declaration,scope]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Simulation relation; see below *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk1c"><span class="kn">Variable</span> <span class="nv">R</span> : X -&gt; Y -&gt; <span class="kt">Prop</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Interpreting this declaration <span class="kr">as</span> <span class="kr">if</span> a <span class="kn">global</span>
declaration prefixed <span class="bp">by</span> <span class="s2">&quot;Local&quot;</span>, i.e. <span class="kr">as</span> a <span class="kn">global</span>
declaration which shall not be available without
qualification when imported. [local-declaration,scope]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk1d"><span class="kn">Theorem</span> <span class="nf">forward_simulation</span> :
  <span class="kr">forall</span> <span class="nv">x1</span> <span class="nv">y1</span> <span class="nv">x2</span> <span class="nv">t</span>,
    R x1 y1 -&gt; step1 x1 x2 t -&gt; <span class="kr">exists</span> <span class="nv">y2</span>, step2 y1 y2 t /\ R x2 y2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x1</span> : X) (<span class="nv">y1</span> : Y) (<span class="nv">x2</span> : X) (<span class="nv">t</span> : list A),
R x1 y1 -&gt;
step1 x1 x2 t -&gt;
<span class="kr">exists</span> <span class="nv">y2</span> : Y, step2 y1 y2 t /\ R x2 y2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* ... *)</span>
</span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="proving-equivalence-of-two-programs-expressed-as-different-types-v-chk1e"><span class="kn">Theorem</span> <span class="nf">compilation_is_related</span> :
  <span class="kr">forall</span> <span class="nv">x</span>, R x (compile x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X, R x (compile x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* ... *)</span>
</span></pre><p>This differs from your example in two main ways. First, notice that
the result of the target execution is <em>existentially</em> quantified in
the conclusion -- it does not usually make sense to require <span class="docutils literal">y1</span> to
step to <em>any</em> <span class="docutils literal">y2</span> whatsoever.</p>
<p>Second, I have added a hypothesis saying that the starting states of
the two transition systems are related by some simulation relation
<span class="docutils literal">R</span>. This relation should intuitively express when a state <span class="docutils literal">y</span> of
the target system correctly represents a state <span class="docutils literal">x</span> of the source
system, in the sense that it can simulate its behavior.</p>
<p>Finding such a relation requires creativity. Sometimes, it is as
simple as saying that the target is the result of compiling the
source, as you did in your example. More often than not, however, you
need to generalize the relationship between the source and the target
to be able to relate arbitrary executions: the state that you get in
the target during execution might not be the result of compiling a
source state. Once you prove <span class="docutils literal">forward_simulation</span> and
<span class="docutils literal">compilation_is_related</span>, it should be easy to prove an analogue of
your correctness statement by induction on the multi-step execution
relation.</p>
<p>There are many variations on this basic pattern. For instance,
sometimes a step in the source is not simulated by a single step in
the target, but by multiple ones. Or you might need multiple steps in
the source before you can relate them to a single matching step at the
target.</p>
<p>To conclude, if you are proving the correctness of a compiler, you
might want to consider the opposite statement from the one you
mentioned; namely, that every behavior that you observe in the
compiled program can be explained by a matching source execution --
you certainly would not want the compiled program to exhibit some
behavior that is not allowed by the source language!</p>
<pre class="code coq literal-block"><code><span class="kn">Theorem</span> <span class="nf">compile_is_correct</span> <span class="o">:</span>
  <span class="kr">forall</span> <span class="nv">x1</span> <span class="nv">y1</span> <span class="nv">y2</span> <span class="nv">t</span><span class="o">,</span>
    <span class="n">compile</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">-&gt;</span> <span class="n">multi_step2</span> <span class="n">y1</span> <span class="n">y2</span> <span class="n">t</span> <span class="o">-&gt;</span>
    <span class="kr">exists</span> <span class="nv">x2</span><span class="o">,</span> <span class="n">multi_step1</span> <span class="n">x1</span> <span class="n">x2</span> <span class="n">t</span><span class="o">.</span></code></pre>
</section>
</div>
</main>
</div></body>
</html>
