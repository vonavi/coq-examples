<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Building up tree and decreasing argument of fix</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="building-up-tree-and-decreasing-argument-of-fix">
<h1 class="title">Building up tree and decreasing argument of fix</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/56132183">https://stackoverflow.com/q/56132183</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>I'm attempting to implement a function to build up a Braun tree with
<span class="docutils literal">n</span> elements using the following function in Coq, but Coq gives me
the error that it cannot guess decreasing argument of fix:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="building-up-tree-and-decreasing-argument-of-fix-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="building-up-tree-and-decreasing-argument-of-fix-v-chk0"><span class="kn">Fixpoint</span> <span class="nf">copy</span> (<span class="nv">x</span> : V) (<span class="nv">n</span> : nat) : BraunTree :=
  <span class="kr">let</span>
    <span class="nv">fix</span> <span class="nv">copy2</span> (<span class="nv">a</span> : V) (<span class="nv">i</span> : nat) : (BraunTree * BraunTree) :=
    <span class="kr">match</span> i <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; (T a E E, E)
    | _ =&gt; <span class="kr">match</span> Nat.odd i <span class="kr">with</span>
           | true =&gt; <span class="kr">let</span> <span class="nv">m</span> := (i - <span class="mi">1</span>) / <span class="mi">2</span> <span class="kr">in</span>
                     <span class="kr">let</span> (<span class="nv">s</span>,t) := copy2 a m <span class="kr">in</span>
                     (T a s t, T a t t)
           | false =&gt; <span class="kr">let</span> <span class="nv">m</span> := (i - <span class="mi">2</span>) / <span class="mi">2</span> <span class="kr">in</span>
                      <span class="kr">let</span> (<span class="nv">s</span>, t) := copy2 a m <span class="kr">in</span>
                      (T a s s, T a s t)
           <span class="kr">end</span>
    <span class="kr">end</span>
  <span class="kr">in</span>
  <span class="kr">match</span> copy2 x n <span class="kr">with</span>
  | (_, snd) =&gt; snd
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Cannot guess decreasing argument of <span class="kr">fix</span>.</blockquote></div></div></small></span></pre><p>I know that it is not the separate even and odd cases that is the
problem because it gave the same error when I removed the even/odd
cases:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="building-up-tree-and-decreasing-argument-of-fix-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="building-up-tree-and-decreasing-argument-of-fix-v-chk1"><span class="kn">Fixpoint</span> <span class="nf">copy</span> (<span class="nv">x</span> : V) (<span class="nv">n</span> : nat) : BraunTree :=
  <span class="kr">let</span>
    <span class="nv">fix</span> <span class="nv">copy2</span> (<span class="nv">a</span> : V) (<span class="nv">i</span> : nat) : (BraunTree * BraunTree) :=
    <span class="kr">match</span> i <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; (T a E E, E)
    | _ =&gt; <span class="kr">let</span> <span class="nv">m</span> := (i - <span class="mi">1</span>) / <span class="mi">2</span> <span class="kr">in</span>
           <span class="kr">let</span> (<span class="nv">s</span>, t) := copy2 a m <span class="kr">in</span>
           (T a s t, T a t t)
    <span class="kr">end</span>
  <span class="kr">in</span>
  <span class="kr">match</span> copy2 x n <span class="kr">with</span>
  | (_, snd) =&gt; snd
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Cannot guess decreasing argument of <span class="kr">fix</span>.</blockquote></div></div></small></span></pre><p>How can I convince Coq that i is in fact a decreasing argument?</p>
<p><strong>EDIT</strong> Type of <span class="docutils literal">BraunTree</span>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">BraunTree</span> : <span class="kt">Type</span> :=
| E : BraunTree
| T : V -&gt; BraunTree -&gt; BraunTree -&gt; BraunTree.</span></span></pre></section>
<section id="answer">
<h2>Answer</h2>
<p><span class="docutils literal">Fixpoint</span>/<span class="docutils literal">fix</span> only allows recursive calls on a <em>syntactically</em>
smaller argument.</p>
<pre class="code coq literal-block"><code><span class="kn">Fixpoint</span> <span class="nf">example</span> <span class="o">(</span><span class="nv">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">...</span> <span class="c">(* There must be a match on [n] somewhere *)</span>
    <span class="o">...</span> <span class="kr">match</span> <span class="n">n</span> <span class="kr">with</span>
        <span class="o">|</span> <span class="n">O</span> <span class="o">=&gt;</span> <span class="n">base_case</span> <span class="c">(* no recursive call allowed *)</span>
        <span class="o">|</span> <span class="n">S</span> <span class="n">m</span> <span class="o">=&gt;</span>
          <span class="o">...</span> <span class="o">(</span><span class="n">example</span> <span class="n">m</span><span class="o">)</span>
          <span class="c">(* We can only call [example] on [m], or some even
             smaller value obtained by matching on [m] *)</span>
        <span class="kr">end</span> <span class="o">...</span></code></pre>
<p>In particular, it's not allowed to make a recursive call on a value
obtained via some arbitrary function (in this case, <span class="docutils literal">div</span> and
<span class="docutils literal">sub</span> in <span class="docutils literal">copy2 a ((i - 1) / 2)</span>).</p>
<p>Here are three options:</p>
<ol class="arabic simple">
<li><p>Pick another representation of natural numbers so that
pattern-matching on it naturally decomposes into the different
branches of the desired definition (base case (zero), even, odd).</p></li>
<li><p>Use the fact that the recursion depth is actually bounded by <span class="docutils literal">n</span>,
so we can use <span class="docutils literal">n</span> as &quot;fuel&quot;, which we know will not actually
deplete before we are done.</p></li>
<li><p>Cunningly extract a subterm of the decreasing argument to make the
recursive call. This solution is less general and robust than the
previous ones; it's a much harder fight against the termination
checker.</p></li>
</ol>
<hr class="docutils" />
<section id="alternative-representation">
<h3>Alternative representation</h3>
<p>We have three cases: zero, even, and odd. Luckily the standard library
has a type with almost the same structure, <span class="docutils literal">positive</span>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">positive</span> :=    <span class="c">(* p &gt; 0 *)</span>
| xH                     <span class="c">(* 1 *)</span>
| xI (p : positive)      <span class="c">(* 2p + 1 *)</span>
| xO (p : positive).     <span class="c">(* 2p     *)</span></span></span></pre><p>Pointing the type <span class="docutils literal">positive</span> with an additional zero, we get <span class="docutils literal">N</span>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">N</span> :=
| N0                      <span class="c">(* 0 *)</span>
| Npos (p : positive).    <span class="c">(* p &gt; 0 *)</span></span></span></pre><p>There is also a conversion function <span class="docutils literal">N.of_nat : nat <span class="pre">-&gt;</span> N</span>, although
it might also be a good idea to use <span class="docutils literal">N</span> everywhere instead of
<span class="docutils literal">nat</span>, if the conversions become too annoying.</p>
<p>The final definition starts by case analysis on <span class="docutils literal">N</span>, and the case
revealing a <span class="docutils literal">positive</span> number is handled with a <span class="docutils literal">fix</span>-point, where
the base case is <span class="docutils literal">1</span> instead of <span class="docutils literal">0</span>. We have to shift some
details, because the even case is <span class="docutils literal">2p</span> instead of <span class="docutils literal">2p + 2</span>, so
instead of a pair of trees of size <span class="docutils literal">(i+1, i)</span> we have to do <span class="docutils literal"><span class="pre">(i-1,</span> i)</span>. But overall the recursive cases still naturally match an
informal specification:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> NArith PArith.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">V</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">BraunTree</span> : <span class="kt">Type</span> :=
| E : BraunTree
| T : V -&gt; BraunTree -&gt; BraunTree -&gt; BraunTree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">copy</span> (<span class="nv">x</span> : V) (<span class="nv">n</span> : N) : BraunTree :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | N0 =&gt; E
  | Npos p =&gt;
    <span class="kr">let</span>
      (* copy2 a i : a tree of (i-<span class="mi">1</span>) copies of a, and another of i
         copies of a *)
      <span class="nv">fix</span> <span class="nv">copy2</span> (<span class="nv">a</span> : V) (<span class="nv">i</span> : positive) : (BraunTree * BraunTree) :=
      <span class="kr">match</span> i <span class="kr">with</span>
      | xH =&gt; <span class="c">(* i = 1 *)</span>
        (E, T a E E)
      | xI p =&gt; <span class="c">(* i = 2p + 1 *)</span>
        <span class="kr">let</span> (<span class="nv">s</span>, t) := copy2 a p <span class="kr">in</span>
        (T a t s, T a t t)
      | xO p =&gt; <span class="c">(* i = 2p *)</span>
        <span class="kr">let</span> (<span class="nv">s</span>, t) := copy2 a p <span class="kr">in</span>
          (T a s s, T a t s)
      <span class="kr">end</span>
    <span class="kr">in</span>
    <span class="kr">match</span> copy2 x p <span class="kr">with</span>
    | (_, snd) =&gt; snd
    <span class="kr">end</span>
  <span class="kr">end</span>.</span></span></pre></section>
<hr class="docutils" />
<section id="just-enough-fuel">
<h3>Just enough fuel</h3>
<p>We add fuel to the <span class="docutils literal">fix</span> as the decreasing argument. We can only run
out if <span class="docutils literal">n = i = 0</span>, so we know what the result should be then.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* note: This doesn&#39;t need to be a Fixpoint *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">copy</span> (<span class="nv">x</span> : V) (<span class="nv">n</span> : nat) : BraunTree :=
  <span class="kr">let</span>
    <span class="nv">fix</span> <span class="nv">copy2</span> (<span class="nv">a</span> : V) (<span class="nv">n</span> : nat) (<span class="nv">i</span> : nat) : (BraunTree * BraunTree) :=
    <span class="kr">match</span> n <span class="kr">with</span>
    | O =&gt; (T a E E, E)
    | S n&#39; =&gt;
      <span class="kr">match</span> i <span class="kr">with</span>
      | O =&gt; (T a E E, E)
      | _ =&gt;
        <span class="kr">if</span> Nat.odd i <span class="kr">then</span>
          <span class="kr">let</span> <span class="nv">m</span> := div2 ((i - <span class="mi">1</span>) / <span class="mi">2</span>) <span class="kr">in</span>
          <span class="kr">let</span> (<span class="nv">s</span>, t) := copy2 a n&#39; m <span class="kr">in</span>
          (T a s t, T a t t)
        <span class="kr">else</span>
          <span class="kr">let</span> <span class="nv">m</span> := div2 ((i - <span class="mi">2</span>) / <span class="mi">2</span>) <span class="kr">in</span>
          <span class="kr">let</span> (<span class="nv">s</span>, t) := copy2 a n&#39; m <span class="kr">in</span>
          (T a s s, T a s t)
      <span class="kr">end</span>
    <span class="kr">end</span>
  <span class="kr">in</span>
  <span class="kr">match</span> copy2 x n n <span class="kr">with</span>
  | (_, snd) =&gt; snd
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span></pre><p>This works nicely when:</p>
<ul class="simple">
<li><p>we can compute the amount of fuel needed;</p></li>
<li><p>and there is a predictable answer to give when we run out of fuel.</p></li>
</ul>
<p>If either of those assumption does <em>not</em> hold, we need to litter our
code with <span class="docutils literal">option</span>.</p>
</section>
<hr class="docutils" />
<section id="nested-recursion">
<h3>Nested recursion</h3>
<p>As mentioned earlier, Coq has strict rules about decreasing arguments.
The usual explanation is that we can only make a recursive call on a
subterm obtained through pattern-matching on the decreasing argument
(or transitively, one of its subterms).</p>
<p>One apparent restriction is that, because the condition is syntactic
(i.e., Coq looks at the definition to track the provenance of the
decreasing argument), the argument <span class="docutils literal">n</span> can only decrease by a
constant at most (constant with respect to <span class="docutils literal">n</span>), since there are
only finitely many <span class="docutils literal">match</span> in a definition. In particular, there is
no way to make a recursive call on the result of a division by two, as
that represents a decrease by <span class="docutils literal">n/2</span>, a value linear in <span class="docutils literal">n</span>.</p>
<p>For better or for worse, Coq's termination criterion is actually a bit
smarter than that: one can pass the decreasing argument to a nested
fixpoint, and the &quot;subterm&quot; relation will be tracked through it.</p>
<section id="cons-free-division">
<h4>Cons-free division</h4>
<p>And indeed, the division of a Peano <span class="docutils literal">nat</span> can be defined in such a
way that Coq can tell that the result is a subterm of the dividend:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">div2</span> (<span class="nv">n</span> : nat) :=
  <span class="kr">let fix</span> <span class="nv">d2</span> (<span class="nv">n1</span> : nat) (<span class="nv">n2</span> : nat) {<span class="nv">struct</span> <span class="nv">n1</span>} :=
      <span class="kr">match</span> n2 <span class="kr">with</span>
      | S (S n2&#39;) =&gt;
        <span class="kr">match</span> n1 <span class="kr">with</span>
        | O =&gt; n1
        | S n1&#39; =&gt; d2 n1&#39; n2&#39;
        <span class="kr">end</span>
      | _ =&gt; n1
      <span class="kr">end</span>
  <span class="kr">in</span> d2 n n.</span></span></pre><p>The idea is to write a <span class="docutils literal">fix</span>-point of two arguments (somewhat like
the fuel solution), which start out equal (<span class="docutils literal">d2 n n</span>), and we remove
<strong>two</strong> <span class="docutils literal">S</span> constructors from one (<span class="docutils literal">n2</span>) of them for every <strong>one</strong>
<span class="docutils literal">S</span> we remove from the other (<span class="docutils literal">n1</span>). Important details:</p>
<ul class="simple">
<li><p>In all the non-recursing cases, we return <span class="docutils literal">n1</span> (and <em>not</em> <span class="docutils literal">0</span> in
any case), which is then guaranteed to be a subterm of the topmost
<span class="docutils literal">n</span>.</p></li>
<li><p>And the function must be decreasing in <span class="docutils literal">n1</span> (the term we return),
rather than <span class="docutils literal">n2</span> (Coq only keeps track of subterms of decreasing
arguments).</p></li>
</ul>
<p>All that ensures that <span class="docutils literal">div2 n</span> is a subterm of <span class="docutils literal">n</span> (not a <em>strict
subterm</em> (or <em>proper subterm</em>), because <span class="docutils literal">n</span> could be <span class="docutils literal">O</span>).</p>
<p>This has similarities to the previous fuel-based solution, but here
the decreasing argument is a lot more relevant than just a device to
trick the type checker.</p>
<p>This technique is a variant of <em>cons-free programming</em>. (Note though
that the constraints are not quite the same as what is discussed in
the literature, for example when the focus is on avoiding <em>memory
allocations</em> rather than ensuring <em>termination</em> by structural
well-foundedness.)</p>
</section>
<section id="conclusion-definition-of-copy">
<h4>Conclusion: definition of <span class="docutils literal">copy</span></h4>
<p>Once we have <span class="docutils literal">div2</span>, we can define <span class="docutils literal">copy</span> with a few tweaks to
obtain <span class="docutils literal"><span class="pre">i-1</span></span> and <span class="docutils literal"><span class="pre">i-2</span></span> as <em>proper subterms</em> of <span class="docutils literal">i</span>, again by
pattern-matching. Below, <span class="docutils literal">i'</span> and <span class="docutils literal">i''</span> are proper subterms of
<span class="docutils literal">i</span> (by visual inspection), and <span class="docutils literal">div2 i'</span> and <span class="docutils literal">div2 i''</span> are
subterms of <span class="docutils literal">i'</span> and <span class="docutils literal">i''</span> (by the definition of <span class="docutils literal">div2</span>). By
transitivity they are proper subterms of <span class="docutils literal">i</span>, so the termination
checker accepts.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">copy</span> (<span class="nv">x</span> : V) (<span class="nv">n</span> : nat) : BraunTree :=
  <span class="kr">let</span>
    <span class="nv">fix</span> <span class="nv">copy2</span> (<span class="nv">a</span> : V) (<span class="nv">i</span> : nat) : (BraunTree * BraunTree) :=
    <span class="kr">match</span> i <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; (T a E E, E)
    | S i&#39; =&gt; <span class="c">(* i&#39; = i-1 *)</span>
      <span class="kr">if</span> Nat.odd i <span class="kr">then</span>
        <span class="kr">let</span> <span class="nv">m</span> := div2 i&#39; <span class="kr">in</span>
        <span class="kr">let</span> (<span class="nv">s</span>, t) := copy2 a m <span class="kr">in</span>
        (T a s t, T a t t)
      <span class="kr">else</span>
        <span class="kr">match</span> i&#39; <span class="kr">with</span>
        | O =&gt; <span class="c">(* Unreachable *)</span> (E, E)
        | S i&#39;&#39; =&gt; <span class="c">(* i&#39;&#39; = i-2 *)</span>
          <span class="kr">let</span> <span class="nv">m</span> := div2 i&#39;&#39; <span class="kr">in</span>
          <span class="kr">let</span> (<span class="nv">s</span>, t) := copy2 a m <span class="kr">in</span>
          (T a s s, T a s t)
        <span class="kr">end</span>
    <span class="kr">end</span>
  <span class="kr">in</span>
  <span class="kr">match</span> copy2 x n <span class="kr">with</span>
  | (_, snd) =&gt; snd
  <span class="kr">end</span>.</span></span></pre></section>
</section>
</section>
</div>
</main>
</div></body>
</html>
