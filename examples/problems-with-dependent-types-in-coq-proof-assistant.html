<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>Problems with dependent types in Coq proof assistant</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="problems-with-dependent-types-in-coq-proof-assistant">
<h1 class="title">Problems with dependent types in Coq proof assistant</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/43453365">https://stackoverflow.com/q/43453365</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>Consider the following simple expression language:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Exp</span> : <span class="kt">Set</span> :=
| EConst : nat -&gt; Exp
| EVar   : nat -&gt; Exp
| EFun   : nat -&gt; list Exp -&gt; Exp.</span></span></pre><p>and its wellformedness predicate:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Env</span> := list nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">WF</span> (<span class="nv">env</span> : Env) : Exp -&gt; <span class="kt">Prop</span> :=
| WFConst : <span class="kr">forall</span> <span class="nv">n</span>, WF env (EConst n)
| WFVar   : <span class="kr">forall</span> <span class="nv">n</span>, In n env -&gt; WF env (EVar n)
| WFFun   : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">es</span>, In n env -&gt;
                         Forall (WF env) es -&gt;
                         WF env (EFun n es).</span></span></pre><p>which basically states that every variable and function symbols must
be defined in the environment. Now, I want to define a function that
states the decidability of <tt class="docutils literal">WF</tt> predicate:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk0"><span class="kn">Definition</span> <span class="nf">WFDec</span> (<span class="nv">env</span> : Env) : <span class="kr">forall</span> <span class="nv">e</span>, {WF env e} + {~ WF env e}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>Env</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">e</span> : Exp, {WF env e} + {~ WF env e}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk1"><span class="nb">refine</span> (<span class="kr">fix</span> wfdec e : {WF env e} + {~ WF env e} :=
            <span class="kr">match</span> e <span class="kr">as</span> e&#39; <span class="kr">return</span> e = e&#39; -&gt; {WF env e&#39;} + {~ WF env e&#39;} <span class="kr">with</span>
            | EConst n =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="nb">left</span> _ _
            | EVar n =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt;
                          <span class="kr">match</span> in_dec eq_nat_dec n env <span class="kr">with</span>
                          | <span class="nb">left</span> _ _ =&gt; <span class="nb">left</span> _ _
                          | <span class="nb">right</span> _ _ =&gt; <span class="nb">right</span> _ _
                          <span class="kr">end</span>
            | EFun n es =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt;
                             <span class="kr">match</span> in_dec eq_nat_dec n env <span class="kr">with</span>
                             | <span class="nb">left</span> _ _ =&gt; _
                             | <span class="nb">right</span> _ _ =&gt; <span class="nb">right</span> _ _
                             <span class="kr">end</span>
            <span class="kr">end</span> (eq_refl e)); <span class="nb">clear</span> wfdec; <span class="nb">subst</span>; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>Env</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">WF env (EConst n)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>Env</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>In n env</span></span></span><br></div><label class="goal-separator" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk2"><hr></label><div class="goal-conclusion">WF env (EVar n)</div></blockquote><input class="alectryon-extra-goal-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>Env</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>~ In n env</span></span></span><br></div><label class="goal-separator" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk3"><hr></label><div class="goal-conclusion">~ WF env (EVar n)</div></blockquote><input class="alectryon-extra-goal-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>Env</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>es</var><span class="hyp-type"><b>: </b><span>list Exp</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>In n env</span></span></span><br></div><label class="goal-separator" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk4"><hr></label><div class="goal-conclusion">{WF env (EFun n es)} + {~ WF env (EFun n es)}</div></blockquote><input class="alectryon-extra-goal-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>Env</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>es</var><span class="hyp-type"><b>: </b><span>list Exp</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>~ In n env</span></span></span><br></div><label class="goal-separator" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk5"><hr></label><div class="goal-conclusion">~ WF env (EFun n es)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>The trouble is how to state that <tt class="docutils literal">WF</tt> predicate holds or not for a
list of expressions in the <tt class="docutils literal">EFun</tt> case. My obvious guess was:</p>
<pre class="code coq literal-block">
<span class="o">...</span>
<span class="kr">match</span> <span class="n">Forall_dec</span> <span class="o">(</span><span class="n">WF</span> <span class="n">env</span><span class="o">)</span> <span class="n">wfdec</span> <span class="n">es</span> <span class="kr">with</span>
<span class="o">...</span>
</pre>
<p>But Coq refuses it, arguing that the recursive call <tt class="docutils literal">wfdec</tt> is
ill-formed. My question is: Is it possible to define decidability of
such wellformedness predicate without changing the expression
representation?</p>
<p>The complete working code is at the following <a class="reference external" href="https://gist.github.com/rodrigogribeiro/132e4feca910f40198242d3da3eca040">gist</a>.</p>
</div>
<div class="section" id="answer-ejgallego">
<h1>Answer (ejgallego)</h1>
<p>As a temporal workaround you can define <tt class="docutils literal">wf</tt> as:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">wf</span> (<span class="nv">env</span> : Env) := <span class="kr">fix</span> <span class="kn">wf</span> (e : Exp) : bool :=
    <span class="kr">match</span> e <span class="kr">with</span>
    | EConst _ =&gt; true
    | EVar v   =&gt; v \<span class="kr">in</span> env
    | EFun v l =&gt; [&amp;&amp; v \<span class="kr">in</span> env &amp; <span class="kp">all</span> <span class="kn">wf</span> l]
    <span class="kr">end</span>.</span></span></pre><p>which is usually way more convenient to use. However, this definition
will be pretty useless due to Coq generating the wrong induction
principle for <tt class="docutils literal">exp</tt>, as it doesn't detect the list. What I usually
do is to fix the induction principle manually, but this is costly.
Example:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk6"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> all_ssreflect.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ | _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ : _ | _ ]&quot;</span> was already used <span class="kr">in</span>
scope fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ &amp; _ | _ ]&quot;</span> was already used
<span class="kr">in</span> scope fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span>
scope fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ | _ ]&quot;</span> was already used <span class="kr">in</span>
scope fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ + _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ - _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ * _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unset Printing Implicit Defensive</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> <span class="kn">Prenex Implicits</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ReflectMorph</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk7"><span class="kn">Lemma</span> <span class="nf">and_MR</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">b</span> <span class="nv">c</span> : reflect P b -&gt; reflect Q c -&gt; reflect (P /\ Q) (b &amp;&amp; c).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect P b -&gt;
reflect Q c -&gt; reflect (P /\ Q) (b &amp;&amp; c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect P b -&gt;
reflect Q c -&gt; reflect (P /\ Q) (b &amp;&amp; c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; h1 h2; <span class="nb">apply</span>: (iffP andP) =&gt; -[/h1 ? /h2 ?].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk9"><span class="kn">Lemma</span> <span class="nf">or_MR</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">b</span> <span class="nv">c</span> : reflect P b -&gt; reflect Q c -&gt; reflect (P \/ Q) (b || c).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect P b -&gt;
reflect Q c -&gt; reflect (P \/ Q) (b || c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect P b -&gt;
reflect Q c -&gt; reflect (P \/ Q) (b || c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; h1 h2; <span class="nb">apply</span>: (iffP orP) =&gt; -[/h1 | /h2]; <span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ReflectMorph</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">IN</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">X</span> : eqType).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chkb"><span class="kn">Lemma</span> <span class="nf">InP</span> (<span class="nv">x</span> : X) <span class="nv">l</span> : reflect (In x l) (x \<span class="kr">in</span> l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>eqType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>seq X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (In x l) (x \<span class="kr">in</span> l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chkc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>eqType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>seq X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (In x l) (x \<span class="kr">in</span> l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chkd"><span class="nb">elim</span>: l =&gt; [|y l ihl]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">constructor</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>eqType</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>seq X</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>reflect (In x l) (x \<span class="kr">in</span> l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (In x (y :: l)) (x \<span class="kr">in</span> y :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: or_MR; <span class="nb">rewrite</span> // eq_sym; <span class="bp">exact</span>: eqP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">IN</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">FORALL</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : X -&gt; <span class="kt">Prop</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">p</span> : X -&gt; bool).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chke"><span class="kn">Lemma</span> <span class="nf">Forall_inv</span> <span class="nv">x</span> <span class="nv">l</span> : Forall P (x :: l) -&gt; P x /\ Forall P l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>X -&gt; bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>seq X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall P (x :: l) -&gt; P x /\ Forall P l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chkf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>X -&gt; bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>seq X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall P (x :: l) -&gt; P x /\ Forall P l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; U; <span class="nb">inversion</span> U.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk10"><span class="kn">Lemma</span> <span class="nf">ForallP</span> <span class="nv">l</span> : (<span class="kr">forall</span> <span class="nv">x</span>, In x l -&gt; reflect (P x) (p x)) -&gt;
                    reflect (Forall P l) (<span class="kp">all</span> p l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>X -&gt; bool</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>seq X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, In x l -&gt; reflect (P x) (p x)) -&gt;
reflect (Forall P l) (<span class="kp">all</span> p l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>X -&gt; bool</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>seq X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, In x l -&gt; reflect (P x) (p x)) -&gt;
reflect (Forall P l) (<span class="kp">all</span> p l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk12"><span class="nb">elim</span>: l =&gt; [|x l hp ihl /=]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>X -&gt; bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>seq X</span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : X, In x l -&gt; reflect (P x) (p x)) -&gt;
reflect (Forall P l) (<span class="kp">all</span> p l)</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : X, In x0 (x :: l) -&gt; reflect (P x0) (p x0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (Forall P (x :: l)) (p x &amp;&amp; <span class="kp">all</span> p l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk13"><span class="nb">have</span>/hp {hp}hp : <span class="kr">forall</span> <span class="nv">x</span> : X, In x l -&gt; reflect (P x) (p x).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Duplicate <span class="nb">clear</span> of hp [duplicate-<span class="nb">clear</span>,ssr]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>X -&gt; bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>seq X</span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : X, In x l -&gt; reflect (P x) (p x)) -&gt;
reflect (Forall P l) (<span class="kp">all</span> p l)</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : X, In x0 (x :: l) -&gt; reflect (P x0) (p x0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X, In x l -&gt; reflect (P x) (p x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>X -&gt; bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>seq X</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : X, In x0 (x :: l) -&gt; reflect (P x0) (p x0)</span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>reflect (Forall P l) (<span class="kp">all</span> p l)</span></span></span><br></div><label class="goal-separator" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk14"><hr></label><div class="goal-conclusion">reflect (Forall P (x :: l)) (p x &amp;&amp; <span class="kp">all</span> p l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk15"><span class="bp">by</span> <span class="nb">move</span>=&gt; y y_in; <span class="nb">apply</span>: ihl; <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>X -&gt; bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>seq X</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : X, In x0 (x :: l) -&gt; reflect (P x0) (p x0)</span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>reflect (Forall P l) (<span class="kp">all</span> p l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (Forall P (x :: l)) (p x &amp;&amp; <span class="kp">all</span> p l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk16"><span class="nb">have</span> {ihl} ihl := ihl _ (or_introl erefl).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Duplicate <span class="nb">clear</span> of ihl [duplicate-<span class="nb">clear</span>,ssr]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>X -&gt; bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>seq X</span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>reflect (Forall P l) (<span class="kp">all</span> p l)</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>reflect (P x) (p x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (Forall P (x :: l)) (p x &amp;&amp; <span class="kp">all</span> p l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: (iffP andP) =&gt; [|/Forall_inv] [] /ihl hx /hp hall; <span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">FORALL</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Exp</span> : <span class="kt">Type</span> :=
| EConst : nat -&gt; Exp
| EVar   : nat -&gt; Exp
| EFun   : nat -&gt; list Exp -&gt; Exp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk17"><span class="kn">Lemma</span> <span class="nf">Exp_rect_list</span> (<span class="nv">P</span> : Exp -&gt; <span class="kt">Type</span>) :
  (<span class="kr">forall</span> <span class="nv">n</span> : nat, P (EConst n)) -&gt;
  (<span class="kr">forall</span> <span class="nv">n</span> : nat, P (EVar n)) -&gt;
  (<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : seq Exp),
      (<span class="kr">forall</span> <span class="nv">x</span>, In x l -&gt; P x) -&gt; P (EFun n l)) -&gt; <span class="kr">forall</span> <span class="nv">e</span> : Exp, P e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>Exp -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">n</span> : nat, P (EConst n)) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> : nat, P (EVar n)) -&gt;
(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : seq Exp),
 (<span class="kr">forall</span> <span class="nv">x</span> : Exp, In x l -&gt; P x) -&gt; P (EFun n l)) -&gt;
<span class="kr">forall</span> <span class="nv">e</span> : Exp, P e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Env</span> := list nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">wf</span> (<span class="nv">env</span> : Env) := <span class="kr">fix</span> <span class="kn">wf</span> (e : Exp) : bool :=
    <span class="kr">match</span> e <span class="kr">with</span>
    | EConst _ =&gt; true
    | EVar v   =&gt; v \<span class="kr">in</span> env
    | EFun v l =&gt; [&amp;&amp; v \<span class="kr">in</span> env &amp; <span class="kp">all</span> <span class="kn">wf</span> l]
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">WF</span> (<span class="nv">env</span> : Env) : Exp -&gt; <span class="kt">Prop</span> :=
| WFConst : <span class="kr">forall</span> <span class="nv">n</span>, WF env (EConst n)
| WFVar   : <span class="kr">forall</span> <span class="nv">n</span>, In n env -&gt; WF env (EVar n)
| WFFun   : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">es</span>, In n env -&gt;
                         Forall (WF env) es -&gt;
                         WF env (EFun n es).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk18"><span class="kn">Lemma</span> <span class="nf">WF_inv</span> <span class="nv">env</span> <span class="nv">e</span> (<span class="nv">wf</span> : WF env e) :
  <span class="kr">match</span> e <span class="kr">with</span>
  | EConst n  =&gt; <span class="kt">True</span>
  | EVar n    =&gt; In n env
  | EFun n es =&gt; In n env /\ Forall (WF env) es
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>Env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Exp</span></span></span><br><span><var>wf</var><span class="hyp-type"><b>: </b><span>WF env e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> e <span class="kr">with</span>
| EConst _ =&gt; <span class="kt">True</span>
| EVar n =&gt; In n env
| EFun n es =&gt; In n env /\ Forall (WF env) es
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk19"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>Env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Exp</span></span></span><br><span><var>wf</var><span class="hyp-type"><b>: </b><span>WF env e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> e <span class="kr">with</span>
| EConst _ =&gt; <span class="kt">True</span>
| EVar n =&gt; In n env
| EFun n es =&gt; In n env /\ Forall (WF env) es
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: e <span class="kn">wf</span> =&gt; // [n | n l] H; <span class="nb">inversion</span> H.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk1a"><span class="kn">Lemma</span> <span class="nf">wfP</span> <span class="nv">env</span> <span class="nv">e</span> : reflect (WF env e) (<span class="kn">wf</span> env e).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>Env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Exp</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (WF env e) (<span class="kn">wf</span> env e)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk1b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>Env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Exp</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (WF env e) (<span class="kn">wf</span> env e)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk1c"><span class="nb">elim</span>/Exp_rect_list: e =&gt; [n | n | n l ihe] /=; <span class="kp">try</span> <span class="kp">repeat</span> <span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>Env</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (WF env (EVar n)) (n \<span class="kr">in</span> env)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk1d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>Env</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>seq Exp</span></span></span><br><span><var>ihe</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Exp, In x l -&gt; reflect (WF env x) (<span class="kn">wf</span> env x)</span></span></span><br></div><label class="goal-separator" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk1d"><hr></label><div class="goal-conclusion">reflect (WF env (EFun n l))
  ((n \<span class="kr">in</span> env) &amp;&amp; <span class="kp">all</span> (<span class="kn">wf</span> env) l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk1e"><span class="bp">by</span> <span class="nb">apply</span>: (iffP idP) =&gt; [/InP | /WF_inv/InP //]; <span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>Env</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>seq Exp</span></span></span><br><span><var>ihe</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Exp, In x l -&gt; reflect (WF env x) (<span class="kn">wf</span> env x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (WF env (EFun n l))
  ((n \<span class="kr">in</span> env) &amp;&amp; <span class="kp">all</span> (<span class="kn">wf</span> env) l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk1f"><span class="nb">apply</span>: (iffP andP) =&gt; [[/InP ? /ForallP H] | /WF_inv[/InP ? /ForallP]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>Env</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>seq Exp</span></span></span><br><span><var>ihe</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Exp, In x l -&gt; reflect (WF env x) (<span class="kn">wf</span> env x)</span></span></span><br><span><var>__view_subject_1_</var><span class="hyp-type"><b>: </b><span>In n env</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Exp -&gt; <span class="kt">Prop</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : Exp,
 In x l -&gt; reflect (P x) (<span class="kn">wf</span> env x)) -&gt; 
Forall P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">WF env (EFun n l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk20" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>Env</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>seq Exp</span></span></span><br><span><var>ihe</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Exp,
In x l -&gt; reflect (WF env x) (<span class="kn">wf</span> env x)</span></span></span><br><span><var>__view_subject_2_</var><span class="hyp-type"><b>: </b><span>n \<span class="kr">in</span> env</span></span></span><br></div><label class="goal-separator" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk20"><hr></label><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">b</span> : Exp -&gt; bool,
 (<span class="kr">forall</span> <span class="nv">x</span> : Exp, In x l -&gt; reflect (WF env x) (b x)) -&gt;
 <span class="kp">all</span> b l) -&gt; n \<span class="kr">in</span> env /\ <span class="kp">all</span> (<span class="kn">wf</span> env) l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="problems-with-dependent-types-in-coq-proof-assistant-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="problems-with-dependent-types-in-coq-proof-assistant-v-chk21"><span class="bp">by</span> <span class="nb">constructor</span> =&gt; //; <span class="bp">exact</span>: H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>env</var><span class="hyp-type"><b>: </b><span>Env</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>seq Exp</span></span></span><br><span><var>ihe</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Exp,
In x l -&gt; reflect (WF env x) (<span class="kn">wf</span> env x)</span></span></span><br><span><var>__view_subject_2_</var><span class="hyp-type"><b>: </b><span>n \<span class="kr">in</span> env</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">b</span> : Exp -&gt; bool,
 (<span class="kr">forall</span> <span class="nv">x</span> : Exp, In x l -&gt; reflect (WF env x) (b x)) -&gt;
 <span class="kp">all</span> b l) -&gt; n \<span class="kr">in</span> env /\ <span class="kp">all</span> (<span class="kn">wf</span> env) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="answer-arthur-azevedo-de-amorim">
<h1>Answer (Arthur Azevedo De Amorim)</h1>
<p>The problem is that <tt class="docutils literal">Forall_dec</tt> is defined as opaque in the
standard library (that is, with <tt class="docutils literal">Qed</tt> instead of <tt class="docutils literal">Defined</tt>).
Because of that, Coq does not know that the use of <tt class="docutils literal">wfdec</tt> is valid.</p>
<p>The immediate solution to your problem is to redefine <tt class="docutils literal">Forall_dec</tt>
so that it is transparent. You can do this by printing the proof term
that Coq generates and pasting it in your source file. I've added a
<a class="reference external" href="https://gist.github.com/anonymous/5b3fdc11871e42b3e9cfe006f6d8cc76">gist</a>
here with a complete solution.</p>
<p>Needless to say, this approach lends itself to bloated, hard to read,
and hard to maintain code. As ejgallego was pointing out in his
answer, your best bet in this case is probably to define a Boolean
function that decides <tt class="docutils literal">WF</tt>, and use that instead of <tt class="docutils literal">WFDec</tt>. The
only problem with his approach, as he said, is that you will need to
write your own induction principle to <tt class="docutils literal">Exp</tt> in order to prove that
the Boolean version indeed decides the inductive definition. Adam
Chlipala's CPDT has a <a class="reference external" href="http://adam.chlipala.net/cpdt/html/InductiveTypes.html">chapter</a> on
inductive types that gives an example of such an induction principle;
just look for &quot;nested inductive types&quot;.</p>
</div>
</div>
</div>
</div></body>
</html>
