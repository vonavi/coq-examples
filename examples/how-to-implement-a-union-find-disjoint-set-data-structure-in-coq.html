<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>How to implement a union-find (disjoint set) data structure in Coq?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="how-to-implement-a-union-find-disjoint-set-data-structure-in-coq">
<h1 class="title">How to implement a union-find (disjoint set) data structure in Coq?</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/66630519">https://stackoverflow.com/q/66630519</a></p>
</dd>
</dl>
<section id="question">
<h2>Question</h2>
<p>I am quite new to Coq, but for my project I have to use a union-find
data structure in Coq. Are there any implementations of the union-find
(disjoint set) data structure in Coq?</p>
<p>If not, can someone provide an implementation or some ideas? It
doesn't have to be very efficient. (no need to do path compression or
all the fancy optimizations) I just need a data structure that can
hold an arbitrary data type (or nat if it's too hard) and perform:
<strong>union</strong> and <strong>find</strong>.</p>
</section>
<section id="answer">
<h2>Answer</h2>
<p>If all you need is a mathematical model, with no concern for actual
performance, I would go for the most straightforward one: a functional
map (finite partial function) in which each element optionally links
to another element with which it has been merged.</p>
<ul class="simple">
<li><p>If an element links to nothing, then its canonical representative is
itself.</p></li>
<li><p>If an element links to another element, then its canonical
representative is the canonical representative of that other
element.</p></li>
</ul>
<p>Note: in the remaining of this answer, as is standard with union-find,
I will assume that elements are simply natural numbers. If you want
another type of elements, simply have another map that binds all
elements to unique numbers.</p>
<p>Then you would define a function <span class="docutils literal">find : UnionFind <span class="pre">-&gt;</span> nat <span class="pre">-&gt;</span> nat</span>
that returns the canonical representative of a given element, by
following links as long as you can. Notice that the function would use
recursion, whose termination argument is not trivial. To make it
happen, I think that the easiest way is to maintain the invariant that
a number only links to a lesser number (i.e. if <span class="docutils literal">i</span> links to <span class="docutils literal">j</span>,
then <span class="docutils literal">i &gt; j</span>). Then the recursion terminates because, when following
links, the current element is a decreasing natural number.</p>
<p>Defining the function <span class="docutils literal">union : UnionFind <span class="pre">-&gt;</span> nat <span class="pre">-&gt;</span> nat <span class="pre">-&gt;</span> UnionFind</span>
is easier: <span class="docutils literal">union m i j</span> simply returns an updated map with <span class="docutils literal">max i' j'</span> linking to <span class="docutils literal">min i' j'</span>, where <span class="docutils literal">i' = find m i</span> and <span class="docutils literal">j' = find m j</span>.</p>
<p>[Side note on performance: maintaining the invariant means that you
cannot adequately choose which of a pair of partitions to merge into
the other, based on their ranks; however you can still implement path
compression if you want!]</p>
<p>As for which data structure exactly to use for the map: there are
several available. The <a class="reference external" href="https://coq.inria.fr/library/index.html">standard library</a> (look under the title
<strong>FSets</strong>) has several implementations (FMapList, FMapPositive and
so on) satisfying the interface <a class="reference external" href="https://coq.inria.fr/library/Coq.FSets.FMapInterface.html">FMapInterface</a>. The
stdpp libray has <a class="reference external" href="https://plv.mpi-sws.org/coqdoc/stdpp/stdpp.gmap.html">gmap</a>.</p>
<p>Again if performance is not a concern, just pick the simplest encoding
or, more importantly, the one that makes your proofs the simplest. I
am thinking of just a list of natural numbers. The positions of the
list are the elements in <em>reverse order</em>. The values of the list are
<em>offsets</em>, i.e. the number of positions to skip forward in order to
reach the target of the link.</p>
<ul class="simple">
<li><p>For an element <span class="docutils literal">i</span> linking to <span class="docutils literal">j</span> (<span class="docutils literal">i &gt; j</span>), the offset is <span class="docutils literal">i − j</span>.</p></li>
<li><p>For a canonical representative, the offset is zero.</p></li>
</ul>
<p>With my best pseudo-ASCII-art skills, here is a map where the links
are { 6↦2, 4↦2, 3↦0, 2↦1 } and the canonical representatives are { 5,
1, 0 }:</p>
<pre class="code literal-block"><code>  6   5   4   3   2   1   0   element
  ↓  ↓  ↓  ↓  ↓  ↓  ↓
               /‾‾‾‾‾‾‾‾‾↘
[ 4 ; 0 ; 2 ; 3 ; 1 ; 0 ; 0 ] map
   \       \___↗↗ \_↗
    \___________/</code></pre>
<p>The motivation is that the invariant discussed above is then enforced
<em>structurally</em>. Hence, there is hope that <span class="docutils literal">find</span> could actually be
defined by structural induction (on the structure of the list), and
have termination for free.</p>
<hr class="docutils" />
<p>A related paper is: <a class="reference external" href="https://www.lri.fr/~filliatr/ftp/publis/puf-wml07.pdf">Sylvain Conchon and Jean-Christophe Filliâtre. A
Persistent Union-Find Data Structure. In ACM SIGPLAN Workshop on ML</a>.</p>
<p>It describes the implementation of an efficient union-find data
structure in ML, that is persistent from the user perspective, but
uses mutation internally. What may be more interesting for you, is
that they prove it correct in Coq, which implies that they have a Coq
model for union-find. However, this model reflects the memory store
for the imperative program that they seek to prove correct. I'm not
sure how applicable it is to your problem.</p>
</section>
</main>
</div></body>
</html>
