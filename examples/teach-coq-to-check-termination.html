<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>Teach coq to check termination</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="teach-coq-to-check-termination">
<h1 class="title">Teach coq to check termination</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/48173854">https://stackoverflow.com/q/48173854</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>Coq, unlike many others, accepts an optional explicit parameter, which
can be used to indicate the decreasing structure of a fixpoint
definition.</p>
<p>From Gallina specification, 1.3.4,</p>
<pre class="code coq literal-block">
<span class="kn">Fixpoint</span> <span class="nf">ident</span> <span class="nv">params</span> <span class="o">{</span><span class="nv">struct</span> <span class="nv">ident0</span><span class="o">}</span> <span class="o">:</span> <span class="n">type0</span> <span class="o">:=</span> <span class="n">term0</span>
</pre>
<p>defines the syntax. but from it, we've known that it must be an
identifier, instead of a general measure.</p>
<p>However, in general, there are recursive functions, that the
termination is not quite obvious, or it in fact is, but just difficult
for the termination checker to find a decreasing structure. For
example, following program interleaves two lists,</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="teach-coq-to-check-termination-v-chk0"><span class="kn">Fixpoint</span> <span class="nf">interleave</span> (<span class="nv">A</span> : <span class="kt">Set</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list A) : list A :=
  <span class="kr">match</span> l1 <span class="kr">with</span>
  | [] =&gt; []
  | h :: t =&gt; h :: interleave l2 t
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">In environment
interleave : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Set</span>,
             list A -&gt; list A -&gt; list A
A : <span class="kt">Set</span>
l1 : list A
l2 : list A
h : A
t : list A
The term <span class="s2">&quot;l2&quot;</span> has type <span class="s2">&quot;list A&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type <span class="s2">&quot;Set&quot;</span>.</blockquote></div></div></small></span></pre><p>This function clearly terminates, while Coq just couldn't figure it
out. The reason is neither <tt class="docutils literal">l1</tt> nor <tt class="docutils literal">l2</tt> are decreasing every
cycle. But what if we consider a measure, defined to be <tt class="docutils literal">length l1 +
length l2</tt>? Then this measure clearly decreases every recursion.</p>
<p>So my question is, in the case of sophisticated situation, where code
is not straightforward to be organized in a termination checkable way,
how do you educate coq and convince it to accept the fixpoint
definition?</p>
</div>
<div class="section" id="answer">
<h1>Answer</h1>
<p>You have multiple options and all of them boil down to structural
recursion in the end.</p>
<div class="section" id="preamble">
<h2>Preamble</h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span></span></pre></div>
<div class="section" id="structural-recursion">
<h2>Structural recursion</h2>
<p>Sometimes you can reformulate your algorithm in a structurally
recursive way:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">interleave1</span> {<span class="nv">A</span>} (<span class="nv">l1</span> <span class="nv">l2</span> : list A) {<span class="nv">struct</span> <span class="nv">l1</span>} : list A :=
  <span class="kr">match</span> l1, l2 <span class="kr">with</span>
  | [], _ =&gt; l2
  | _, [] =&gt; l1
  | h1 :: t1, h2 :: t2 =&gt; h1 :: h2 :: interleave1 t1 t2
  <span class="kr">end</span>.</span></span></pre><p>Incidentally, in some cases you can use a trick with nested <tt class="docutils literal">fix</tt>es -- see <a class="reference external" href="https://stackoverflow.com/a/10303475/2747511">this definition of Ackermann function</a> (it wouldn't work
with just <tt class="docutils literal">Fixpoint</tt>).</p>
</div>
<div class="section" id="program-fixpoint">
<h2><tt class="docutils literal">Program Fixpoint</tt></h2>
<p>You can use <tt class="docutils literal">Program Fixpoint</tt> mechanism which lets you write your
program naturally and later prove that it always terminates.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Program Arith.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Fixpoint</span> <span class="nf">interleave2</span> {<span class="nv">A</span>} (<span class="nv">l1</span> <span class="nv">l2</span> : list A)
        {<span class="nv">measure</span> (length l1 + length l2)} : list A :=
  <span class="kr">match</span> l1 <span class="kr">with</span>
  | [] =&gt; l2
  | h :: t =&gt; h :: interleave2 l2 t
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk1"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>interleave2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A0</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l3</span> : list A0),
length l1 + length l3 &lt;
length (h :: t) + length l2 -&gt; 
list A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length l2 + length t &lt; length (h :: t) + length l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk2"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>interleave2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A0</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l3</span> : list A0),
length l1 + length l3 &lt;
length (h :: t) + length l2 -&gt; 
list A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length l2 + length t &lt; S (length t + length l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk3"><span class="nb">rewrite</span> Nat.add_comm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>interleave2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A0</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l3</span> : list A0),
length l1 + length l3 &lt;
length (h :: t) + length l2 -&gt; 
list A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length t + length l2 &lt; S (length t + length l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial with</span> arith.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="function">
<h2><tt class="docutils literal">Function</tt></h2>
<p>Another option is to use the <tt class="docutils literal">Function</tt> command which can be
somewhat limited compared to <tt class="docutils literal">Program Fixpoint</tt>. You can find out
more about their differences <a class="reference external" href="https://stackoverflow.com/q/44606245/2747511">here</a>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require</span> Recdef.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sum_len</span> {<span class="nv">A</span>} (<span class="nv">ls</span> : (list A * list A)) : nat :=
  length (fst ls) + length (snd ls).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk4"><span class="kn">Function</span> <span class="nf">interleave3</span> {A} (ls : (list A * list A))
         {<span class="kn">measure</span> sum_len ls} : list A :=
  <span class="kr">match</span> ls <span class="kr">with</span>
  | ([], _) =&gt; []
  | (h :: t, l2) =&gt; h :: interleave3 (l2, t)
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">ls</span> : list A * list A)
  (<span class="nv">l</span> <span class="nv">l2</span> : list A) (<span class="nv">h</span> : A) (<span class="nv">t</span> : list A),
l = h :: t -&gt;
ls = (h :: t, l2) -&gt;
sum_len (l2, t) &lt; sum_len (h :: t, l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">ls</span> : list A * list A)
  (<span class="nv">l</span> <span class="nv">l2</span> : list A) (<span class="nv">h</span> : A) (<span class="nv">t</span> : list A),
l = h :: t -&gt;
ls = (h :: t, l2) -&gt;
sum_len (l2, t) &lt; sum_len (h :: t, l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk6"><span class="nb">intros</span> A ls l1 l2 h t -&gt; -&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_len (l2, t) &lt; sum_len (h :: t, l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk7"><span class="nb">unfold</span> sum_len.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (fst (l2, t)) + length (snd (l2, t)) &lt;
length (fst (h :: t, l2)) + length (snd (h :: t, l2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk8"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length l2 + length t &lt; S (length t + length l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk9"><span class="nb">rewrite</span> Nat.add_comm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length t + length l2 &lt; S (length t + length l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial with</span> arith.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre></div>
<div class="section" id="equations-plugin">
<h2><a class="reference external" href="http://mattam82.github.io/Coq-Equations/">Equations</a> plugin</h2>
<p>This is an external plugin which addresses many issues with defining
functions in Coq, including dependent types and termination.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> <span class="kn">Equations</span> <span class="nf">Require</span> <span class="nv">Import</span> <span class="nv">Equations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">interleave4</span> {<span class="nv">A</span>} (<span class="nv">l1</span> <span class="nv">l2</span> : list A) : list A
  <span class="bp">by</span> <span class="kn">wf</span> (length l1 + length l2) lt :=
  interleave4 nil l2 := l2;
  interleave4 (cons h t) l2 := cons h (interleave4 l2 t).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chka"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>interleave4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : <span class="kt">Type</span>) (<span class="nv">x0</span> <span class="nv">x1</span> : list x),
length x0 + length x1 &lt;
S (length t + length l2) -&gt; 
list x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length l2 + length t &lt; S (length t + length l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chkb"><span class="nb">rewrite</span> Nat.add_comm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>interleave4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : <span class="kt">Type</span>) (<span class="nv">x0</span> <span class="nv">x1</span> : list x),
length x0 + length x1 &lt;
S (length t + length l2) -&gt; 
list x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length t + length l2 &lt; S (length t + length l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial with</span> arith.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="fix-fix-f-2-combinators">
<h2><tt class="docutils literal">Fix</tt> / <tt class="docutils literal">Fix_F_2</tt> combinators</h2>
<p>You can learn more about this (manual) approach if you follow the
links from <a class="reference external" href="https://stackoverflow.com/q/42285235/2747511">this question</a> about <tt class="docutils literal">mergeSort</tt>
function. By the way, the <tt class="docutils literal">mergeSort</tt> function can be defined
without using <tt class="docutils literal">Fix</tt> if you apply the nested <tt class="docutils literal">fix</tt> trick I
mentioned earlier. Here is a solution which uses <tt class="docutils literal">Fix_F_2</tt>
combinator since we have two arguments and not one like <tt class="docutils literal">mergeSort</tt>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ordering</span> {<span class="nv">A</span>} (<span class="nv">l1</span> <span class="nv">l2</span> : list A * list A) : <span class="kt">Prop</span> :=
  length (fst l1) + length (snd l1) &lt; length (fst l2) + length (snd l2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chkc"><span class="kn">Lemma</span> <span class="nf">ordering_wf&#39;</span> {<span class="nv">A</span>} : <span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">p</span> : list A * list A),
    length (fst p) + length (snd p) &lt;= m -&gt; Acc (@ordering A) p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">p</span> : list A * list A),
length (fst p) + length (snd p) &lt;= m -&gt; Acc ordering p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">p</span> : list A * list A),
length (fst p) + length (snd p) &lt;= m -&gt; Acc ordering p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chke"><span class="nb">unfold</span> ordering.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">p</span> : list A * list A),
length (fst p) + length (snd p) &lt;= m -&gt;
Acc
  (<span class="kr">fun</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A * list A =&gt;
   length (fst l1) + length (snd l1) &lt;
   length (fst l2) + length (snd l2)) p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chkf"><span class="nb">induction</span> m; <span class="nb">intros</span> p H; <span class="nb">constructor</span>; <span class="nb">intros</span> p&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(list A * list A)%type</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (fst p) + length (snd p) &lt;= <span class="mi">0</span></span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>(list A * list A)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (fst p&#39;) + length (snd p&#39;) &lt;
length (fst p) + length (snd p) -&gt;
Acc
  (<span class="kr">fun</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A * list A =&gt;
   length (fst l1) + length (snd l1) &lt;
   length (fst l2) + length (snd l2)) p&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="teach-coq-to-check-termination-v-chk10" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : list A * list A,
length (fst p) + length (snd p) &lt;= m -&gt;
Acc
(<span class="kr">fun</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A * list A =&gt;
length (fst l1) + length (snd l1) &lt; length (fst l2) + length (snd l2)) p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(list A * list A)%type</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (fst p) + length (snd p) &lt;= S m</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>(list A * list A)%type</span></span></span><br></div><label class="goal-separator" for="teach-coq-to-check-termination-v-chk10"><hr></label><div class="goal-conclusion">length (fst p&#39;) + length (snd p&#39;) &lt;
length (fst p) + length (snd p) -&gt;
Acc
  (<span class="kr">fun</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A * list A =&gt;
   length (fst l1) + length (snd l1) &lt;
   length (fst l2) + length (snd l2)) p&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk11">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(list A * list A)%type</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (fst p) + length (snd p) &lt;= <span class="mi">0</span></span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>(list A * list A)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (fst p&#39;) + length (snd p&#39;) &lt;
length (fst p) + length (snd p) -&gt;
Acc
  (<span class="kr">fun</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A * list A =&gt;
   length (fst l1) + length (snd l1) &lt;
   length (fst l2) + length (snd l2)) p&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk12"><span class="nb">apply</span> Nat.le_0_r, Nat.eq_add_0 <span class="kr">in</span> H <span class="kr">as</span> [-&gt; -&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>(list A * list A)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (fst p&#39;) + length (snd p&#39;) &lt; <span class="mi">0</span> + <span class="mi">0</span> -&gt;
Acc
  (<span class="kr">fun</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A * list A =&gt;
   length (fst l1) + length (snd l1) &lt;
   length (fst l2) + length (snd l2)) p&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk13"><span class="nb">intros</span> contra%Nat.nlt_0_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p, p'</var><span class="hyp-type"><b>: </b><span>(list A * list A)%type</span></span></span><br><span><var>contra</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc
  (<span class="kr">fun</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A * list A =&gt;
   length (fst l1) + length (snd l1) &lt;
   length (fst l2) + length (snd l2)) p&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">contradiction</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk14">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : list A * list A,
length (fst p) + length (snd p) &lt;= m -&gt;
Acc
  (<span class="kr">fun</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A * list A =&gt;
   length (fst l1) + length (snd l1) &lt;
   length (fst l2) + length (snd l2)) p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(list A * list A)%type</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (fst p) + length (snd p) &lt;= S m</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>(list A * list A)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (fst p&#39;) + length (snd p&#39;) &lt;
length (fst p) + length (snd p) -&gt;
Acc
  (<span class="kr">fun</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A * list A =&gt;
   length (fst l1) + length (snd l1) &lt;
   length (fst l2) + length (snd l2)) p&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk15"><span class="nb">intros</span> H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : list A * list A,
length (fst p) + length (snd p) &lt;= m -&gt;
Acc
  (<span class="kr">fun</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A * list A =&gt;
   length (fst l1) + length (snd l1) &lt;
   length (fst l2) + length (snd l2)) p</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(list A * list A)%type</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (fst p) + length (snd p) &lt;= S m</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>(list A * list A)%type</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>length (fst p&#39;) + length (snd p&#39;) &lt;
length (fst p) + length (snd p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc
  (<span class="kr">fun</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A * list A =&gt;
   length (fst l1) + length (snd l1) &lt;
   length (fst l2) + length (snd l2)) p&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> IHm, Nat.lt_succ_r, Nat.lt_le_trans; <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk16"><span class="kn">Lemma</span> <span class="nf">ordering_wf</span> {<span class="nv">A</span>} : well_founded (@ordering A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded ordering</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk17"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded ordering</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">red</span>; <span class="nb">intro</span>; <span class="nb">eapply</span> ordering_wf&#39;.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* it&#39;s in the stdlib but unfortunately opaque -- this blocks evaluation *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk18"><span class="kn">Lemma</span> <span class="nf">destruct_list</span> {<span class="nv">A</span>} (<span class="nv">l</span> : list A) :
  { x : A &amp; {tl : list A | l = x :: tl} } + { l = [] }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : A &amp; {tl : list A | l = x :: tl}} + {l = []}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk19"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : A &amp; {tl : list A | l = x :: tl}} + {l = []}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk1a"><span class="nb">induction</span> l <span class="kr">as</span> [|h tl]; [<span class="nb">right</span> | <span class="nb">left</span>]; <span class="nb">trivial</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tl</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHtl</var><span class="hyp-type"><b>: </b><span>{x : A &amp; {tl0 : list A | tl = x :: tl0}} +
{tl = []}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : A &amp; {tl0 : list A | h :: tl = x :: tl0}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk1b"><span class="kr">exists</span> <span class="nv">h</span>, tl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tl</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHtl</var><span class="hyp-type"><b>: </b><span>{x : A &amp; {tl0 : list A | tl = x :: tl0}} +
{tl = []}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h :: tl = h :: tl</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk1c"><span class="kn">Definition</span> <span class="nf">interleave5</span> {<span class="nv">A</span>} (<span class="nv">xs</span> <span class="nv">ys</span> : list A) : list A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs, ys</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk1d"><span class="nb">refine</span> (Fix_F_2
            (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; list A)
            (<span class="kr">fun</span> (<span class="nv">l1</span> <span class="nv">l2</span> : list A)
                 (<span class="nv">interleave</span> :
                    (<span class="kr">forall</span> <span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span>, ordering (l1&#39;, l2&#39;) (l1, l2) -&gt; list A)) =&gt;
               <span class="kr">match</span> destruct_list l1 <span class="kr">with</span>
               | inright _ =&gt; l2
               | inleft pf =&gt; <span class="kr">let</span> &#39;(existT _ h (exist _ tl eq)) := pf
                              <span class="kr">in</span> h :: interleave l2 tl _
               <span class="kr">end</span>) (ordering_wf (xs, ys))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs, ys, l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>interleave</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span> : list A,
ordering (l1&#39;, l2&#39;) (l1, l2) -&gt; list A</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>{x : A &amp; {tl : list A | l1 = x :: tl}}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>{tl : list A | l1 = h :: tl}</span></span></span><br><span><var>tl</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>l1 = h :: tl</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ordering (l2, tl) (l1, l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk1e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs, ys, l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>interleave</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span> : list A,
ordering (l1&#39;, l2&#39;) (l1, l2) -&gt; list A</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>{x : A &amp; {tl : list A | l1 = x :: tl}}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>{tl : list A | l1 = h :: tl}</span></span></span><br><span><var>tl</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>l1 = h :: tl</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ordering (l2, tl) (l1, l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk1f"><span class="nb">unfold</span> ordering.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs, ys, l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>interleave</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span> : list A,
ordering (l1&#39;, l2&#39;) (l1, l2) -&gt; list A</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>{x : A &amp; {tl : list A | l1 = x :: tl}}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>{tl : list A | l1 = h :: tl}</span></span></span><br><span><var>tl</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>l1 = h :: tl</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (fst (l2, tl)) + length (snd (l2, tl)) &lt;
length (fst (l1, l2)) + length (snd (l1, l2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk20"><span class="nb">rewrite</span> eq, Nat.add_comm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs, ys, l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>interleave</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span> : list A,
ordering (l1&#39;, l2&#39;) (l1, l2) -&gt; list A</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>{x : A &amp; {tl : list A | l1 = x :: tl}}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>{tl : list A | l1 = h :: tl}</span></span></span><br><span><var>tl</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>l1 = h :: tl</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (snd (l2, tl)) + length (fst (l2, tl)) &lt;
length (fst (h :: tl, l2)) +
length (snd (h :: tl, l2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre></div>
<div class="section" id="evaluation-tests">
<h2>Evaluation tests</h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk21"><span class="kn">Check</span> eq_refl : interleave1 [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>] = [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">5</span>; <span class="mi">3</span>; <span class="mi">6</span>].</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">eq_refl
:
interleave1 [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>] = [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">5</span>; <span class="mi">3</span>; <span class="mi">6</span>]
     : interleave1 [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>] =
       [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">5</span>; <span class="mi">3</span>; <span class="mi">6</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk22"><span class="kn">Check</span> eq_refl : interleave2 [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>] = [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">5</span>; <span class="mi">3</span>; <span class="mi">6</span>].</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">eq_refl
:
interleave2 [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>] = [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">5</span>; <span class="mi">3</span>; <span class="mi">6</span>]
     : interleave2 [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>] =
       [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">5</span>; <span class="mi">3</span>; <span class="mi">6</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk23"><span class="kn">Check</span> eq_refl : interleave3 ([<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>], [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>]) = [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">5</span>; <span class="mi">3</span>; <span class="mi">6</span>].</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">eq_refl
:
interleave3 ([<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>], [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>]) =
[<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">5</span>; <span class="mi">3</span>; <span class="mi">6</span>]
     : interleave3 ([<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>], [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>]) =
       [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">5</span>; <span class="mi">3</span>; <span class="mi">6</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk24"><span class="kn">Check</span> eq_refl : interleave4 [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>] = [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">5</span>; <span class="mi">3</span>; <span class="mi">6</span>].</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">eq_refl
:
interleave4 [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>] = [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">5</span>; <span class="mi">3</span>; <span class="mi">6</span>]
     : interleave4 [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>] =
       [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">5</span>; <span class="mi">3</span>; <span class="mi">6</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="teach-coq-to-check-termination-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="teach-coq-to-check-termination-v-chk25"><span class="kn">Check</span> eq_refl : interleave5 [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>] = [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">5</span>; <span class="mi">3</span>; <span class="mi">6</span>].</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">eq_refl
:
interleave5 [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>] = [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">5</span>; <span class="mi">3</span>; <span class="mi">6</span>]
     : interleave5 [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>] =
       [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">5</span>; <span class="mi">3</span>; <span class="mi">6</span>]</blockquote></div></div></small></span></pre><p>Exercise: what happens with this last check if you comment out
<tt class="docutils literal">destruct_list</tt> lemma?</p>
</div>
</div>
</div>
</div>
</div></body>
</html>
