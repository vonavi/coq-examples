<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Decreasing argument (and what is a Program Fixpoint)</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="decreasing-argument-and-what-is-a-program-fixpoint">
<h1 class="title">Decreasing argument (and what is a <span class="docutils literal">Program Fixpoint</span>)</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/47816742">https://stackoverflow.com/q/47816742</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>Consider the following fixpoint:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Lists.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">my_type</span>: <span class="kt">Type</span>:=
| Left: my_type
| Right: my_type.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decreasing-argument-and-what-is-a-program-fixpoint-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="decreasing-argument-and-what-is-a-program-fixpoint-v-chk0"><span class="kn">Fixpoint</span> <span class="nf">decrease</span> (<span class="nv">which</span> : my_type) (<span class="nv">left</span> <span class="nv">right</span> : list my_type) :
  list my_type :=
  <span class="kr">match</span> which <span class="kr">with</span>
  | Left =&gt;
      <span class="kr">match</span> <span class="nb">left with</span>
      | [] =&gt; []
      | a::tl =&gt; decrease a tl <span class="nb">right</span>
      <span class="kr">end</span>
  | Right =&gt;
      <span class="kr">match</span> <span class="nb">right with</span>
      | [] =&gt; []
      | a::tl =&gt; decrease a <span class="nb">left</span> tl
      <span class="kr">end</span>
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Cannot guess decreasing argument of <span class="kr">fix</span>.</blockquote></div></div></small></span></pre><p>Coq rejects the following fixpoint because it can not guess the
decreasing fixpoint (sometimes the <span class="docutils literal">left</span> list looses its head,
sometimes it is the <span class="docutils literal">right</span> one).</p>
<p>This <a class="reference external" href="https://stackoverflow.com/questions/33302526/well-founded-recursion-in-coq">answer</a>
shows that one can solve this by using a <span class="docutils literal">Program Fixpoint</span> and
specifying a <span class="docutils literal">{measure ((length <span class="pre">left)+(length</span> <span class="pre">right))}</span></span>.</p>
<p>My questions are:</p>
<ul class="simple">
<li><p>What is the difference between a regular <span class="docutils literal">Fixpoint</span> and a
<span class="docutils literal">Program Fixpoint</span>?</p></li>
<li><p>Is it possible to explicit the decreasing argument in a regular
<span class="docutils literal">Fixpoint</span>?</p></li>
<li><p>What is the <span class="docutils literal">Next Obligation</span> goal?</p></li>
</ul>
</section>
<section id="answer">
<h2>Answer</h2>
<ul>
<li><p>The <span class="docutils literal">Fixpoint</span> command in Coq constructs a recursive function
using Coq's primitive <span class="docutils literal">fix</span>, which checks for structural recursion
to ensure termination. This is the only recursion in Coq, and all
other techniques ultimately desugar to a <span class="docutils literal">fix</span> of some sort.</p>
<p><span class="docutils literal">Program Fixpoint</span> is a feature of <a class="reference external" href="https://coq.inria.fr/refman/program.html">Program</a>, which allows writing
definitions in a slightly extended language that are then compiled
into Coq definitions. <span class="docutils literal">Program Fixpoint</span> accepts any recursive
function, generates an appropriate proof obligation that shows the
function terminates (by decreasing some measure of its arguments on
each recursive subcall), and then packages up the definition and
termination proof into a Coq definition that structurally decreases
an argument. If that sounds magical it basically is, but <a class="reference external" href="http://adam.chlipala.net/cpdt/html/GeneralRec.html">CPDT</a> gives a good
explanation of how to do this kind of encoding.</p>
</li>
<li><p>Yes, you can add a <span class="docutils literal">{struct arg}</span> annotation to explicitly specify
<em>which argument is structurally decreasing</em>: <span class="docutils literal">Fixpoint decrease (which: my_type) (left right: list my_type) {struct right} : list my_type</span>. This doesn't help for your example, since your function
doesn't in general structurally decrease either argument. All
primitive <span class="docutils literal">fix</span> constructs have a <span class="docutils literal">struct</span> annotation, but Coq
can usually infer it automatically when you write a <span class="docutils literal">Fixpoint</span>.
For example, here's <span class="docutils literal">Nat.add</span>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="decreasing-argument-and-what-is-a-program-fixpoint-v-chk1" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Nat.add = 
<span class="kr">fix</span> add (n m : nat) {<span class="kr">struct</span> n} : nat :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; m
  | S p =&gt; S (add p m)
  <span class="kr">end</span>
     : nat -&gt; nat -&gt; nat

<span class="kn">Arguments</span> Nat.add (_ _)%nat_scope</blockquote></div></div></small></span></pre></li>
<li><p>You get two types of goals from <span class="docutils literal">Next Obligation</span> with <span class="docutils literal">Program Fixpoint</span>: first that each subcall has a smaller argument (using
<span class="docutils literal">measure</span>, &quot;smaller&quot; is defined using &lt; on nats), and second, that
the &quot;smaller&quot; relation is well-founded; this is, it has no
infinitely descending sequences of smaller and smaller objects. I'm
not sure why <span class="docutils literal">Program Fixpoint</span> doesn't do this automatically for
<span class="docutils literal">Nat.lt</span>, given that it should know the relevant theorem. Note
that <span class="docutils literal">Program</span> has more features than just more general recursion,
so it can generate other goals related to those features as well,
depending on the definition you write.</p></li>
</ul>
</section>
</div>
</main>
</div></body>
</html>
