<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Case analysis on evidence of equality type in Coq</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="case-analysis-on-evidence-of-equality-type-in-coq">
<h1 class="title">Case analysis on evidence of equality type in Coq</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/48161372">https://stackoverflow.com/q/48161372</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>I have a query about inductively defined relation <span class="docutils literal">eq</span> in Coq.
Consider the following definition of <span class="docutils literal">eq</span> in Coq:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="case-analysis-on-evidence-of-equality-type-in-coq-v-chk0" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Inductive</span> <span class="nf">eq</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : A) : A -&gt; <span class="kt">Prop</span> :=
    eq_refl : x = x

<span class="kn">Arguments</span> eq {A}%type_scope _ _
<span class="kn">Arguments</span> eq_refl {A}%type_scope {x}, [_] _</blockquote></div></div></small></span></pre><p>This is an inductively defined relation just like <span class="docutils literal">Le</span> (<span class="docutils literal">&lt;=</span>).
Therefore I should be able to do case analysis on any evidence of this
type. However, when I tried proving the following result I could not
succeed.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="case-analysis-on-evidence-of-equality-type-in-coq-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="case-analysis-on-evidence-of-equality-type-in-coq-v-chk1"><span class="kn">Lemma</span> <span class="nf">true_num</span> : <span class="kr">forall</span> <span class="nv">m</span> : nat, <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : m = m, x = y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">x</span> <span class="nv">y</span> : m = m), x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="case-analysis-on-evidence-of-equality-type-in-coq-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="case-analysis-on-evidence-of-equality-type-in-coq-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">x</span> <span class="nv">y</span> : m = m), x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="case-analysis-on-evidence-of-equality-type-in-coq-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="case-analysis-on-evidence-of-equality-type-in-coq-v-chk3"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>m = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="case-analysis-on-evidence-of-equality-type-in-coq-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="case-analysis-on-evidence-of-equality-type-in-coq-v-chk4"><span class="nb">destruct</span> x.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Abstracting <span class="nb">over</span> the terms <span class="s2">&quot;m&quot;</span> <span class="kn">and</span> <span class="s2">&quot;x&quot;</span> leads to a term
<span class="kr">fun</span> (<span class="nv">m0</span> : nat) (<span class="nv">x0</span> : m0 = m0) =&gt; x0 = y
which <span class="kr">is</span> ill-typed.
Reason <span class="kr">is</span>: Illegal application: 
The term <span class="s2">&quot;@eq&quot;</span> of type
 <span class="s2">&quot;forall A : Type, A -&gt; A -&gt; Prop&quot;</span>
cannot be applied to the terms
 <span class="s2">&quot;m0 = m0&quot;</span> : <span class="s2">&quot;Prop&quot;</span>
 <span class="s2">&quot;x0&quot;</span> : <span class="s2">&quot;m0 = m0&quot;</span>
 <span class="s2">&quot;y&quot;</span> : <span class="s2">&quot;m = m&quot;</span>
The <span class="mi">3</span>rd term has type <span class="s2">&quot;m = m&quot;</span>
which should be coercible to <span class="s2">&quot;m0 = m0&quot;</span>.</blockquote></div></div></small></span></pre><p>I am unable to decode this error.</p>
<p>The only proof for <span class="docutils literal">m = m</span> should be <span class="docutils literal">&#64;eq_refl nat m</span> since
<span class="docutils literal">eq_refl</span> is the only constructor. Hence one should be able to prove
the equality of <span class="docutils literal">x</span> and <span class="docutils literal">y</span> by doing case analysis.</p>
<p>What is wrong with this line of reasoning?</p>
</section>
<section id="answer-ejgallego">
<h2>Answer (ejgallego)</h2>
<p>The error is due to the way <span class="docutils literal">destruct</span> works, recall that the tactic
tries to build a match statement, and in order to do so it has some
heuristics as to bring dependent hypotheses into context.</p>
<p>In particular, in this case it tries to abstract over the variable
<span class="docutils literal">m</span>, which is an index to the <span class="docutils literal">eq</span> inductive in <span class="docutils literal">y : m = m</span>;
however <span class="docutils literal">y</span> is not brought into context, hence the error as <span class="docutils literal">m != m0</span> [with <span class="docutils literal">m0</span> being the abstracted <span class="docutils literal">m</span>]. You can workaround that
problem it by doing a &quot;less smart&quot; match, which won't modify <span class="docutils literal">m</span>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="case-analysis-on-evidence-of-equality-type-in-coq-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="case-analysis-on-evidence-of-equality-type-in-coq-v-chk5"><span class="nb">refine</span> (<span class="kr">match</span> x <span class="kr">with</span> | @eq_refl _ _ =&gt; _ <span class="kr">end</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>m = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span></pre><p>but usually, the best solution is to bring the hypothesis at fault
into scope:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="case-analysis-on-evidence-of-equality-type-in-coq-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="case-analysis-on-evidence-of-equality-type-in-coq-v-chk6"><span class="nb">revert</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>m = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : m = m, x = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="case-analysis-on-evidence-of-equality-type-in-coq-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="case-analysis-on-evidence-of-equality-type-in-coq-v-chk7"><span class="nb">destruct</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : m = m, eq_refl = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>On the other hand, to prove your goal simple pattern-matching won't
suffice as pointed out by the other excellent answers. My preferred
practical approach to solve goals like yours is to use a library:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="case-analysis-on-evidence-of-equality-type-in-coq-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="case-analysis-on-evidence-of-equality-type-in-coq-v-chk8"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> all_ssreflect.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ | _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ : _ | _ ]&quot;</span> was already used <span class="kr">in</span>
scope fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ &amp; _ | _ ]&quot;</span> was already used
<span class="kr">in</span> scope fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span>
scope fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ | _ ]&quot;</span> was already used <span class="kr">in</span>
scope fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ + _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ - _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ * _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="case-analysis-on-evidence-of-equality-type-in-coq-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="case-analysis-on-evidence-of-equality-type-in-coq-v-chk9"><span class="kn">Lemma</span> <span class="nf">true_num</span> (<span class="nv">m</span> : nat) (<span class="nv">x</span> <span class="nv">y</span> : m = m) : x = y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>m = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="case-analysis-on-evidence-of-equality-type-in-coq-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="case-analysis-on-evidence-of-equality-type-in-coq-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>m = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: eq_irrelevance.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>In this case, the proper side conditions for the <span class="docutils literal">nat</span> type are
inferred automatically by the machinery of the library.</p>
</section>
<section id="answer-jason-gross">
<h2>Answer (Jason Gross)</h2>
<blockquote>
<p>The only proof for <span class="docutils literal">m = m</span> should be <span class="docutils literal">&#64;eq_refl nat m</span> since
<span class="docutils literal">eq_refl</span> is the only constructor</p>
</blockquote>
<p>No. Your theorem happens to be true because you are talking about
equality of <span class="docutils literal">nat</span>, but your reasoning goes through just as well (or
poorly) if you replace <span class="docutils literal">nat</span> with <span class="docutils literal">Type</span>, and replacing <span class="docutils literal">nat</span>
with <span class="docutils literal">Type</span> makes the theorem unprovable.</p>
<p>The issue is that the equality type <em>family is freely generated</em> by
the reflexively proof. Therefore, since everything in Coq respects
equality in the right way (this is the bit I'm a bit fuzzy on), to
prove a property of all proofs of equality in a family (i.e. all
proofs of <span class="docutils literal">x = y</span> for some fixed <span class="docutils literal">x</span> and <em>for all</em> <span class="docutils literal">y</span>), it
suffices to prove the property of the generator, the reflexively
proof. However, once you fix both endpoints, so to speak, you no
longer have this property. Said another way, the induction principle
for <span class="docutils literal">eq</span> is really an induction principle for <span class="docutils literal">{ y | x = y }</span>, not
for <span class="docutils literal">x = y</span>. Similarly, the induction principle for vectors
(length-indexed lists) is really an induction principle for <span class="docutils literal">{ n &amp; Vector.t A n }</span>.</p>
<p>To decode the error messages, it might help to try manually applying
the induction principle for <span class="docutils literal">eq</span>. The induction principle states:
given a type <span class="docutils literal">A</span>, a term <span class="docutils literal">x : A</span>, and a property <span class="docutils literal">P : forall y : A, x = y <span class="pre">-&gt;</span> Prop</span>, to prove <span class="docutils literal">P y e</span> for any given <span class="docutils literal">y : A</span> and any
proof <span class="docutils literal">e : x = y</span>, it suffices to prove <span class="docutils literal">P x eq_refl</span>. (To see why
this makes sense, consider the non dependent version: given a type
<span class="docutils literal">A</span>, a term <span class="docutils literal">x : A</span>, and a property <span class="docutils literal">P : A <span class="pre">-&gt;</span> Prop</span>, for any <span class="docutils literal">y : A</span> and any proof <span class="docutils literal">e : x = y</span>, to prove <span class="docutils literal">P y</span>, it suffices to
prove <span class="docutils literal">P x</span>.)</p>
<p>If you try applying this by hand, you will find that there is no way
to construct a well-typed function <span class="docutils literal">P</span> when you are trying to induct
over the second proof of equality.</p>
<p>There is an excellent blog post that explains this in much more depth here: <a class="reference external" href="http://math.andrej.com/2013/08/28/the-elements-of-an-inductive-type/">http://math.andrej.com/2013/08/28/the-elements-of-an-inductive-type/</a></p>
</section>
</div>
</main>
</div></body>
</html>
