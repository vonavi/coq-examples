<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>How to use a custom induction principle in Coq?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="how-to-use-a-custom-induction-principle-in-coq">
<h1 class="title">How to use a custom induction principle in Coq?</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/33071903">https://stackoverflow.com/q/33071903</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>I read that the induction principle for a type is just a theorem about
a proposition <tt class="docutils literal">P</tt>. So I constructed an induction principle for
<tt class="docutils literal">List</tt> based on the right (or reverse) list constructor.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rcons</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list X) (<span class="nv">x</span> : X) : list X :=
  l ++ x :: nil.</span></span></pre><p>The induction principle itself is:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">true_for_nil</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : list X -&gt; <span class="kt">Prop</span>) : <span class="kt">Prop</span> :=
  P nil.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">true_for_list</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : list X -&gt; <span class="kt">Prop</span>) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">xs</span>, P xs.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">preserved_by_rcons</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : list X -&gt; <span class="kt">Prop</span>) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">xs&#39;</span> <span class="nv">x</span>, P xs&#39; -&gt; P (rcons xs&#39; x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-use-a-custom-induction-principle-in-coq-v-chk0"><span class="kn">Theorem</span> <span class="nf">list_ind_rcons</span> :
  <span class="kr">forall</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : list X -&gt; <span class="kt">Prop</span>),
    true_for_nil P -&gt;
    preserved_by_rcons P -&gt;
    true_for_list P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : list X -&gt; <span class="kt">Prop</span>),
true_for_nil P -&gt;
preserved_by_rcons P -&gt; true_for_list P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-use-a-custom-induction-principle-in-coq-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : list X -&gt; <span class="kt">Prop</span>),
true_for_nil P -&gt;
preserved_by_rcons P -&gt; true_for_list P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span></span></pre><p>But now, I am having trouble using the theorem. I don't how to invoke
it to achieve the same as the <tt class="docutils literal">induction</tt> tactic.</p>
<p>For example, I tried:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-use-a-custom-induction-principle-in-coq-v-chk2"><span class="kn">Theorem</span> <span class="nf">rev_app_dist</span> : <span class="kr">forall</span> {<span class="nv">X</span>} (<span class="nv">l1</span> <span class="nv">l2</span> : list X),
    rev (l1 ++ l2) = rev l2 ++ rev l1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list X),
rev (l1 ++ l2) = rev l2 ++ rev l1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-use-a-custom-induction-principle-in-coq-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list X),
rev (l1 ++ l2) = rev l2 ++ rev l1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-use-a-custom-induction-principle-in-coq-v-chk4"><span class="nb">intros</span> X l1 l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev (l1 ++ l2) = rev l2 ++ rev l1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="how-to-use-a-custom-induction-principle-in-coq-v-chk5"><span class="nb">induction</span> l2 <span class="nb">using</span> list_ind_rcons.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Cannot recognize an <span class="nb">induction</span> scheme.</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev (l1 ++ l2) = rev l2 ++ rev l1</div></blockquote></div></div></small></span></pre><p>But in the last line, I got:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chk6" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
Cannot recognize an <span class="nb">induction</span> scheme.</blockquote></div></div></small></span></pre><p>What are the correct steps to define and apply a custom induction
principle like <tt class="docutils literal">list_ind_rcons</tt>?</p>
</div>
<div class="section" id="answer-anton-trunov">
<h1>Answer (Anton Trunov)</h1>
<p>If one would like to preserve the intermediate definitions, then one
could use the <tt class="docutils literal">Section</tt> mechanism, like so:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Lists.List.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rcons</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list X) (<span class="nv">x</span> : X) : list X :=
  l ++ [x].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">custom_induction_principle</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">X</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">P</span> : list X -&gt; <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hypothesis</span> <span class="nv">true_for_nil</span> : P nil.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hypothesis</span> <span class="nv">true_for_list</span> : <span class="kr">forall</span> <span class="nv">xs</span>, P xs.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hypothesis</span> <span class="nv">preserved_by_rcons</span> : <span class="kr">forall</span> <span class="nv">xs&#39;</span> <span class="nv">x</span>, P xs&#39; -&gt; P (rcons xs&#39; x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-use-a-custom-induction-principle-in-coq-v-chk7"><span class="kn">Fixpoint</span> <span class="nf">list_ind_rcons</span> (<span class="nv">xs</span> : list X) : P xs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list X -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>true_for_nil</var><span class="hyp-type"><b>: </b><span>P []</span></span></span><br><span><var>true_for_list</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : list X, P xs</span></span></span><br><span><var>preserved_by_rcons</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">xs&#39;</span> : list X) (<span class="nv">x</span> : X),
P xs&#39; -&gt; P (rcons xs&#39; x)</span></span></span><br><span><var>list_ind_rcons</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : list X, P xs</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P xs</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">custom_induction_principle</span>.</span></span></pre><p>Coq substitutes the definitions and <tt class="docutils literal">list_ind_rcons</tt> has the needed
type and <tt class="docutils literal">induction ... using ...</tt> works:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-use-a-custom-induction-principle-in-coq-v-chk8"><span class="kn">Theorem</span> <span class="nf">rev_app_dist</span> : <span class="kr">forall</span> {<span class="nv">X</span>} (<span class="nv">l1</span> <span class="nv">l2</span> : list X),
    rev (l1 ++ l2) = rev l2 ++ rev l1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list X),
rev (l1 ++ l2) = rev l2 ++ rev l1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-use-a-custom-induction-principle-in-coq-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list X),
rev (l1 ++ l2) = rev l2 ++ rev l1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-use-a-custom-induction-principle-in-coq-v-chka"><span class="nb">intros</span> X l1 l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev (l1 ++ l2) = rev l2 ++ rev l1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-use-a-custom-induction-principle-in-coq-v-chkb"><span class="nb">induction</span> l2 <span class="nb">using</span> list_ind_rcons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev (l1 ++ []) = rev [] ++ rev l1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><label class="goal-separator" for="how-to-use-a-custom-induction-principle-in-coq-v-chkc"><hr></label><div class="goal-conclusion">rev (l1 ++ l2) = rev l2 ++ rev l1</div></blockquote><input class="alectryon-extra-goal-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>IHl2</var><span class="hyp-type"><b>: </b><span>rev (l1 ++ l2) = rev l2 ++ rev l1</span></span></span><br></div><label class="goal-separator" for="how-to-use-a-custom-induction-principle-in-coq-v-chkd"><hr></label><div class="goal-conclusion">rev (l1 ++ rcons l2 x) = rev (rcons l2 x) ++ rev l1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><p>By the way, this induction principle is present in the standard
library (<a class="reference external" href="https://coq.inria.fr/library/Coq.Lists.List.html">List</a>
module):</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-use-a-custom-induction-principle-in-coq-v-chke"><span class="kn">Check</span> rev_ind.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">rev_ind
     : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : list A -&gt; <span class="kt">Prop</span>),
       P [] -&gt;
       (<span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">l</span> : list A),
        P l -&gt; P (l ++ [x])) -&gt; <span class="kr">forall</span> <span class="nv">l</span> : list A, P l</blockquote></div></div></small></span></pre></div>
<div class="section" id="answer-arthur-azevedo-de-amorim">
<h1>Answer (Arthur Azevedo De Amorim)</h1>
<p>What you did was mostly correct. The problem is that Coq has some
trouble recognizing that what you wrote is an induction principle,
because of the intermediate definitions. This, for instance, works
just fine:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-use-a-custom-induction-principle-in-coq-v-chkf"><span class="kn">Theorem</span> <span class="nf">list_ind_rcons</span> :
  <span class="kr">forall</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : list X -&gt; <span class="kt">Prop</span>),
    P nil -&gt;
    (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">l</span>, P l -&gt; P (rcons l x)) -&gt;
    <span class="kr">forall</span> <span class="nv">l</span>, P l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : list X -&gt; <span class="kt">Prop</span>),
P nil -&gt;
(<span class="kr">forall</span> (<span class="nv">x</span> : X) (<span class="nv">l</span> : list X), P l -&gt; P (rcons l x)) -&gt;
<span class="kr">forall</span> <span class="nv">l</span> : list X, P l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-use-a-custom-induction-principle-in-coq-v-chk10"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : list X -&gt; <span class="kt">Prop</span>),
P nil -&gt;
(<span class="kr">forall</span> (<span class="nv">x</span> : X) (<span class="nv">l</span> : list X), P l -&gt; P (rcons l x)) -&gt;
<span class="kr">forall</span> <span class="nv">l</span> : list X, P l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-use-a-custom-induction-principle-in-coq-v-chk11"><span class="kn">Theorem</span> <span class="nf">rev_app_dist</span> : <span class="kr">forall</span> {<span class="nv">X</span>} (<span class="nv">l1</span> <span class="nv">l2</span> : list X),
    rev (l1 ++ l2) = rev l2 ++ rev l1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list X),
rev (l1 ++ l2) = rev l2 ++ rev l1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-use-a-custom-induction-principle-in-coq-v-chk12"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list X),
rev (l1 ++ l2) = rev l2 ++ rev l1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-use-a-custom-induction-principle-in-coq-v-chk13"><span class="nb">intros</span> X l1 l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev (l1 ++ l2) = rev l2 ++ rev l1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-use-a-custom-induction-principle-in-coq-v-chk14"><span class="nb">induction</span> l2 <span class="nb">using</span> @list_ind_rcons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev (l1 ++ nil) = rev nil ++ rev l1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-use-a-custom-induction-principle-in-coq-v-chk15" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>IHl2</var><span class="hyp-type"><b>: </b><span>rev (l1 ++ l2) = rev l2 ++ rev l1</span></span></span><br></div><label class="goal-separator" for="how-to-use-a-custom-induction-principle-in-coq-v-chk15"><hr></label><div class="goal-conclusion">rev (l1 ++ rcons l2 x) = rev (rcons l2 x) ++ rev l1</div></blockquote></div></div></div></small></span></pre><p>I don't know if Coq not being able to automatically unfold the
intermediate definitions should be considered a bug or not, but at
least there is a workaround.</p>
<hr class="docutils" />
<p><strong>A:</strong> In Coq, there is long standing disrespect for definitional
equality in the implementation of tactics. Whilst this is
questionable, ideologically, it is far too late to do anything about
it in practice.</p>
</div>
</div>
</div>
</div></body>
</html>
