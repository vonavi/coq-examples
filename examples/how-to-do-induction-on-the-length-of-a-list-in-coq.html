<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>How to do induction on the length of a list in Coq?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="how-to-do-induction-on-the-length-of-a-list-in-coq">
<h1 class="title">How to do induction on the length of a list in Coq?</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/45872719">https://stackoverflow.com/q/45872719</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>When reasoning on paper, I often use arguments by induction on the
length of some list. I want to formalized these arguments in Coq, but
there doesn't seem to be any built in way to do induction on the
length of a list.</p>
<p>How should I perform such an induction?</p>
<p>More concretely, I am trying to prove <a class="reference external" href="http://pastebin.ubuntu.com/25386445/">this theorem</a>. On paper, I proved it by
induction on the length of <tt class="docutils literal">w</tt>. My goal is to formalize this proof
in Coq.</p>
</div>
<div class="section" id="answer-yves">
<h1>Answer (Yves)</h1>
<p>There are many general patterns of induction like this one that can be
covered by the existing library on well founded induction. In this
case, you can prove any property P by induction on length of lists by
using <tt class="docutils literal">well_founded_induction</tt>, <tt class="docutils literal">wf_inverse_image</tt>, and
<tt class="docutils literal">PeanoNat.Nat.lt_wf_0</tt>, as in the following command:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk0"><span class="nb">induction</span> l <span class="nb">using</span> (well_founded_induction
                       (wf_inverse_image _ nat _ (@length _)
                                         PeanoNat.Nat.lt_wf_0)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list T -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list T, length y &lt; length l -&gt; P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>if you are working with lists of type <tt class="docutils literal">T</tt> and proving a goal <tt class="docutils literal">P
l</tt>, this generates an hypothesis of the form</p>
<pre class="code coq literal-block">
<span class="n">H</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">y</span> <span class="o">:</span> <span class="n">list</span> <span class="n">T</span><span class="o">,</span> <span class="n">length</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="n">P</span> <span class="n">y</span>
</pre>
<p>This will apply to any other datatype (like trees for instance) as
long as you can map that other datatype to <tt class="docutils literal">nat</tt> using any size
function from that datatype to <tt class="docutils literal">nat</tt> instead of <tt class="docutils literal">length</tt>.</p>
<p>Note that you need to add <tt class="docutils literal">Require Import Wellfounded.</tt> at the head
of your development for this to work.</p>
<hr class="docutils" />
<p><strong>A:</strong> Here is a slightly shorter variant:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk1"><span class="nb">induction</span> xs <span class="nb">using</span> (induction_ltof1 _ (@length _)); <span class="nb">unfold</span> ltof <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list T -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list T, length y &lt; length xs -&gt; P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P xs</div></blockquote></div></div></small></span></pre><p>But I'd prefer explicit naming:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk2"><span class="nb">induction</span> xs <span class="kr">as</span> [xs IHxs] <span class="nb">using</span> (induction_ltof1 _ (@length _));
    <span class="nb">unfold</span> ltof <span class="kr">in</span> IHxs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list T -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list T, length y &lt; length xs -&gt; P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre></div>
<div class="section" id="answer-james-wilcox">
<h1>Answer (James Wilcox)</h1>
<p>Here is how to prove a general list-length induction principle.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> List Lia.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">list_length_ind</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">A</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">P</span> : list A -&gt; <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hypothesis</span> <span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">xs</span>, (<span class="kr">forall</span> <span class="nv">l</span>, length l &lt; length xs -&gt; P l) -&gt; P xs.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk3"><span class="kn">Theorem</span> <span class="nf">list_length_ind</span> : <span class="kr">forall</span> <span class="nv">xs</span>, P xs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : list A,
(<span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt; length xs -&gt; P l) -&gt;
P xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">xs</span> : list A, P xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : list A,
(<span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt; length xs -&gt; P l) -&gt;
P xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">xs</span> : list A, P xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk5"><span class="nb">assert</span> (<span class="kr">forall</span> <span class="nv">xs</span> <span class="nv">l</span> : list A, length l &lt;= length xs -&gt; P l) <span class="kr">as</span> H_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : list A,
(<span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt; length xs -&gt; P l) -&gt;
P xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">xs</span> <span class="nv">l</span> : list A, length l &lt;= length xs -&gt; P l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : list A,
(<span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt; length xs -&gt; P l) -&gt;
P xs</span></span></span><br><span><var>H_ind</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> <span class="nv">l</span> : list A,
length l &lt;= length xs -&gt; P l</span></span></span><br></div><label class="goal-separator" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk6"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">xs</span> : list A, P xs</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk7">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : list A,
(<span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt; length xs -&gt; P l) -&gt;
P xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">xs</span> <span class="nv">l</span> : list A, length l &lt;= length xs -&gt; P l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk8"><span class="nb">induction</span> xs; <span class="nb">intros</span> l Hlen; <span class="nb">apply</span> H; <span class="nb">intros</span> l0 H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : list A,
(<span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt; length xs -&gt; P l) -&gt;
P xs</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>length l &lt;= length nil</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>length l0 &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P l0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : list A,
(<span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt; length xs -&gt; P l) -&gt;
P xs</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt;= length xs -&gt; P l</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>length l &lt;= length (a :: xs)</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>length l0 &lt; length l</span></span></span><br></div><label class="goal-separator" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk9"><hr></label><div class="goal-conclusion">P l0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chka">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : list A,
(<span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt; length xs -&gt; P l) -&gt;
P xs</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>length l &lt;= length nil</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>length l0 &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P l0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chkb"><span class="nb">inversion</span> Hlen.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : list A,
(<span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt; length xs -&gt; P l) -&gt;
P xs</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>length l &lt;= length nil</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>length l0 &lt; length l</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>length l = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P l0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chkc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : list A,
(<span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt; length xs -&gt; P l) -&gt;
P xs</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt;= length xs -&gt; P l</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>length l &lt;= length (a :: xs)</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>length l0 &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P l0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chkd"><span class="nb">apply</span> IHxs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : list A,
(<span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt; length xs -&gt; P l) -&gt;
P xs</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt;= length xs -&gt; P l</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>length l &lt;= length (a :: xs)</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>length l0 &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length l0 &lt;= length xs</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chke"><span class="nb">simpl</span> <span class="kr">in</span> Hlen.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : list A,
(<span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt; length xs -&gt; P l) -&gt;
P xs</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt;= length xs -&gt; P l</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>length l &lt;= S (length xs)</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>length l0 &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length l0 &lt;= length xs</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chkf">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : list A,
(<span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt; length xs -&gt; P l) -&gt;
P xs</span></span></span><br><span><var>H_ind</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> <span class="nv">l</span> : list A,
length l &lt;= length xs -&gt; P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">xs</span> : list A, P xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk10"><span class="nb">intros</span> xs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : list A,
(<span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt; length xs -&gt; P l) -&gt;
P xs</span></span></span><br><span><var>H_ind</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> <span class="nv">l</span> : list A,
length l &lt;= length xs -&gt; P l</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P xs</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk11"><span class="nb">apply</span> H_ind <span class="kr">with</span> (xs := xs).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : list A,
(<span class="kr">forall</span> <span class="nv">l</span> : list A, length l &lt; length xs -&gt; P l) -&gt;
P xs</span></span></span><br><span><var>H_ind</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> <span class="nv">l</span> : list A,
length l &lt;= length xs -&gt; P l</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length xs &lt;= length xs</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">list_length_ind</span>.</span></span></pre><p>You can use it like this</p>
<pre class="code coq literal-block">
<span class="kn">Theorem</span> <span class="nf">foo</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span><span class="o">,</span> <span class="o">...</span>
<span class="kn">Proof</span><span class="o">.</span>
  <span class="nb">induction</span> <span class="n">l</span> <span class="nb">using</span> <span class="n">list_length_ind</span><span class="o">.</span>
  <span class="o">...</span>
</pre>
<p>That said, your concrete example example does not necessarily need
induction on the length. You just need a sufficiently general
induction hypothesis.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Init.Nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Arith.PeanoNat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Lists.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ... some definitions elided here ... *)</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">flip_state</span> (<span class="nv">s</span> : state) :=
  <span class="kr">match</span> s <span class="kr">with</span>
  | A =&gt; B
  | B =&gt; A
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">delta</span> (<span class="nv">s</span> : state) (<span class="nv">n</span> : input) : state :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | zero =&gt; s
  | one =&gt; flip_state s
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ...some more definitions elided here ...*)</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk12"><span class="kn">Theorem</span> <span class="nf">automata221</span> : <span class="kr">forall</span> (<span class="nv">w</span> : list input),
    extend_delta A w = B &lt;-&gt; Nat.odd (one_num w) = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">w</span> : list input,
extend_delta A w = B &lt;-&gt; Nat.odd (one_num w) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk13"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">w</span> : list input,
extend_delta A w = B &lt;-&gt; Nat.odd (one_num w) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk14"><span class="nb">assert</span> (<span class="kr">forall</span> <span class="nv">w</span> <span class="nv">s</span>, extend_delta s w = <span class="kr">if</span> Nat.odd (one_num w)
                                         <span class="kr">then</span> flip_state s
                                         <span class="kr">else</span> s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">w</span> : list input) (<span class="nv">s</span> : state),
extend_delta s w =
(<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk15" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">w</span> : list input) (<span class="nv">s</span> : state),
extend_delta s w =
(<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</span></span></span><br></div><label class="goal-separator" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk15"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">w</span> : list input,
extend_delta A w = B &lt;-&gt; Nat.odd (one_num w) = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk16">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">w</span> : list input) (<span class="nv">s</span> : state),
extend_delta s w =
(<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk17"><span class="nb">induction</span> w <span class="kr">as</span> [|i w]; <span class="nb">intros</span> s; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s = s</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk18" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>input</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list input</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> : state,
extend_delta s w = (<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br></div><label class="goal-separator" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk18"><hr></label><div class="goal-conclusion">delta (extend_delta s w) i =
(<span class="kr">if</span>
  Nat.odd
    <span class="kr">match</span> i <span class="kr">with</span>
    | zero =&gt; one_num w
    | one =&gt; S (one_num w)
    <span class="kr">end</span>
 <span class="kr">then</span> flip_state s
 <span class="kr">else</span> s)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk19">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s = s</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk1a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>input</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list input</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> : state,
extend_delta s w = (<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta (extend_delta s w) i =
(<span class="kr">if</span>
  Nat.odd
    <span class="kr">match</span> i <span class="kr">with</span>
    | zero =&gt; one_num w
    | one =&gt; S (one_num w)
    <span class="kr">end</span>
 <span class="kr">then</span> flip_state s
 <span class="kr">else</span> s)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk1b"><span class="nb">rewrite</span> IHw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>input</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list input</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> : state,
extend_delta s w = (<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta
  (<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s) i =
(<span class="kr">if</span>
  Nat.odd
    <span class="kr">match</span> i <span class="kr">with</span>
    | zero =&gt; one_num w
    | one =&gt; S (one_num w)
    <span class="kr">end</span>
 <span class="kr">then</span> flip_state s
 <span class="kr">else</span> s)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk1c"><span class="nb">destruct</span> i; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>w</var><span class="hyp-type"><b>: </b><span>list input</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> : state,
extend_delta s w = (<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s) =
(<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk1d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>w</var><span class="hyp-type"><b>: </b><span>list input</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> : state,
extend_delta s w = (<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br></div><label class="goal-separator" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk1d"><hr></label><div class="goal-conclusion">flip_state
  (<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s) =
(<span class="kr">if</span> Nat.odd (S (one_num w)) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk1e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>w</var><span class="hyp-type"><b>: </b><span>list input</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> : state,
extend_delta s w = (<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s) =
(<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk1f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>w</var><span class="hyp-type"><b>: </b><span>list input</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> : state,
extend_delta s w = (<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flip_state
  (<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s) =
(<span class="kr">if</span> Nat.odd (S (one_num w)) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk20"><span class="nb">rewrite</span> &lt;- Nat.negb_even, Nat.odd_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>w</var><span class="hyp-type"><b>: </b><span>list input</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span> : state,
extend_delta s w = (<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flip_state
  (<span class="kr">if</span> negb (Nat.even (one_num w))
   <span class="kr">then</span> flip_state s
   <span class="kr">else</span> s) =
(<span class="kr">if</span> Nat.even (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (Nat.even (one_num w)), s; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk21">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">w</span> : list input) (<span class="nv">s</span> : state),
extend_delta s w =
(<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">w</span> : list input,
extend_delta A w = B &lt;-&gt; Nat.odd (one_num w) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk22"><span class="nb">intros</span> w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">w</span> : list input) (<span class="nv">s</span> : state),
extend_delta s w =
(<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list input</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extend_delta A w = B &lt;-&gt; Nat.odd (one_num w) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk23"><span class="nb">rewrite</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">w</span> : list input) (<span class="nv">s</span> : state),
extend_delta s w =
(<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list input</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state A <span class="kr">else</span> A) = B &lt;-&gt;
Nat.odd (one_num w) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk24"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">w</span> : list input) (<span class="nv">s</span> : state),
extend_delta s w =
(<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> flip_state s <span class="kr">else</span> s)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list input</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> Nat.odd (one_num w) <span class="kr">then</span> B <span class="kr">else</span> A) = B &lt;-&gt;
Nat.odd (one_num w) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (Nat.odd (one_num w)); <span class="nb">intuition</span> <span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="answer-ejgallego">
<h1>Answer (ejgallego)</h1>
<p>In case like this, it is often faster to generalize your lemma
directly:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk25"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> all_ssreflect.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ | _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ : _ | _ ]&quot;</span> was already used <span class="kr">in</span>
scope fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ &amp; _ | _ ]&quot;</span> was already used
<span class="kr">in</span> scope fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span>
scope fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ | _ ]&quot;</span> was already used <span class="kr">in</span>
scope fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ + _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ - _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ * _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unset Strict Implicit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unset Printing Implicit Defensive</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">SO</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">T</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> (<span class="nv">s</span> : seq T) (<span class="nv">P</span> : seq T -&gt; <span class="kt">Prop</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk26"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">P</span> <span class="nv">s</span> : P s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>seq T -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>seq T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk27"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>seq T -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>seq T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk28"><span class="nb">move</span>: {<span class="mi">2</span>}(size _) (leqnn (size s)) =&gt; ss; <span class="nb">elim</span>: ss s =&gt; [|ss ihss] s hs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>seq T -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>seq T</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>size s &lt;= <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P s</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk29" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>seq T -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>ss</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ihss</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">s</span>, size s &lt;= ss -&gt; P s</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>seq T</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>size s &lt;= ss.+<span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="how-to-do-induction-on-the-length-of-a-list-in-coq-v-chk29"><hr></label><div class="goal-conclusion">P s</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">SO</span>.</span></span></pre><p>Just introduce a fresh <tt class="docutils literal">nat</tt> for the size of the list, and regular
induction will work.</p>
</div>
</div>
</div>
</div></body>
</html>
