<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>Shorter notation for matching hypotheses in Coq?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="shorter-notation-for-matching-hypotheses-in-coq">
<h1 class="title">Shorter notation for matching hypotheses in Coq?</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="link field"><th class="docinfo-name">Link:</th><td class="field-body"><a class="reference external" href="https://stackoverflow.com/q/55992567">https://stackoverflow.com/q/55992567</a></td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<div class="section" id="question">
<h1>Question</h1>
<p>I find myself often wanting to refer to hypotheses by their type
rather than by their name; especially in proofs with inversions on
semantic rules, i.e., rules with several cases each of which may have
multiple antecedents.</p>
<p>I know how to do this with <tt class="docutils literal">match goal with ...</tt>, as in the
following trivial example.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk0"><span class="kn">Lemma</span> <span class="nf">l0</span>:
  <span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span>, P1 \/ (P1 = P2) -&gt; P2 -&gt; P1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span> : <span class="kt">Prop</span>, P1 \/ P1 = P2 -&gt; P2 -&gt; P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span> : <span class="kt">Prop</span>, P1 \/ P1 = P2 -&gt; P2 -&gt; P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk3"><span class="kr">match goal with</span> H:_ \/ _ |- _ =&gt; <span class="nb">destruct</span> H <span class="kr">as</span> [H1|H2] <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br></div><label class="goal-separator" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk4"><hr></label><div class="goal-conclusion">P1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk5"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk6"><span class="kr">match goal with</span> H: _ = _ |- _ =&gt; <span class="nb">rewrite</span> H <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p><em>Is there a more concise way? Or a better approach?</em></p>
<p>(Introduction patterns, like <tt class="docutils literal">intros <span class="pre">[????</span> HA <span class="pre">HB|???</span> <span class="pre">HA|?????</span> HA HB
HC HD]</tt>, are not an option---I am tired of finding the right number
of <tt class="docutils literal">?</tt>s!)</p>
<p>For instance, is it possible to write a <tt class="docutils literal">grab</tt> tactic to combine a
pattern and a tactic, as in</p>
<pre class="code coq literal-block">
<span class="n">grab</span> <span class="o">[</span><span class="n">H</span><span class="o">:</span><span class="n">P1</span> <span class="o">\/</span> <span class="n">_</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="nb">rename</span> <span class="n">H</span> <span class="nb">into</span> <span class="n">HH</span><span class="o">.</span>
<span class="n">grab</span> <span class="o">[</span><span class="n">H</span><span class="o">:</span><span class="n">P1</span> <span class="o">\/</span> <span class="n">_</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="nb">destruct</span> <span class="n">H</span> <span class="nb">into</span> <span class="o">[</span><span class="n">H1</span><span class="o">|</span><span class="n">H2</span><span class="o">].</span>

<span class="n">grab</span> <span class="o">[</span><span class="n">P1</span> <span class="o">\/</span> <span class="n">_</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="nb">rename</span> <span class="n">it</span> <span class="nb">into</span> <span class="n">HH</span><span class="o">.</span>
<span class="n">grab</span> <span class="o">[</span><span class="n">P1</span> <span class="o">\/</span> <span class="n">_</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="nb">destruct</span> <span class="n">it</span> <span class="nb">into</span> <span class="o">[</span><span class="n">H1</span><span class="o">|</span><span class="n">H2</span><span class="o">].</span>
</pre>
<p>From my understanding of <a class="reference external" href="https://coq.inria.fr/refman/user-extensions/syntax-extensions.html#tactic-notations">Tactic Notations</a>,
it is not possible to have a cpattern as an argument, but maybe there
is another way?</p>
<p>Ideally, I would like to be able to use an hypothesis pattern instead
of an identifier in any tactic as in Isabelle:</p>
<pre class="code coq literal-block">
<span class="nb">rename</span> <span class="o">⟨</span><span class="n">P1</span> <span class="o">\/</span> <span class="n">_</span><span class="o">⟩</span> <span class="nb">into</span> <span class="n">HH</span><span class="o">.</span>
<span class="nb">destruct</span> <span class="o">⟨</span><span class="n">P1</span> <span class="o">\/</span> <span class="n">_</span><span class="o">⟩</span> <span class="kr">as</span> <span class="o">[</span><span class="n">H1</span><span class="o">|</span><span class="n">H2</span><span class="o">].</span>
<span class="nb">rewrite</span> <span class="o">⟨</span><span class="n">P1</span> <span class="o">=</span> <span class="n">_</span><span class="o">⟩.</span>
</pre>
<p>But I imagine this to be quite an invasive change.</p>
</div>
<div class="section" id="answer">
<h1>Answer</h1>
<p>You can iterate over all the assumptions until you find a matching
one:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;summon&quot;</span> <span class="kp">uconstr</span>(ty) <span class="s2">&quot;as&quot;</span> <span class="kn">ident</span>(id) :=
  <span class="kr">match goal with</span> H : _ |- _ =&gt; <span class="nb">pose</span> (id := H : ty) <span class="kr">end</span>.</span></span></pre><p>The trick is that you take the type to be found not as a pattern, but,
well, as a type :). Specifically, if you issue something like <tt class="docutils literal">summon
(P _) as id</tt>, then Coq will take the <tt class="docutils literal">_</tt> as an unsolved existential
variable. In turn, each assumption will be typechecked against <tt class="docutils literal">P
_</tt>, trying to instantiate that hole along the way. When one succeeds,
the <tt class="docutils literal">pose</tt> names it <tt class="docutils literal">id</tt>. The iteration arises because <tt class="docutils literal">match
goal</tt> will keep retrying with different matches until something
sticks or everything fails.</p>
<p>You can define a form without <tt class="docutils literal">as</tt> that just names the found thing
<tt class="docutils literal">it</tt> (while kicking anything else out):</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;summon&quot;</span> <span class="kp">uconstr</span>(ty) :=
  <span class="kr">let</span> <span class="nv">new_it</span> := <span class="kp">fresh</span> <span class="s2">&quot;it&quot;</span>
  <span class="kr">in</span> <span class="kp">try</span> (<span class="nb">rename</span> it <span class="nb">into</span> new_it); summon ty <span class="kr">as</span> it.</span></span></pre><p>Ta-da!</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk7"><span class="kn">Lemma</span> <span class="nf">l0</span> : <span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span>, P1 \/ (P1 = P2) -&gt; P2 -&gt; P1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span> : <span class="kt">Prop</span>, P1 \/ P1 = P2 -&gt; P2 -&gt; P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span> : <span class="kt">Prop</span>, P1 \/ P1 = P2 -&gt; P2 -&gt; P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk9"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chka">summon (_ \/ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>it</var><span><span class="hyp-body"><b>:= </b><span>H : P1 \/ P1 = P2</span></span><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chkb"><span class="nb">destruct</span> it.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br></div><label class="goal-separator" for="shorter-notation-for-matching-hypotheses-in-coq-v-chkc"><hr></label><div class="goal-conclusion">P1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chkd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chke">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chkf">summon (_ = _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br><span><var>it</var><span><span class="hyp-body"><b>:= </b><span>H1 : P1 = P2</span></span><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk10"><span class="nb">rewrite</span> it.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br><span><var>it</var><span><span class="hyp-body"><b>:= </b><span>H1 : P1 = P2</span></span><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span></pre><p>You can also get your <tt class="docutils literal">=&gt;</tt> syntax. I don't think it's terribly
useful, but...</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* assumption of type ty is summoned into id for the duration of tac</span>
<span class="c">   anything that used to be called id is saved and restored</span>
<span class="c">   afterwards, if possible. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;summon&quot;</span> <span class="kp">uconstr</span>(ty) <span class="s2">&quot;as&quot;</span> <span class="kn">ident</span>(id) <span class="s2">&quot;=&gt;&quot;</span> tactic(tac) :=
  <span class="kr">let</span> <span class="nv">saved_id</span> := <span class="kp">fresh</span> id
  <span class="kr">in</span> <span class="kp">try</span> (<span class="nb">rename</span> id <span class="nb">into</span> saved_id);
     summon ty <span class="kr">as</span> id; tac;
     <span class="kp">try</span> (<span class="nb">rename</span> saved_id <span class="nb">into</span> id).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk11"><span class="kn">Lemma</span> <span class="nf">l0</span> : <span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span>, P1 \/ (P1 = P2) -&gt; P2 -&gt; P1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span> : <span class="kt">Prop</span>, P1 \/ P1 = P2 -&gt; P2 -&gt; P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk12"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span> : <span class="kt">Prop</span>, P1 \/ P1 = P2 -&gt; P2 -&gt; P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk13"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk14">summon (_ \/ _) <span class="kr">as</span> H =&gt; <span class="nb">destruct</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk15" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br></div><label class="goal-separator" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk15"><hr></label><div class="goal-conclusion">P1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk16">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk17">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk18">summon (_ = _) <span class="kr">as</span> H =&gt; <span class="nb">rewrite</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>H2 : P1 = P2</span></span><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="section" id="old-answer">
<h2>Old answer</h2>
<p>(You may want to read this, because the above solution is really a
variant of this one, and there's more explanation here.)</p>
<p>You can summon an assumption matching a type pattern into a name with
<tt class="docutils literal">eassert (name : ty) by eassumption.</tt>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk19"><span class="kn">Lemma</span> <span class="nf">l0</span> : <span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span>, P1 \/ (P1 = P2) -&gt; P2 -&gt; P1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span> : <span class="kt">Prop</span>, P1 \/ P1 = P2 -&gt; P2 -&gt; P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk1a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span> : <span class="kt">Prop</span>, P1 \/ P1 = P2 -&gt; P2 -&gt; P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk1b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk1c"><span class="nb">eassert</span> (HH : _ \/ _) <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk1d"><span class="nb">destruct</span> HH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk1e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br></div><label class="goal-separator" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk1e"><hr></label><div class="goal-conclusion">P1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk1f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk20">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk21"><span class="nb">eassert</span> (HH : _ = _) <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1, HH</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk22"><span class="nb">rewrite</span> HH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1, HH</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span></pre><p>Why is this an improvement? Because the <tt class="docutils literal">_ \/ _</tt> and <tt class="docutils literal">_ = _</tt> are
now full types, not just patterns. They just contain unsolved
existential variables. Between <tt class="docutils literal">eassert</tt> and <tt class="docutils literal">eassumption</tt>, these
variables get solved at the same time the matching assumption is
located. Tactic notations can definitely work with types (i.e. terms).
Sadly, there appears to be a bit of a mishap in the parsing rules.
Specifically, the tactic notation needs an untyped term (so we don't
try and fail to resolve the variables too early), so we need
<tt class="docutils literal">uconstr</tt>, but <a class="reference external" href="https://sympa.inria.fr/sympa/arc/coq-club/2015-10/msg00054.html">there's no luconstr</a>,
meaning we're forced to add extraneous parentheses. To avoid
bracket-mania, I've reworked the syntax of your <tt class="docutils literal">grab</tt>. I'm also not
entirely sure if your <tt class="docutils literal">=&gt;</tt> syntax makes much sense, because why not
just bring the name into scope for good, instead of only on the
<tt class="docutils literal">=&gt;</tt>, as you seem to imply?</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;summon&quot;</span> <span class="kp">uconstr</span>(ty) <span class="s2">&quot;as&quot;</span> <span class="kn">ident</span>(id) :=
  <span class="nb">eassert</span> (id : ty) <span class="bp">by</span> <span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk23"><span class="kn">Lemma</span> <span class="nf">l0</span> : <span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span>, P1 \/ (P1 = P2) -&gt; P2 -&gt; P1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span> : <span class="kt">Prop</span>, P1 \/ P1 = P2 -&gt; P2 -&gt; P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk24"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span> : <span class="kt">Prop</span>, P1 \/ P1 = P2 -&gt; P2 -&gt; P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk25"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk26">summon (_ \/ _) <span class="kr">as</span> HH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk27"><span class="nb">destruct</span> HH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br></div><label class="goal-separator" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk28"><hr></label><div class="goal-conclusion">P1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk29">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk2a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk2b">summon (_ = _) <span class="kr">as</span> HH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1, HH</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk2c"><span class="nb">rewrite</span> HH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1, HH</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span></pre><p>You can make <tt class="docutils literal">summon</tt>-sans-<tt class="docutils literal">as</tt> name the found assumption <tt class="docutils literal">it</tt>,
while booting anything else under that name out.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;summon&quot;</span> <span class="kp">uconstr</span>(ty) <span class="s2">&quot;as&quot;</span> <span class="kn">ident</span>(id) :=
  <span class="nb">eassert</span> (id : ty) <span class="bp">by</span> <span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;summon&quot;</span> <span class="kp">uconstr</span>(ty) :=
  <span class="kr">let</span> <span class="nv">new_it</span> := <span class="kp">fresh</span> <span class="s2">&quot;it&quot;</span>
  <span class="kr">in</span> (<span class="kp">try</span> (<span class="nb">rename</span> it <span class="nb">into</span> new_it); summon ty <span class="kr">as</span> it).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk2d"><span class="kn">Lemma</span> <span class="nf">l0</span> : <span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span>, P1 \/ (P1 = P2) -&gt; P2 -&gt; P1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span> : <span class="kt">Prop</span>, P1 \/ P1 = P2 -&gt; P2 -&gt; P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk2e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span> : <span class="kt">Prop</span>, P1 \/ P1 = P2 -&gt; P2 -&gt; P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk2f"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* This example is actually a bad demonstration of the name-forcing</span>
<span class="c">     behavior because destruct-ion, well, destroys. Save the summoned</span>
<span class="c">     proof under the name it, but destroy it from another, then</span>
<span class="c">     observe the way the second summon shoves the original it into</span>
<span class="c">     it0. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk30">summon (_ \/ _) <span class="kr">as</span> prf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>prf</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk31"><span class="nb">pose</span> (it := prf).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>prf</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>it</var><span><span class="hyp-body"><b>:= </b><span>prf</span></span><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk32"><span class="nb">destruct</span> prf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P1</span></span></span><br><span><var>it</var><span><span class="hyp-body"><b>:= </b><span>or_introl p</span></span><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk33" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br><span><var>it</var><span><span class="hyp-body"><b>:= </b><span>or_intror e</span></span><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span></span><br></div><label class="goal-separator" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk33"><hr></label><div class="goal-conclusion">P1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk34">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P1</span></span></span><br><span><var>it</var><span><span class="hyp-body"><b>:= </b><span>or_introl p</span></span><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk35">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br><span><var>it</var><span><span class="hyp-body"><b>:= </b><span>or_intror e</span></span><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk36">summon (_ = _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br><span><var>it0</var><span><span class="hyp-body"><b>:= </b><span>or_intror e</span></span><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span></span><br><span><var>it</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk37"><span class="nb">rewrite</span> it.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br><span><var>it0</var><span><span class="hyp-body"><b>:= </b><span>or_intror e</span></span><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span></span><br><span><var>it</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span></pre><p>Idiomatically, that would really just be</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk38"><span class="kn">Lemma</span> <span class="nf">l0</span> : <span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span>, P1 \/ (P1 = P2) -&gt; P2 -&gt; P1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span> : <span class="kt">Prop</span>, P1 \/ P1 = P2 -&gt; P2 -&gt; P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk39"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P1</span> <span class="nv">P2</span> : <span class="kt">Prop</span>, P1 \/ P1 = P2 -&gt; P2 -&gt; P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk3a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk3b">summon (_ \/ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>it</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk3c"><span class="nb">destruct</span> it.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk3d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br></div><label class="goal-separator" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk3d"><hr></label><div class="goal-conclusion">P1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk3e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk3f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk40">summon (_ = _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1, it</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="shorter-notation-for-matching-hypotheses-in-coq-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="shorter-notation-for-matching-hypotheses-in-coq-v-chk41"><span class="nb">rewrite</span> it.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P1, P2</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P1 \/ P1 = P2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P2</span></span></span><br><span><var>H1, it</var><span class="hyp-type"><b>: </b><span>P1 = P2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>I believe that you could go and create a bunch of specialized <tt class="docutils literal">Tactic
Notations</tt> to replace the <tt class="docutils literal">ident</tt> arguments in <tt class="docutils literal">destruct</tt>,
<tt class="docutils literal">rewrite</tt>, etc. with these holey-type <tt class="docutils literal">uconstrs</tt>, if you really
wanted to. Indeed, <tt class="docutils literal">summon _ as _</tt> is almost your modified <tt class="docutils literal">rename
_ into _</tt>.</p>
<p>Another caveat: <tt class="docutils literal">assert</tt> is opaque; the definitions generated by
<tt class="docutils literal">summon</tt> look like new assumptions that don't reveal that they are
equal to one of the old ones. Something like <tt class="docutils literal">refine (let it := _ in
_)</tt> or <tt class="docutils literal">pose</tt> should be used to rectify this, but my Ltac-fu is not
strong enough to do this. See also: this issue advocating for a
literal <a class="reference external" href="https://github.com/coq/coq/issues/3551">transparent assert</a>.</p>
<p>(The new answer solves this caveat.)</p>
</div>
</div>
</div>
</div>
</div></body>
</html>
