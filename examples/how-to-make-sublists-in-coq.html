<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>How to make sublists in Coq?</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="how-to-make-sublists-in-coq">
<h1 class="title">How to make sublists in Coq?</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/36896291">https://stackoverflow.com/q/36896291</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>I'm working in Coq and trying to figure out how to do the next thing:
If I have a list of natural numbers and a given number <span class="docutils literal">n</span>, I want
to break my list in what goes before and after each of the <span class="docutils literal">n</span>'s. To
make it clearer, if I have the list <span class="docutils literal">[1; 2; 0; 3; 4; 0; 9]</span> and the
number <span class="docutils literal">n = 0</span>, then I want to have as output the three lists:
<span class="docutils literal">[1;2]</span>, <span class="docutils literal">[3;4]</span> and <span class="docutils literal">[9]</span>. The main problem I have is that I
don't know how to output several elements on a <span class="docutils literal">Fixpoint</span>. I think I
need to nest <span class="docutils literal">Fixpoint</span>s but I just don't see how. As a very raw
idea with one too many issues I have:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="how-to-make-sublists-in-coq-v-chk0"><span class="kn">Fixpoint</span> <span class="nf">SubLists</span> (<span class="nv">A</span> : list nat) (<span class="nv">m</span> : nat) :=
  <span class="kr">match</span> A <span class="kr">with</span>
  | [] =&gt; []
  | n :: A0 =&gt; <span class="kr">if</span> n =? m <span class="kr">then</span> SubLists L <span class="kr">else</span> n :: SubLists L
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The reference L was not found <span class="kr">in</span> the current
environment.</blockquote></div></div></small></span></pre><p>I would very much appreciate your input on how to do this, and how to
navigate having an output of several elements.</p>
</section>
<section id="answer-arthur-azevedo-de-amorim">
<h2>Answer (Arthur Azevedo De Amorim)</h2>
<p>You can do this by combining a few fixpoints:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Arith.Arith.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Lists.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">prefix</span> <span class="nv">n</span> <span class="nv">l</span> :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; []
  | m :: l&#39; =&gt; <span class="kr">if</span> beq_nat n m <span class="kr">then</span> [] <span class="kr">else</span> m :: prefix n l&#39;
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">suffix</span> <span class="nv">n</span> <span class="nv">l</span> :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; l
  | m :: l&#39; =&gt; <span class="kr">if</span> beq_nat n m <span class="kr">then</span> l&#39; <span class="kr">else</span> suffix n l&#39;
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">split_at</span> <span class="nv">n</span> <span class="nv">l</span> :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; []
  | m :: l&#39; =&gt; prefix n (m :: l&#39;) :: split_at n (suffix n (m :: l&#39;))
  <span class="kr">end</span>.</span></span></pre><p>Notice that Coq's termination checker accepts the recursive call to
<span class="docutils literal">split_at</span>, even though it is not done syntactically a subterm of
<span class="docutils literal">l</span>. The reason for that is that it is able to detect that suffix
only outputs subterms of its argument. But in order for this to work,
we <em>must</em> return <span class="docutils literal">l</span>, and not <span class="docutils literal">[]</span> on its first branch (try
changing it to see what happens!).</p>
</section>
<section id="answer-ejgallego">
<h2>Answer (ejgallego)</h2>
<p>In addition to Arthur's solution, you can use an accumulator, which is
typical of Functional Programming style:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Arith.Arith.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Lists.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">add_acc</span> <span class="nv">m</span> (<span class="nv">s</span> : list (list nat)) :=
  <span class="kr">match</span> s <span class="kr">with</span>
  | []      =&gt; [[m]]
  | s :: ss =&gt; (m :: s) :: ss
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">split_seq</span> <span class="nv">n</span> <span class="nv">l</span> <span class="nv">acc</span> :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | []      =&gt; map (@rev _) (rev acc)
  | m :: l&#39; =&gt; <span class="kr">if</span> beq_nat n m
               <span class="kr">then</span> split_seq n l&#39; ([] :: acc)
               <span class="kr">else</span> split_seq n l&#39; (add_acc m acc)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk1"><span class="kn">Compute</span> (split_seq <span class="mi">0</span> [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">0</span>; <span class="mi">3</span>; <span class="mi">4</span>; <span class="mi">0</span>; <span class="mi">9</span>] []).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= [[<span class="mi">1</span>; <span class="mi">2</span>]; [<span class="mi">3</span>; <span class="mi">4</span>]; [<span class="mi">9</span>]]
: list (list nat)</blockquote></div></div></small></span></pre><p>Note that the result is reversed so you need to use <span class="docutils literal">rev</span>. A bonus
exercise is to improve this.</p>
<p>EDIT: Provided second variant that doesn't add <span class="docutils literal">[]</span> for repeated
separators.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">reset_acc</span> (<span class="nv">s</span> : list (list nat)) :=
  <span class="kr">match</span> s <span class="kr">with</span>
  | [] :: ss =&gt; [] :: ss
  | ss       =&gt; [] :: ss
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">split_seq_nodup</span> <span class="nv">n</span> <span class="nv">l</span> <span class="nv">acc</span> :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | []      =&gt; map (@rev _) (rev acc)
  | m :: l&#39; =&gt; <span class="kr">if</span> beq_nat n m
               <span class="kr">then</span> split_seq_nodup n l&#39; (reset_acc acc)
               <span class="kr">else</span> split_seq_nodup n l&#39; (add_acc m acc)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk2"><span class="kn">Compute</span> (split_seq_nodup <span class="mi">0</span> [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">0</span>; <span class="mi">3</span>; <span class="mi">4</span>; <span class="mi">0</span>; <span class="mi">9</span>] []).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= [[<span class="mi">1</span>; <span class="mi">2</span>]; [<span class="mi">3</span>; <span class="mi">4</span>]; [<span class="mi">9</span>]]
: list (list nat)</blockquote></div></div></small></span></pre><hr class="docutils" />
<p><strong>A:</strong> (1) For <span class="docutils literal">reset_acc</span>'s body I'd write <span class="docutils literal">match s with | [] :: _ =&gt; s | _ =&gt; [] :: s</span> (2) For novice Coq programmers, not familiar
with the <a class="reference external" href="https://coq.inria.fr/refman/Reference-Manual004.html#Implicits-explicitation">&#64; syntax</a>:
it turns off &quot;implicitness&quot;, so <span class="docutils literal">(&#64;rev _)</span> stands for <span class="docutils literal">(&#64;rev nat)</span>. Without <span class="docutils literal">&#64;</span>, one could have used eta-expansion: <span class="docutils literal">map (fun xs =&gt; rev xs) (rev acc)</span>.</p>
</section>
<section id="answer-gallais">
<h2>Answer (gallais)</h2>
<p>An alternative way to tackle this issue is to formally describe the
problem you are trying to solve and then either write a
dependently-typed function proving that this problem can indeed be
solved or using tactics to slowly build up your proof.</p>
<p>This is, if I am not mistaken, a relation describing the relationship
between the outputs <span class="docutils literal">n</span> and <span class="docutils literal">ns</span> you want to pass your function
and the output <span class="docutils literal">mss</span> you want to get back.</p>
<p>The <span class="docutils literal">(* <span class="pre">-------</span> *)</span> lines are simple comments used to suggest that
these constructors should be seen as <a class="reference external" href="https://en.wikipedia.org/wiki/Inference_rule">inference rules</a>: whatever is under
one such line is the conclusion one can make based on the assumptions
above it.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">SubListsRel</span> (<span class="nv">n</span> : nat) :
  <span class="kr">forall</span> (<span class="nv">ns</span> : list nat) (<span class="nv">mss</span> : list (list nat)), <span class="kt">Prop</span> :=
| base      : SubListsRel n nil (nil :: nil)
| consEq    : <span class="kr">forall</span> <span class="nv">ns</span> <span class="nv">m</span> <span class="nv">mss</span>,
    n = m -&gt; SubListsRel n ns mss -&gt;
    <span class="c">(* ------------------------------ *)</span>
    SubListsRel n (m :: ns) (nil :: mss)
| consNotEq : <span class="kr">forall</span> <span class="nv">ns</span> <span class="nv">m</span> <span class="nv">ms</span> <span class="nv">mss</span>,
    (n &lt;&gt; m) -&gt; SubListsRel n ns (ms :: mss) -&gt;
    <span class="c">(* -------------------------------------- *)</span>
    SubListsRel n (m :: ns) ((m :: ms) :: mss).</span></span></pre><p>We can then express your <span class="docutils literal">Sublists</span> problem as being, given inputs
<span class="docutils literal">n</span> and <span class="docutils literal">ns</span>, the existence of an output <span class="docutils literal">mss</span> such that
<span class="docutils literal">SubListsRel n ns mss</span> holds:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">SubLists</span> (<span class="nv">n</span> : nat) (<span class="nv">ns</span> : list nat) : <span class="kt">Set</span> :=
  { mss | SubListsRel n ns mss }.</span></span></pre><p>Using tactics we can readily generate such <span class="docutils literal">Sublists</span> for concrete
examples in order to sanity-check our specification. We can for
instance take the example you had in your original post:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk3"><span class="kn">Example</span> <span class="nf">example1</span> : SubLists <span class="mi">0</span> (<span class="mi">1</span> :: <span class="mi">2</span> :: <span class="mi">0</span> :: <span class="mi">3</span> :: <span class="mi">4</span> :: <span class="mi">0</span> :: <span class="mi">9</span> :: nil).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">SubLists <span class="mi">0</span> (<span class="mi">1</span> :: <span class="mi">2</span> :: <span class="mi">0</span> :: <span class="mi">3</span> :: <span class="mi">4</span> :: <span class="mi">0</span> :: <span class="mi">9</span> :: nil)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">SubLists <span class="mi">0</span> (<span class="mi">1</span> :: <span class="mi">2</span> :: <span class="mi">0</span> :: <span class="mi">3</span> :: <span class="mi">4</span> :: <span class="mi">0</span> :: <span class="mi">9</span> :: nil)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk5"><span class="nb">eexists</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">SubListsRel <span class="mi">0</span> (<span class="mi">1</span> :: <span class="mi">2</span> :: <span class="mi">0</span> :: <span class="mi">3</span> :: <span class="mi">4</span> :: <span class="mi">0</span> :: <span class="mi">9</span> :: nil)
  <span class="nl">?mss</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> <span class="nb">econstructor</span>; <span class="nb">intro</span> Hf; <span class="nb">inversion</span> Hf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>And check that the output is indeed the list you were expecting:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk6"><span class="kn">Check</span> (eq_refl : proj1_sig example1
                 = ((<span class="mi">1</span> :: <span class="mi">2</span> :: nil) :: (<span class="mi">3</span> :: <span class="mi">4</span> :: nil) :: (<span class="mi">9</span> :: nil) :: nil)).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">eq_refl
:
proj1_sig example1 =
(<span class="mi">1</span> :: <span class="mi">2</span> :: nil)
:: (<span class="mi">3</span> :: <span class="mi">4</span> :: nil) :: (<span class="mi">9</span> :: nil) :: nil
     : proj1_sig example1 =
       (<span class="mi">1</span> :: <span class="mi">2</span> :: nil)
       :: (<span class="mi">3</span> :: <span class="mi">4</span> :: nil) :: (<span class="mi">9</span> :: nil) :: nil</blockquote></div></div></small></span></pre><p>Now comes the main part of this post: the proof that <span class="docutils literal">forall n ns, SubLists n ns</span>. Given that the premise of <span class="docutils literal">consNotEq</span> assumes that
<span class="docutils literal">mss</span> is non-empty, we will actually prove a strengthened statement
in order to make our life easier:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Strenghtened_SubLists</span> (<span class="nv">n</span> : nat) (<span class="nv">ns</span> : list nat) : <span class="kt">Set</span> :=
  { mss | SubListsRel n ns mss /\ mss &lt;&gt; nil }.</span></span></pre><p>And given that oftentimes we will have goals of the shape
<span class="docutils literal">something_absurd <span class="pre">-&gt;</span> False</span>, I define a simple tactic to handle
these things. It introduces the absurd assumption and inverts it
immediately to make the goal disappear:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">dismiss</span> := <span class="nb">intro</span> Hf; <span class="nb">inversion</span> Hf.</span></span></pre><p>We can now prove the main statement by proving the strengthened
version by induction and deducing it. I guess that here it's better
for you to step through it in Coq rather than me trying to explain
what happens. The key steps are the <span class="docutils literal">cut</span> (proving a stronger
statement), <span class="docutils literal">induction</span> and the case analysis on <span class="docutils literal">eq_nat_dec</span>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk7"><span class="kn">Lemma</span> <span class="nf">subLists</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">ns</span>, SubLists n ns.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">ns</span> : list nat), SubLists n ns</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">ns</span> : list nat), SubLists n ns</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk9"><span class="nb">intros</span> n ns.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SubLists n ns</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chka"><span class="nb">cut</span> (Strenghtened_SubLists n ns).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Strenghtened_SubLists n ns -&gt; SubLists n ns</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-make-sublists-in-coq-v-chkb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><label class="goal-separator" for="how-to-make-sublists-in-coq-v-chkb"><hr></label><div class="goal-conclusion">Strenghtened_SubLists n ns</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chkc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Strenghtened_SubLists n ns -&gt; SubLists n ns</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chkd"><span class="nb">intros</span> [mss [Hmss _]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>mss</var><span class="hyp-type"><b>: </b><span>list (list nat)</span></span></span><br><span><var>Hmss</var><span class="hyp-type"><b>: </b><span>SubListsRel n ns mss</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SubLists n ns</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chke"><span class="nb">eexists</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>mss</var><span class="hyp-type"><b>: </b><span>list (list nat)</span></span></span><br><span><var>Hmss</var><span class="hyp-type"><b>: </b><span>SubListsRel n ns mss</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SubListsRel n ns <span class="nl">?mss</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chkf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Strenghtened_SubLists n ns</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk10"><span class="nb">induction</span> ns.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Strenghtened_SubLists n nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-make-sublists-in-coq-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>IHns</var><span class="hyp-type"><b>: </b><span>Strenghtened_SubLists n ns</span></span></span><br></div><label class="goal-separator" for="how-to-make-sublists-in-coq-v-chk11"><hr></label><div class="goal-conclusion">Strenghtened_SubLists n (a :: ns)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk12">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Strenghtened_SubLists n nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk13"><span class="nb">eexists</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SubListsRel n nil <span class="nl">?mss</span> /\ <span class="nl">?mss</span> &lt;&gt; nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; [<span class="nb">econstructor</span> | dismiss].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk14">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>IHns</var><span class="hyp-type"><b>: </b><span>Strenghtened_SubLists n ns</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Strenghtened_SubLists n (a :: ns)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk15"><span class="nb">destruct</span> IHns <span class="kr">as</span> [mss [Hmss mssNotNil]];
        <span class="nb">destruct</span> (eq_nat_dec n a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>mss</var><span class="hyp-type"><b>: </b><span>list (list nat)</span></span></span><br><span><var>Hmss</var><span class="hyp-type"><b>: </b><span>SubListsRel n ns mss</span></span></span><br><span><var>mssNotNil</var><span class="hyp-type"><b>: </b><span>mss &lt;&gt; nil</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>n = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Strenghtened_SubLists n (a :: ns)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="how-to-make-sublists-in-coq-v-chk16" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>mss</var><span class="hyp-type"><b>: </b><span>list (list nat)</span></span></span><br><span><var>Hmss</var><span class="hyp-type"><b>: </b><span>SubListsRel n ns mss</span></span></span><br><span><var>mssNotNil</var><span class="hyp-type"><b>: </b><span>mss &lt;&gt; nil</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n &lt;&gt; a</span></span></span><br></div><label class="goal-separator" for="how-to-make-sublists-in-coq-v-chk16"><hr></label><div class="goal-conclusion">Strenghtened_SubLists n (a :: ns)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk17">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>mss</var><span class="hyp-type"><b>: </b><span>list (list nat)</span></span></span><br><span><var>Hmss</var><span class="hyp-type"><b>: </b><span>SubListsRel n ns mss</span></span></span><br><span><var>mssNotNil</var><span class="hyp-type"><b>: </b><span>mss &lt;&gt; nil</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>n = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Strenghtened_SubLists n (a :: ns)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk18"><span class="nb">eexists</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>mss</var><span class="hyp-type"><b>: </b><span>list (list nat)</span></span></span><br><span><var>Hmss</var><span class="hyp-type"><b>: </b><span>SubListsRel n ns mss</span></span></span><br><span><var>mssNotNil</var><span class="hyp-type"><b>: </b><span>mss &lt;&gt; nil</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>n = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SubListsRel n (a :: ns) <span class="nl">?mss</span> /\ <span class="nl">?mss</span> &lt;&gt; nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; [<span class="nb">eapply</span> consEq; <span class="bp">eassumption</span> | dismiss].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk19">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>mss</var><span class="hyp-type"><b>: </b><span>list (list nat)</span></span></span><br><span><var>Hmss</var><span class="hyp-type"><b>: </b><span>SubListsRel n ns mss</span></span></span><br><span><var>mssNotNil</var><span class="hyp-type"><b>: </b><span>mss &lt;&gt; nil</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n &lt;&gt; a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Strenghtened_SubLists n (a :: ns)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk1a"><span class="nb">destruct</span> mss; [<span class="nb">apply</span> False_rect, mssNotNil; <span class="bp">reflexivity</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ns, l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>mss</var><span class="hyp-type"><b>: </b><span>list (list nat)</span></span></span><br><span><var>Hmss</var><span class="hyp-type"><b>: </b><span>SubListsRel n ns (l :: mss)</span></span></span><br><span><var>mssNotNil</var><span class="hyp-type"><b>: </b><span>l :: mss &lt;&gt; nil</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n &lt;&gt; a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Strenghtened_SubLists n (a :: ns)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk1b"><span class="nb">eexists</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>ns, l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>mss</var><span class="hyp-type"><b>: </b><span>list (list nat)</span></span></span><br><span><var>Hmss</var><span class="hyp-type"><b>: </b><span>SubListsRel n ns (l :: mss)</span></span></span><br><span><var>mssNotNil</var><span class="hyp-type"><b>: </b><span>l :: mss &lt;&gt; nil</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n &lt;&gt; a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SubListsRel n (a :: ns) <span class="nl">?mss</span> /\ <span class="nl">?mss</span> &lt;&gt; nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; [<span class="nb">eapply</span> consNotEq; <span class="bp">eassumption</span> | dismiss].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><p>Once we have this function, we can come back to our example and
generate the appropriate <span class="docutils literal">Sublists</span> this time not by calling tactics
but by running the function <span class="docutils literal">subLists</span> we just defined.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">example2</span> : SubLists <span class="mi">0</span> (<span class="mi">1</span> :: <span class="mi">2</span> :: <span class="mi">0</span> :: <span class="mi">3</span> :: <span class="mi">4</span> :: <span class="mi">0</span> :: <span class="mi">9</span> :: nil) :=
  subLists _ _.</span></span></pre><p>And we can <span class="docutils literal">Check</span> that the computed list is indeed the same as the
one obtained in <span class="docutils literal">example1</span>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk1c"><span class="kn">Check</span> (eq_refl : proj1_sig example1 = proj1_sig example2).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">eq_refl : proj1_sig example1 = proj1_sig example2
     : proj1_sig example1 = proj1_sig example2</blockquote></div></div></small></span></pre><p><strong>Nota Bene</strong>: It is paramount here that our proofs are ended with
<span class="docutils literal">Defined</span> rather than <span class="docutils literal">Qed</span> in order for them to be unfolded when
computing with them (which is what we want to do here: they give us
the <span class="docutils literal">list (list nat)</span> we are looking for!).</p>
<p><a class="reference external" href="https://gist.github.com/gallais/e6c7dac6542459037a9b3935f3fd3741">A gist</a>
with all the code and the right imports.</p>
</section>
<section id="answer-anton-trunov">
<h2>Answer (Anton Trunov)</h2>
<p>Here is another take, based on the standard library function
<span class="docutils literal">List.fold_left</span>. It works by maintaining an accumulator, which is a
pair of the overall <em>reversed</em> result (a list of lists) and a current
sublist (also reversed while accumulating). Once we reach a delimiter,
we reverse the current sublist and put it into the resulting list of
sublists. After executing <span class="docutils literal">fold_left</span>, we reverse the result in the
outermost <span class="docutils literal">match</span> expression.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Arith.Arith.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Lists.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">split_skip_dup_delims</span> (<span class="nv">m</span> : nat) (<span class="nv">xs</span> : list nat) :=
  <span class="kr">match</span> fold_left
          (<span class="kr">fun</span> (<span class="nv">acctup</span>: _ * _) <span class="nv">x</span> =&gt;
             <span class="kr">let</span> (<span class="nv">acc</span>, rev_subl) := acctup <span class="kr">in</span>
             <span class="kr">if</span> beq_nat x m
             <span class="kr">then</span> <span class="kr">match</span> rev_subl <span class="kr">with</span> <span class="c">(* a delimiter found *)</span>
                  | [] =&gt; (acc, []) <span class="c">(* do not insert empty sublist *)</span>
                  | _ =&gt; (rev rev_subl :: acc, []) <span class="kr">end</span>
             <span class="kr">else</span> (acc, x :: rev_subl)) <span class="c">(* keep adding to the current sublist *)</span>
          xs
          ([],[]) <span class="kr">with</span>
  | (acc, []) =&gt; rev acc        <span class="c">(* list ends with a delimiter *)</span>
  | (acc, rev_subl) =&gt; rev (rev rev_subl :: acc) <span class="c">(* no delimiter at the end *)</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="how-to-make-sublists-in-coq-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="how-to-make-sublists-in-coq-v-chk1d"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> split_skip_dup_delims <span class="mi">0</span> [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">0</span>; <span class="mi">0</span>; <span class="mi">0</span>; <span class="mi">3</span>; <span class="mi">4</span>; <span class="mi">0</span>; <span class="mi">9</span>].</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= [[<span class="mi">1</span>; <span class="mi">2</span>]; [<span class="mi">3</span>; <span class="mi">4</span>]; [<span class="mi">9</span>]]
: list (list nat)</blockquote></div></div></small></span></pre></section>
</div>
</main>
</div></body>
</html>
