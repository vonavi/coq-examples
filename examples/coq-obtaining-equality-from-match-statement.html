<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Coq - Obtaining equality from match statement</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><main id="coq-obtaining-equality-from-match-statement">
<h1 class="title">Coq - Obtaining equality from <span class="docutils literal">match</span> statement</h1>
<dl class="docinfo simple">
<dt class="link">Link<span class="colon">:</span></dt>
<dd class="link"><p><a class="reference external" href="https://stackoverflow.com/q/70946233">https://stackoverflow.com/q/70946233</a></p>
</dd>
</dl>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<section id="question">
<h2>Question</h2>
<p>Here's a simplified version of something I'm trying to implement in
Coq. I have an inductive type, say <span class="docutils literal">foo</span>, whose constructor takes in
another type <span class="docutils literal">A</span>, and a function with inputs in <span class="docutils literal">A</span>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">foo</span> :=
| <span class="nb">constructor</span> (A : <span class="kt">Type</span>) (f : A -&gt; bool).</span></span></pre><p>I also have a function which, given an object of type <span class="docutils literal">foo</span>, tells
me what type was used to construct it.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">foo_type</span> (<span class="nv">x</span> : foo) :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | <span class="nb">constructor</span> A f =&gt; A
  <span class="kr">end</span>.</span></span></pre><p>So far so good. But now, I want to define a function which takes in an
object <span class="docutils literal">x</span> of type <span class="docutils literal">foo</span> and an object <span class="docutils literal">y</span> of type <span class="docutils literal">foo_type x</span>, and returns the <span class="docutils literal">f y</span>, where <span class="docutils literal">f</span> is the function used in the
constructor of <span class="docutils literal">x</span>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="coq-obtaining-equality-from-match-statement-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="coq-obtaining-equality-from-match-statement-v-chk0"><span class="kn">Definition</span> <span class="nf">foo_func</span> (<span class="nv">x</span> : foo) (<span class="nv">y</span> : (foo_type x)) :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | <span class="nb">constructor</span> A f =&gt; f y
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">In environment
x : foo
y : foo_type x
A : <span class="kt">Type</span>
f : A -&gt; bool
The term <span class="s2">&quot;y&quot;</span> has type <span class="s2">&quot;foo_type x&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type <span class="s2">&quot;A&quot;</span>.</blockquote></div></div></small></span></pre><p>However, this doesn't work. Coq tells me that there is a type error:
<span class="docutils literal">y</span> is of type <span class="docutils literal">foo_type x</span>, when it should be of type <span class="docutils literal">A</span>.</p>
<p>Now, I know that <span class="docutils literal">foo_type x</span> evaluates to <span class="docutils literal">A</span> in this situation.
Using <a class="reference external" href="https://stackoverflow.com/questions/52514957">this stackoverflow question</a>, I found a function
I can use that takes as input an equality of types <span class="docutils literal">A = B</span> and an
element <span class="docutils literal">a : A</span> and returns <span class="docutils literal">a</span>, but of type <span class="docutils literal">B</span>. However, to
make use of this, I need to be able to obtain the equality <span class="docutils literal">foo_type x = A</span> within the <span class="docutils literal">match</span> part of my function definition. This
boils down to obtaining the equality <span class="docutils literal">x = constructor A f</span>.</p>
<p>So: within a <span class="docutils literal">match x with</span> statement in my definition, is it
possible to extract the equality <span class="docutils literal">x = constructor A f</span>? How can I do
this? Or is there another way to get around this issue?</p>
</section>
<section id="answer">
<h2>Answer</h2>
<p>You need to use dependent pattern matching (an give some information
to Coq) to get an equality proof between a term and its
pattern-matched content:</p>
<pre class="code coq literal-block"><code><span class="kr">match</span> <span class="n">x</span> <span class="kr">as</span> <span class="n">x0</span> <span class="kr">return</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">-&gt;</span> <span class="o">...</span> <span class="kr">with</span>
<span class="o">|</span> <span class="n">pat</span> <span class="o">=&gt;</span> <span class="kr">fun</span> <span class="o">(</span><span class="nv">e</span> <span class="o">:</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pat</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="o">...</span>
<span class="o">|</span> <span class="o">...</span>
<span class="kr">end</span> <span class="n">eq_refl</span></code></pre>
<p>On the outside of the match construct, you can build a term <span class="docutils literal">eq_refl : x = x</span> that is refined during pattern matching. This is called the
convoy pattern in <a class="reference external" href="http://adam.chlipala.net/cpdt/">Certified programming with dependent types</a>.</p>
<p>In your case however there is a related, slightly simpler alternative,
still using dependent pattern matching:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">foo_func</span> (<span class="nv">x</span> : foo) (<span class="nv">y</span> : (foo_type x)) :=
  <span class="kr">match</span> x <span class="kr">as</span> x0 <span class="kr">return</span> foo_type x0 -&gt; bool <span class="kr">with</span>
  | <span class="nb">constructor</span> A f =&gt; <span class="kr">fun</span> <span class="nv">y</span> =&gt; f y
  <span class="kr">end</span> y.</span></span></pre><hr class="docutils" />
<p><strong>A:</strong> I would never write the first version, unless I was feeling the
need to write particularly bad code. Use the second version! (And you
would need about the same thing anyway, whether explicit or folded
into an existing lemma, to actually rewrite the equality you get from
the first version in the type of any term.)</p>
</section>
</div>
</main>
</div></body>
</html>
