- path: "examples/a-coq-proof-of-a-theorem-which-turns-a-formula-containing-y-into-a-formula-conta.html"
  title: "A Coq proof of a theorem which turns a formula containing <tt>y</tt> into a formula containing <tt>f(x)</tt>"
  tags: [proof-irrelevance, sigma-type]

- path: "examples/a-simple-case-of-universe-inconsistency.html"
  title: "A simple case of universe inconsistency"
  tags: [universe]

- path: "examples/about-the-refine-tactic-in-coq.html"
  title: "About the <tt>refine</tt> tactic in Coq"
  tags: [congruence, tactic]

- path: "examples/abstracting-leads-to-a-term-ill-typed-yet-well-typed.html"
  title: "Abstracting leads to a term ill-typed... yet well-typed"
  tags: [decidable, eq_rect]

- path: "examples/abstracting-patterns-in-induction-rule-for-inductive-predicates-for-coq.html"
  title: "Abstracting patterns in induction rule for inductive predicates for Coq"
  tags: [fixpoint]

- path: "examples/adding-complete-disjunctive-assumption-in-coq.html"
  title: "Adding complete disjunctive assumption in Coq"
  tags: [view]

- path: "examples/agda-like-programming-in-coq-proof-general.html"
  title: "Agda-like programming in Coq/Proof General?"
  tags: [proving]

- path: "examples/all-quantified-type-variable-in-value-constructor-cannot-be-explicitly-typed-a.html"
  title: "All-quantified type variable in (value) constructor cannot be explicitly typed as wanted"
  tags: [convoy-pattern, fixpoint, proving, tactic, view]

- path: "examples/apply-rewrite-tactic-to-sub-expression.html"
  title: "Apply rewrite tactic to sub-expression"
  tags: [congruence, tactic]

- path: "examples/applying-a-program-definition-fails-with-unable-to-unify-prop-with-goal.html"
  title: "Applying a Program Definition fails with \"unable to unify Prop with [goal]\""
  tags: [eq_rect, indexed-type, tactic]

- path: "examples/are-all-proofs-of-true-true-the-same.html"
  title: "Are all proofs of <tt>true = true</tt> the same?"
  tags: [convoy-pattern, decidable, indexed-type, match]

- path: "examples/assert-a-proposition-on-multiple-witnesses.html"
  title: "Assert a proposition on multiple witnesses"
  tags: [eq_rect, proving, sigma-type]

- path: "examples/attempting-to-use-proof-irrelevance-without-creating-ill-typed-terms.html"
  title: "Attempting to use proof irrelevance without creating ill-typed terms"
  tags: [convoy-pattern, eq_rect, tactic]

- path: "examples/best-practices-for-an-effective-use-of-coqs-hint-database.html"
  title: "Best practices for an effective use of Coq's hint database"
  tags: [tactic]

- path: "examples/best-practices-for-parametrized-coq-libraries.html"
  title: "Best practices for parametrized Coq libraries"
  tags: [module, typeclass]

- path: "examples/best-way-to-handle-sub-types-of-the-form-x-nat-x-13-x-19.html"
  title: "Best way to handle (sub) types of the form <tt>{ x : nat | x >= 13 /x <= 19 }</tt>?"
  tags: [coercion, sigma-type]

- path: "examples/building-a-class-hierarchy-in-coq.html"
  title: "Building a class hierarchy in Coq?"
  tags: [typeclass]

- path: "examples/building-up-tree-and-decreasing-argument-of-fix.html"
  title: "Building up tree and decreasing argument of fix"
  tags: [fixpoint, nested]

- path: "examples/call-a-theorem-using-let-in.html"
  title: "Call a theorem using let-in"
  tags: [compute, notation, record]

- path: "examples/can-any-one-help-me-how-to-prove-this-therom-in-coq.html"
  title: "Can any one help me how to prove this theorem in Coq"
  tags: [classical, decidable]

- path: "examples/can-coq-intros-pattern-split-at-the-rightmost-opportunity-for-conjunction.html"
  title: "Can Coq <tt>intros</tt> pattern split at the rightmost opportunity for conjunction?"
  tags: [tactic, view]

- path: "examples/can-i-tell-coq-to-do-induction-from-n-to-n2.html"
  title: "Can I tell Coq to do induction from <tt>n</tt> to <tt>n + 2</tt>?"
  tags: [fixpoint, reflection]

- path: "examples/can-one-prove-an-equivalent-to-forall-inv-for-heterogeneous-lists-in-coq.html"
  title: "Can one prove an equivalent to <tt>Forall_inv</tt> for heterogeneous lists in Coq?"
  tags: [fixpoint, indexed-type, match, tactic]

- path: "examples/can-you-prove-excluded-middle-is-wrong-in-coq-if-i-do-not-import-classical-logic.html"
  title: "Can you prove Excluded Middle is wrong in Coq if I do not import classical logic"
  tags: [classical, proof-irrelevance]

- path: "examples/cannot-determine-termination.html"
  title: "Cannot determine termination"
  tags: [fixpoint]

- path: "examples/cannot-rewrite-goal-with-assertion.html"
  title: "Cannot rewrite goal with assertion?"
  tags: [tactic]

- path: "examples/cant-automate-a-lemma-that-works-manually-in-coq.html"
  title: "Can't automate a lemma that works manually in Coq"
  tags: [tactic]

- path: "examples/case-analysis-on-evidence-of-equality-type-in-coq.html"
  title: "Case analysis on evidence of equality type in Coq"
  tags: [eq_rect, fixpoint, indexed-type, match]

- path: "examples/change-a-function-at-one-point.html"
  title: "Change a function at one point"
  tags: [decidable]

- path: "examples/characteristic-function-of-a-union.html"
  title: "Characteristic function of a union"
  tags: [classical, decidable]

- path: "examples/church-numerals-and-universe-inconsistency.html"
  title: "Church numerals and universe inconsistency"
  tags: [universe]

- path: "examples/classical-axioms-implies-every-proposition-is-decidable.html"
  title: "Classical axioms implies every proposition is decidable?"
  tags: [classical, decidable, view]

- path: "examples/closing-a-lemma-on-list-of-nats.html"
  title: "Closing a lemma on list of nats"
  tags: [fixpoint]

- path: "examples/compute-if-in-a-decideable-prop-in-coq.html"
  title: "Compute <tt>if</tt> in a decideable prop in Coq"
  tags: [compute, decidable, proving]

- path: "examples/compute-with-a-recursive-function-defined-by-well-defined-induction.html"
  title: "Compute with a recursive function defined by well-defined induction"
  tags: [compute, proving, tactic]

- path: "examples/confused-about-pattern-matching-in-record-constructions-in-coq.html"
  title: "Confused about pattern matching in <tt>Record</tt> constructions in Coq"
  tags: [convoy-pattern]

- path: "examples/context-expression-in-coq.html"
  title: "<tt>context</tt> expression in Coq"
  tags: [match]

- path: "examples/contradiction-on-natural-numbers-zero-test.html"
  title: "Contradiction on natural number's zero test"
  tags: [proving, reflection]

- path: "examples/coq-a-left-recursive-notation-must-have-an-explicit-level.html"
  title: "Coq: a left-recursive notation must have an explicit level"
  tags: [tactic]

- path: "examples/coq-a-single-notation-for-multiple-constructors.html"
  title: "Coq: a single notation for multiple constructors"
  tags: [synthesis, typeclass]

- path: "examples/coq-adding-a-new-variable-instead-of-using-the-correct-one.html"
  title: "Coq adding a new variable instead of using the correct one"
  tags: [convoy-pattern, eq_rect, indexed-type]

- path: "examples/coq-adding-a-strong-induction-tactic.html"
  title: "Coq: adding a \"strong induction\" tactic"
  tags: [tactic]

- path: "examples/coq-assign-expression-to-variable.html"
  title: "Coq - Assign expression to variable"
  tags: [tactic]

- path: "examples/coq-associativity-of-relational-composition.html"
  title: "Coq: Associativity of relational composition"

- path: "examples/coq-auto-tactic-fails.html"
  title: "Coq <tt>auto</tt> tactic fails"
  tags: [match, tactic]

- path: "examples/coq-automate-repeated-rewriting.html"
  title: "Coq: automate repeated rewriting"
  tags: [congruence, tactic]

- path: "examples/coq-cannot-unify-inductive-types.html"
  title: "Coq: cannot unify inductive types"
  tags: [convoy-pattern, indexed-type]

- path: "examples/coq-cant-compute-a-well-founded-function-on-z-but-it-works-on-nat.html"
  title: "Coq can't compute a well-founded function on <tt>Z</tt>, but it works on <tt>nat</tt>"
  tags: [compute, decidable, proof-irrelevance]

- path: "examples/coq-cant-infer-type-parameter-in-match.html"
  title: "Coq can't infer type parameter in <tt>match</tt>"
  tags: [convoy-pattern, eq_rect]

- path: "examples/coq-cant-see-that-two-types-are-the-same.html"
  title: "Coq can't see that two types are the same"
  tags: [eq_rect, indexed-type, proving, tactic]

- path: "examples/coq-coercion-of-list-nat.html"
  title: "Coq - Coercion of <tt>list nat</tt>"
  tags: [coercion]

- path: "examples/coq-coercion-subtyping-between-complex-expressions.html"
  title: "Coq: coercion/subtyping between complex expressions"
  tags: [coercion]

- path: "examples/coq-coercions-and-goal-matching.html"
  title: "Coq coercions and goal matching"
  tags: [coercion]

- path: "examples/coq-controlling-subst-when-we-have-many-equalities.html"
  title: "Coq: controlling <tt>subst</tt> when we have many equalities"
  tags: [tactic]

- path: "examples/coq-derive-argument-from-context.html"
  title: "Coq: Derive argument from context"
  tags: [module, typeclass]

- path: "examples/coq-destruct-coinductive-hypothesis-without-losing-information.html"
  title: "Coq: destruct (co)inductive hypothesis without losing information"
  tags: [congruence, tactic]

- path: "examples/coq-easiest-way-to-construct-members-of-a-decidable-sigma-type.html"
  title: "Coq: easiest way to construct members of a decidable sigma type?"
  tags: [proving, sigma-type, typeclass]

- path: "examples/coq-eliminating-forall.html"
  title: "Coq: eliminating <tt>forall</tt>?"

- path: "examples/coq-execution-difference-between-semicolon-and-period.html"
  title: "Coq execution difference between semicolon <tt>;</tt> and period <tt>.</tt>"
  tags: [proving, tactic]

- path: "examples/coq-how-are-the-equality-tacticts-symmetry-and-transitivity-defined.html"
  title: "Coq: How are the equality tactics <tt>symmetry</tt> and <tt>transitivity</tt> defined?"
  tags: [tactic]

- path: "examples/coq-how-to-prove-if-statements-involving-strings.html"
  title: "Coq: How to prove if statements involving strings?"
  tags: [decidable, proving, view]

- path: "examples/coq-how-to-prove-max-a-b-ab.html"
  title: "Coq: How to prove <tt>max a b <= a + b</tt>?"
  tags: [proving, view]

- path: "examples/coq-how-to-refer-to-the-types-generated-by-a-specific-constructor.html"
  title: "Coq: How to refer to the types generated by a specific constructor?"
  tags: [complete, convoy-pattern, proving]

- path: "examples/coq-identity-term-which-is-not-eq-refl.html"
  title: "Coq identity term which is not <tt>eq_refl</tt>"
  tags: [compute, eq_rect, match]

- path: "examples/coq-implementation-of-splitstring-and-proof-that-nothing-gets-deleted.html"
  title: "Coq: Implementation of <tt>split_string</tt> and proof that nothing gets deleted"
  tags: [fixpoint]

- path: "examples/coq-index-relation.html"
  title: "Coq Index Relation"
  tags: [proof-irrelevance, sigma-type]

- path: "examples/coq-induction-on-modulo.html"
  title: "Coq induction on modulo"
  tags: [fixpoint, tactic, view]

- path: "examples/coq-inference-behavior.html"
  title: "Coq inference behavior"
  tags: [convoy-pattern, proving, tactic]

- path: "examples/coq-item-1-2-10-type-cast.html"
  title: "Coq item 1.2.10 Type cast"
  tags: [compute]

- path: "examples/coq-leb-does-not-give-me-an-hypothesis-after-case-or-induction.html"
  title: "Coq <tt>leb</tt> (<tt><=?</tt>) does not give me an hypothesis after case or induction"
  tags: [proving, reflection, view]

- path: "examples/coq-local-ltac-definition.html"
  title: "Coq: local ltac definition"
  tags: [module]

- path: "examples/coq-losing-information-from-if-statement-when-doing-recursive-function-with-prog.html"
  title: "Coq losing information from if-statement when doing recursive function with <tt>Program</tt>"
  tags: [convoy-pattern, decidable, match, notation]

- path: "examples/coq-notation-for-multi-type-list.html"
  title: "Coq notation for multi type list"
  tags: [coercion, typeclass]

- path: "examples/coq-obtaining-equality-from-match-statement.html"
  title: "Coq - Obtaining equality from <tt>match</tt> statement"
  tags: [convoy-pattern]

- path: "examples/coq-path-implementation.html"
  title: "Coq <tt>path</tt> implementation"

- path: "examples/coq-produce-instance-of-a-type-x-t-p-x-inside-an-explicit-definition-giv.html"
  title: "Coq produce instance of a type <tt>{x : T | P x}</tt> inside an explicit definition given an <tt>x</tt> of type <tt>T</tt>"
  tags: [nested, proving, sigma-type, tactic]

- path: "examples/coq-prop-versus-set-in-typen.html"
  title: "Coq: <tt>Prop</tt> versus <tt>Set</tt> in <tt>Type(n)</tt>"
  tags: [classical, fixpoint, proof-irrelevance]

- path: "examples/coq-proving-addition-inequality.html"
  title: "Coq proving addition inequality"
  tags: [proving]

- path: "examples/coq-proving-relation-between-and-≤.html"
  title: "Coq: Proving relation between <tt><</tt> and <tt><=</tt>"
  tags: [fixpoint, indexed-type]

- path: "examples/coq-proving-that-the-product-of-n-and-s-n-is-even.html"
  title: "Coq: Proving that the product of <tt>n</tt> and <tt>(S n)</tt> is even"
  tags: [fixpoint, proving, view]

- path: "examples/coq-qarith-division-by-zero-is-zero-why.html"
  title: "Coq QArith division by zero is zero, why?"
  tags: [complete, indexed-type, proving]

- path: "examples/coq-qed-raise-a-warning-with-admitted-lemmas.html"
  title: "Coq <tt>Qed</tt> raise a warning with admitted lemmas"
  tags: [proving, tactic]

- path: "examples/coq-recursive-definition-of-fibonacci-is-ill-formed.html"
  title: "Coq: Recursive definition of fibonacci is ill-formed"
  tags: [fixpoint, match]

- path: "examples/coq-recursive-smart-constructors-and-sigma-types-how-to-avoid-axioms.html"
  title: "Coq: Recursive Smart Constructors and Sigma types, how to avoid axioms"
  tags: [decidable, proof-irrelevance]

- path: "examples/coq-return-value-of-type-which-is-equal-to-function-return-type.html"
  title: "Coq - return value of type which is equal to function return type"
  tags: [coercion, eq_rect, indexed-type, proving, record]

- path: "examples/coq-rewrite-preserving-input-hypothesis.html"
  title: "Coq: <tt>rewrite</tt> preserving input hypothesis"
  tags: [tactic]

- path: "examples/coq-rewriting-a-fmap-within-a-relation.html"
  title: "Coq - Rewriting a <tt>FMap</tt> Within a Relation"
  tags: [convoy-pattern, proving]

- path: "examples/coq-rewriting-using-lambda-arguments.html"
  title: "Coq rewriting using lambda arguments"
  tags: [tactic]

- path: "examples/coq-rewriting-with-forall-in-hypothesis-or-goal.html"
  title: "Coq: Rewriting with <tt>forall</tt> in hypothesis or goal"
  tags: [tactic]

- path: "examples/coq-testing-partial-convertibilty.html"
  title: "Coq: Testing partial convertibilty"
  tags: [record, synthesis]

- path: "examples/coq-theorem-proving-simple-fraction-law-in-peano-arithmetic.html"
  title: "Coq theorem proving: Simple fraction law in peano arithmetic"
  tags: [fixpoint, tactic]

- path: "examples/coq-typeclasses-vs-dependent-records.html"
  title: "Coq: typeclasses vs dependent records"
  tags: [record, typeclass]

- path: "examples/coq-unfolding-class-instances.html"
  title: "Coq: unfolding class instances"
  tags: [compute]

- path: "examples/coq-usage-of-partialorder-typeclass.html"
  title: "Coq: usage of <tt>PartialOrder</tt> typeclass"
  tags: [typeclass]

- path: "examples/coq-viewing-proof-term-during-proof-script-writing.html"
  title: "Coq: viewing proof term during proof script writing"
  tags: [fixpoint, proving, tactic]

- path: "examples/creating-coq-tactic-how-to-use-a-newly-generated-name.html"
  title: "Creating Coq tactic: how to use a newly generated name?"
  tags: [tactic]

- path: "examples/dealing-with-let-in-expressions-in-current-goal.html"
  title: "Dealing with let-in expressions in current goal"
  tags: [match]

- path: "examples/decidable-equality-statement-with-set-vs-prop.html"
  title: "Decidable equality statement with <tt>Set</tt> vs. <tt>Prop</tt>"
  tags: [classical, decidable]

- path: "examples/decide-disjunctions-in-sort-prop.html"
  title: "Decide disjunctions in sort <tt>Prop</tt>"
  tags: [classical, decidable]

- path: "examples/decide-equality-for-mutually-recursive-types-in-coq.html"
  title: "<tt>decide equality</tt> for Mutually Recursive Types in Coq?"
  tags: [fixpoint]

- path: "examples/decoupling-the-data-to-be-manipulated-from-the-proofs-that-the-manipulations-are.html"
  title: "Decoupling the data to be manipulated from the proofs that the manipulations are justified"
  tags: [indexed-type, proving]

- path: "examples/decreasing-argument-and-what-is-a-program-fixpoint.html"
  title: "Decreasing argument (and what is a <tt>Program Fixpoint</tt>)"
  tags: [fixpoint]

- path: "examples/defining-a-function-that-returns-one-element-satisfying-the-condition.html"
  title: "Defining a function that returns one element satisfying the condition"
  tags: [convoy-pattern]

- path: "examples/defining-integers-inductively-in-coq-inductive-definitions-subject-to-relations.html"
  title: "Defining integers inductively in Coq (inductive definitions subject to relations)"

- path: "examples/defining-subtype-relation-in-coq.html"
  title: "Defining subtype relation in Coq"
  tags: [coercion, record]

- path: "examples/definition-by-property-in-coq.html"
  title: "Definition by property in Coq"
  tags: [proof-irrelevance, proving, sigma-type]

- path: "examples/definition-vs-notation-for-constants.html"
  title: "<tt>Definition</tt> vs <tt>Notation</tt> for constants"
  tags: [notation, tactic]

- path: "examples/dependent-pair-types.html"
  title: "Dependent Pair Types"
  tags: [fixpoint, sigma-type]

- path: "examples/dependent-pattern-matching.html"
  title: "Dependent pattern matching"
  tags: [convoy-pattern, fixpoint, notation, sigma-type, view]

- path: "examples/dependent-type-as-a-function-argument-in-coq.html"
  title: "Dependent type as a function argument in Coq"
  tags: [sigma-type]

- path: "examples/deriving-facts-on-pattern-matching-in-coq.html"
  title: "Deriving facts on pattern matching in Coq"
  tags: [compute, convoy-pattern, eq_rect, proving]

- path: "examples/destruct-if-condition-in-program-fixpoint-coq.html"
  title: "Destruct if condition in program fixpoint Coq"
  tags: [fixpoint]

- path: "examples/destructing-equality-of-dependent-records-in-coq.html"
  title: "Destructing equality of dependent records in Coq"
  tags: [eq_rect, indexed-type, sigma-type]

- path: "examples/difference-between-parameters-and-members-of-a-class.html"
  title: "Difference between parameters and members of a class"
  tags: [proof-irrelevance, sigma-type, typeclass]

- path: "examples/difference-between-sumbool-and-intuitionnistic-disjunction.html"
  title: "Difference between <tt>sumbool</tt> and intuitionnistic disjunction"
  tags: [classical, decidable, proof-irrelevance]

- path: "examples/difference-between-type-parameters-and-indices.html"
  title: "Difference between type parameters and indices?"
  tags: [indexed-type]

- path: "examples/different-induction-principles-for-prop-and-type.html"
  title: "Different induction principles for <tt>Prop</tt> and <tt>Type</tt>"
  tags: [eq_rect, indexed-type, proof-irrelevance]

- path: "examples/display-the-original-name-of-the-imported-module-in-coq.html"
  title: "Display the original name of the imported module in Coq"
  tags: [module]

- path: "examples/does-gallina-have-holes-like-in-agda.html"
  title: "Does Gallina have holes like in Agda?"
  tags: [proving]

- path: "examples/ease-life-in-dependently-typed-programming-using-function-and-program-in-coq.html"
  title: "Ease life in dependently typed programming using <tt>Function</tt> and <tt>Program</tt> in Coq"
  tags: [proving]

- path: "examples/efficient-way-of-defining-multiple-functions-of-the-same-type.html"
  title: "Efficient Way of Defining Multiple Functions of the Same Type"
  tags: [module]

- path: "examples/eliminate-redundant-sub-goals-generated-by-case-analysis-in-coq.html"
  title: "Eliminate redundant sub-goals generated by case analysis in Coq"
  tags: [proving, synthesis, tactic]

- path: "examples/equality-in-coq-for-enumerated-types.html"
  title: "Equality in Coq for enumerated types"
  tags: [decidable, match, synthesis, tactic]

- path: "examples/equality-of-dependent-types-and-dependent-values.html"
  title: "Equality of dependent types and dependent values"
  tags: [eq_rect]

- path: "examples/equality-on-inductive-types.html"
  title: "Equality on inductive types"
  tags: [indexed-type, match, tactic]

- path: "examples/error-in-defining-ackermann-in-coq.html"
  title: "Error in defining Ackermann in Coq"
  tags: [compute, fixpoint, nested, tactic]

- path: "examples/error-tactic-failure-the-relation-fun-x-y-bloodtype-x-y-is-not-a-dec.html"
  title: "Error \"Tactic failure: The relation (<tt>fun x y : BloodType => x <> y</tt>) is not a declared reflexive relation.\" when proving a theorem about function"
  tags: [tactic]

- path: "examples/eval-compute-is-incomplete-when-own-decidability-is-used-in-coq.html"
  title: "<tt>Eval compute</tt> is incomplete when own decidability is used in Coq"
  tags: [compute, decidable, proving, reflection, view]

- path: "examples/even-sn-not-even-n-apply-1-hypothesis-in-another.html"
  title: "<tt>even_Sn_not_even_n</tt> - apply 1 hypothesis in another"
  tags: [classical, proving, reflection]

- path: "examples/existential-goals-are-filled-in-too-soon.html"
  title: "Existential goals are filled in too soon"
  tags: [record, tactic]

- path: "examples/existential-instantiation-and-generalization-in-coq.html"
  title: "Existential instantiation and generalization in coq"
  tags: [tactic]

- path: "examples/existential-quantifier-in-coq-impredicative-logic-system-f.html"
  title: "Existential quantifier in Coq impredicative logic (System F)"
  tags: [proving, tactic]

- path: "examples/expanding-recursive-functions-in-coq.html"
  title: "Expanding Recursive Functions In Coq"
  tags: [fixpoint, proving, tactic]

- path: "examples/explain-a-simple-operation-in-coq.html"
  title: "Explain a simple operation in Coq"
  tags: [compute, match, nested, tactic]

- path: "examples/explanation-transitivity-of-equal-coq.html"
  title: "Explanation transitivity of equal Coq"
  tags: [tactic]

- path: "examples/extensible-tactic-in-coq.html"
  title: "Extensible tactic in Coq"
  tags: [proving, tactic]

- path: "examples/fail-to-use-let-destruct-for-tuple-in-coq.html"
  title: "Fail to use let-destruct for tuple in Coq"
  tags: [match, nested]

- path: "examples/finding-a-well-founded-relation-to-prove-termination-of-a-function-that-stops-de.html"
  title: "Finding a well founded relation to prove termination of a function that stops decreasing at some point"
  tags: [decidable, match, proving]

- path: "examples/fixpoint-with-prop-inhabitant-as-argument.html"
  title: "Fixpoint with <tt>Prop</tt> inhabitant as argument"
  tags: [coercion, convoy-pattern, fixpoint, proving]

- path: "examples/form-of-intros-in-coq-specifically-for-forall-and-explicitly-for.html"
  title: "Form of <tt>intros</tt> in Coq specifically for <tt>forall</tt> and explicitly for <tt>-></tt>"
  tags: [tactic]

- path: "examples/function-and-type-substitutions-or-views-in-coq.html"
  title: "Function- and Type substitutions or Views in Coq"
  tags: [indexed-type, proving]

- path: "examples/general-advice-about-when-to-use-prop-and-when-to-use-bool.html"
  title: "General advice about when to use <tt>Prop</tt> and when to use <tt>bool</tt>"
  tags: [decidable, proving, reflection]

- path: "examples/generalising-a-set-of-proofs-in-coq.html"
  title: "Generalising a set of proofs in Coq"
  tags: [tactic]

- path: "examples/generalizing-existential-variables-in-coq.html"
  title: "Generalizing existential variables in Coq"
  tags: [tactic]

- path: "examples/generalizing-expressions-under-binders.html"
  title: "Generalizing expressions under binders"
  tags: [tactic]

- path: "examples/generic-equality-lifting-in-coq.html"
  title: "Generic equality lifting in Coq"
  tags: [tactic]

- path: "examples/heterogeneous-list-in-coq.html"
  title: "Heterogeneous list in Coq"
  tags: [convoy-pattern, indexed-type, nested]

- path: "examples/hint-rewrite-cannot-infer-parameter.html"
  title: "<tt>Hint Rewrite</tt> cannot infer parameter"
  tags: [tactic]

- path: "examples/how-can-i-automate-counting-within-proofs-in-coq.html"
  title: "How can I automate counting within proofs in Coq?"
  tags: [compute, decidable, reflection, tactic]

- path: "examples/how-can-i-avoid-stack-overflow-or-segmentation-fault-in-coq-nats.html"
  title: "How can I avoid stack overflow or segmentation fault in Coq <tt>nat</tt>s?"
  tags: [compute, notation, proving]

- path: "examples/how-can-i-construct-terms-in-first-order-logic-using-coq.html"
  title: "How can I construct terms in first-order logic using Coq?"
  tags: [fixpoint]

- path: "examples/how-can-i-generalise-coq-proofs-of-an-iff.html"
  title: "How can I generalise Coq proofs of an iff?"
  tags: [tactic]

- path: "examples/how-can-i-implement-a-coq-tactic-that-iterates-over-the-hypotheses.html"
  title: "How can I implement a Coq tactic that iterates over the hypotheses?"
  tags: [proving, tactic]

- path: "examples/how-can-i-prove-that-she-cannot-prove-or-commutative-with-only-intro-and-apply.html"
  title: "How can I prove that she cannot prove <tt>Or_commutative</tt> with only intro and apply?"
  tags: [reflection]

- path: "examples/how-can-i-read-coqs-definition-of-proj1-sig.html"
  title: "How can I read Coq's definition of <tt>proj1_sig</tt>?"
  tags: [sigma-type, tactic]

- path: "examples/how-can-i-rewrite-selectively-in-coq.html"
  title: "How can I rewrite selectively in Coq?"
  tags: [tactic]

- path: "examples/how-can-i-use-type-arguments-in-an-ltac.html"
  title: "How can I use type arguments in an ltac?"
  tags: [match, tactic]

- path: "examples/how-can-i-write-a-function-of-the-following-form-in-coq.html"
  title: "How can I write a function of the following form in Coq?"
  tags: [fixpoint]

- path: "examples/how-could-i-make-example-for-sigma-type-in-coq.html"
  title: "How could I make example for sigma type in Coq?"
  tags: [coercion, tactic]

- path: "examples/how-do-i-change-a-concrete-variable-to-an-existentially-quantified-var-in-a-hypo.html"
  title: "How do I change a concrete variable to an existentially quantified var in a hypothesis?"
  tags: [proving, sigma-type, tactic]

- path: "examples/how-do-i-provide-implicit-arguments-explicitly-in-coq.html"
  title: "How do I provide implicit arguments explicitly in Coq?"
  tags: [tactic]

- path: "examples/how-do-we-know-all-coq-constructors-are-injective-and-disjoint.html"
  title: "How do we know all Coq constructors are injective and disjoint?"
  tags: [eq_rect, tactic]

- path: "examples/how-do-you-lookup-the-definition-or-implementation-of-coq-proof-tactics.html"
  title: "How do you lookup the definition or implementation of Coq proof tactics?"
  tags: [match, tactic]

- path: "examples/how-do-you-make-notations-visible-outside-of-a-module-signature-in-coq.html"
  title: "How do you make notations visible outside of a module signature in Coq?"
  tags: [module]

- path: "examples/how-do-you-prove-in-coq-that-e-p-p-eq-refl.html"
  title: "How do you prove in Coq that <tt>(e: p = p) = eq_refl</tt>?"

- path: "examples/how-do-you-selectively-simplify-arguments-to-each-time-a-function-is-called-wit.html"
  title: "How do you selectively simplify arguments to each time a function is called, without evaluating the function itself?"
  tags: [tactic]

- path: "examples/how-does-auto-interract-with-biconditional-iff.html"
  title: "How does <tt>auto</tt> interract with biconditional (iff)"
  tags: [tactic]

- path: "examples/how-does-decidable-equality-works-with-list-remove.html"
  title: "How does decidable equality works with <tt>List.remove</tt>?"
  tags: [compute, decidable, proving, reflection]

- path: "examples/how-does-one-build-the-list-of-only-true-elements-in-coq-using-dependent-types.html"
  title: "How does one build the list of only true elements in Coq using dependent types?"
  tags: [indexed-type, match]

- path: "examples/how-does-one-define-dependent-type-with-named-arguments-in-coq-without-issues-in.html"
  title: "How does one define dependent type with named arguments in Coq without issues in unification in the constructors?"
  tags: [convoy-pattern, indexed-type]

- path: "examples/how-does-one-inspect-what-more-complicated-tactics-do-in-coq-step-by-step.html"
  title: "How does one inspect what more complicated tactics do in Coq step-by-step?"
  tags: [tactic]

- path: "examples/how-proof-assistants-are-implemented.html"
  title: "How proof assistants are implemented?"

- path: "examples/how-proof-functions-prove.html"
  title: "How proof functions prove?"
  tags: [compute]

- path: "examples/how-to-add-assumed-true-statements-in-coq.html"
  title: "How to add \"assumed true\" statements in Coq"
  tags: [tactic]

- path: "examples/how-to-add-to-both-sides-of-an-equality-in-coq.html"
  title: "How to add to both sides of an equality in Coq"
  tags: [proving, tactic]

- path: "examples/how-to-add-variables-introduced-by-set-tactic-to-a-hint-db.html"
  title: "How to add variables introduced by set tactic to a Hint DB?"
  tags: [module]

- path: "examples/how-to-apply-a-function-once-during-simplification-in-coq.html"
  title: "How to apply a function once during simplification in Coq?"
  tags: [proving, tactic]

- path: "examples/how-to-convert-propositional-formula-to-dnf-in-coq.html"
  title: "How to convert propositional formula to DNF in Coq"
  tags: [coercion, fixpoint, nested, reflection]

- path: "examples/how-to-deal-with-really-large-terms-generated-by-program-fixpoint-in-coq.html"
  title: "How to deal with really large terms generated by <tt>Program Fixpoint</tt> in Coq?"
  tags: [fixpoint, module, nested]

- path: "examples/how-to-debug-tactic-failure-in-a-match-goal-branch.html"
  title: "How to debug tactic failure in a match goal branch?"
  tags: [match, tactic]

- path: "examples/how-to-define-an-automatically-unfoldable-definition.html"
  title: "How to define an automatically unfoldable definition"
  tags: [notation, tactic]

- path: "examples/how-to-define-an-inductive-type-and-a-definition-at-the-same-time.html"
  title: "How to define an inductive type and a definition at the same time?"
  tags: [fixpoint, nested]

- path: "examples/how-to-define-axiom-of-a-line-as-two-points-in-coq.html"
  title: "How to define axiom of a line as two points in Coq"
  tags: [tactic]

- path: "examples/how-to-define-set-in-coq-without-defining-set-as-a-list-of-elements.html"
  title: "How to define set in Coq without defining set as a list of elements"
  tags: [compute, decidable, reflection]

- path: "examples/how-to-dependent-match-on-a-list-with-two-elements.html"
  title: "How to dependent match on a list with two elements?"
  tags: [convoy-pattern, indexed-type, nested, synthesis]

- path: "examples/how-to-destruct-pair-equivalence-in-coq.html"
  title: "How to destruct pair equivalence in Coq?"
  tags: [tactic]

- path: "examples/how-to-disable-my-custom-notation-in-coq.html"
  title: "How to disable my custom notation in Coq?"
  tags: [notation]

- path: "examples/how-to-do-cases-with-an-inductive-type-in-coq.html"
  title: "How to do cases with an inductive type in Coq"
  tags: [proving, tactic]

- path: "examples/how-to-do-induction-differently.html"
  title: "How to do induction differently?"
  tags: [fixpoint]

- path: "examples/how-to-do-induction-on-the-length-of-a-list-in-coq.html"
  title: "How to do induction on the length of a list in Coq?"
  tags: [fixpoint, module, view]

- path: "examples/how-to-do-negative-match-in-ltac.html"
  title: "How to do \"negative\" match in Ltac?"
  tags: [tactic]

- path: "examples/how-to-enumerate-set-in-coq-ensemble.html"
  title: "How to enumerate set in Coq <tt>Ensemble</tt>"
  tags: [classical]

- path: "examples/how-to-extract-the-witness-from-exists-in-coq-in-function-notation-without-destr.html"
  title: "How to extract the witness from <tt>exists</tt> in Coq in function notation/without destructing?"
  tags: [classical, compute, proving, reflection, sigma-type]

- path: "examples/how-to-extract-z-from-subset-type-z-z-z-0.html"
  title: "How to \"extract\" <tt>Z</tt> from subset type <tt>{z : Z | z > 0}</tt>"
  tags: [match, sigma-type]

- path: "examples/how-to-forbid-simpl-tactic-to-unfold-arithmetic-expressions.html"
  title: "How to forbid <tt>simpl</tt> tactic to unfold arithmetic expressions?"
  tags: [tactic]

- path: "examples/how-to-get-an-induction-principle-for-nested-fix.html"
  title: "How to get an induction principle for nested <tt>fix</tt>"
  tags: [fixpoint, nested]

- path: "examples/how-to-give-a-counterxample-in-coq.html"
  title: "How to give a counterxample in Coq?"
  tags: [proving]

- path: "examples/how-to-implement-a-union-find-disjoint-set-data-structure-in-coq.html"
  title: "How to implement a union-find (disjoint set) data structure in Coq?"
  tags: [proving, reflection]

- path: "examples/how-to-import-libraries-in-coq.html"
  title: "How to import libraries in Coq?"
  tags: [tactic]

- path: "examples/how-to-import-the-library-coq-arith-peanonat-in-coq.html"
  title: "How to import the library <tt>Coq.Arith.PeanoNat</tt> in Coq?"
  tags: [module]

- path: "examples/how-to-improve-this-proof.html"
  title: "How to improve this proof?"
  tags: [proving, tactic]

- path: "examples/how-to-introduce-a-new-existential-condition-from-a-witness-in-coq.html"
  title: "How to introduce a new existential condition from a witness in Coq?"
  tags: [tactic]

- path: "examples/how-to-introduce-a-new-variable-in-coq.html"
  title: "How to introduce a new variable in Coq?"
  tags: [tactic]

- path: "examples/how-to-leave-a-goal-unfinished-in-coq.html"
  title: "How to leave a goal unfinished in Coq"
  tags: [proving, tactic]

- path: "examples/how-to-leverage-autos-searching-and-hint-databases-in-custom-tactics.html"
  title: "How to leverage <tt>auto</tt>'s searching and hint databases in custom tactics?"
  tags: [tactic]

- path: "examples/how-to-make-algebraic-manipulations-in-coq-easier.html"
  title: "How to make algebraic manipulations in Coq easier?"
  tags: [proving, tactic]

- path: "examples/how-to-make-sublists-in-coq.html"
  title: "How to make sublists in Coq?"
  tags: [compute, fixpoint, view]

- path: "examples/how-to-make-use-of-information-known-about-this-function-type-in-coq.html"
  title: "How to make use of information known about this function type in Coq"
  tags: [convoy-pattern, fixpoint, nested, proving]

- path: "examples/how-to-match-a-match-expression.html"
  title: "How to match a <tt>match</tt> expression?"
  tags: [match, nested]

- path: "examples/how-to-name-the-assumption-when-remembering-an-expression.html"
  title: "How to name the assumption when remembering an expression?"
  tags: [sigma-type, tactic]

- path: "examples/how-to-optimize-a-search-in-coq.html"
  title: "How to optimize a search in Coq"
  tags: [compute, fixpoint]

- path: "examples/how-to-prove-decidability-of-a-partial-order-inductive-predicate.html"
  title: "How to prove decidability of a partial order inductive predicate?"
  tags: [compute, decidable, tactic]

- path: "examples/how-to-prove-equality-from-equality-of-some.html"
  title: "How to prove equality from equality of <tt>Some</tt>"
  tags: [complete, congruence, tactic]

- path: "examples/how-to-prove-false-from-obviously-contradictory-assumptions.html"
  title: "How to prove <tt>False</tt> from obviously contradictory assumptions"
  tags: [congruence, tactic]

- path: "examples/how-to-prove-non-equality-of-terms-produced-by-two-different-constructors-of-the.html"
  title: "How to prove non-equality of terms produced by two different constructors of the same inductive in Coq?"
  tags: [tactic]

- path: "examples/how-to-prove-that-a-number-is-prime-using-znumtheory-in-coq.html"
  title: "How to prove that a number is prime using Znumtheory in Coq"
  tags: [compute, reflection]

- path: "examples/how-to-prove-that-another-definition-of-permutation-is-the-same-as-the-default-p.html"
  title: "How to prove that another definition of permutation is the same as the Default Permutation Library for Coq"
  tags: [fixpoint]

- path: "examples/how-to-prove-that-terms-of-a-first-order-language-are-well-founded.html"
  title: "How to prove that terms of a first-order language are well-founded?"
  tags: [fixpoint, nested, proving]

- path: "examples/how-to-provide-proof-that-two-values-are-different.html"
  title: "How to provide proof that two values are different?"
  tags: [congruence, eq_rect, tactic]

- path: "examples/how-to-repeat-proof-tactics-in-case-in-coq.html"
  title: "How to repeat proof tactics in case in Coq?"
  tags: [proving, tactic]

- path: "examples/how-to-replace-a-term-with-some-property-of-the-term.html"
  title: "How to replace a term with some property of the term?"
  tags: [proving, tactic]

- path: "examples/how-to-return-a-introd-hypothesis-back-to-the-goal-formula.html"
  title: "How to return a (<tt>intro</tt>'d) hypothesis back to the goal formula?"
  tags: [tactic]

- path: "examples/how-to-save-the-current-goal-subgoal-as-an-assert-lemma.html"
  title: "How to save the current goal/subgoal as an <tt>assert</tt> lemma"
  tags: [tactic]

- path: "examples/how-to-set-defaults-for-implicit-arguments-when-they-cant-be-inferred.html"
  title: "How to set defaults for implicit arguments when they can't be inferred?"
  tags: [module, typeclass]

- path: "examples/how-to-solve-contradiction-in-coq.html"
  title: "How to solve contradiction in Coq"
  tags: [tactic]

- path: "examples/how-to-solve-goals-with-invalid-type-equalities-in-coq.html"
  title: "How to solve goals with invalid type equalities in Coq?"
  tags: [universe]

- path: "examples/how-to-specialize-nested-hypotheses-in-coq.html"
  title: "How to specialize nested hypotheses in Coq?"
  tags: [tactic]

- path: "examples/how-to-specify-explicit-equality-in-coq-search-patterns.html"
  title: "How to specify explicit equality in Coq search patterns?"
  tags: [tactic]

- path: "examples/how-to-step-through-semicolons-separated-tactics-sequence-in-coqide.html"
  title: "How to step through semicolons separated tactics sequence in coqide?"
  tags: [tactic]

- path: "examples/how-to-systematically-normalize-inequalities-to-lt-and-le-in-coq.html"
  title: "How to systematically normalize inequalities to <tt><</tt> (<tt>lt</tt>) and <tt><=</tt> (<tt>le</tt>) in Coq?"
  tags: [tactic]

- path: "examples/how-to-turn-an-single-unification-variable-into-a-goal-during-proof.html"
  title: "How to turn an single unification variable into a goal, during proof"
  tags: [tactic]

- path: "examples/how-to-unfold-a-recursive-function-just-once-in-coq.html"
  title: "How to unfold a recursive function just once in Coq"
  tags: [proving, tactic]

- path: "examples/how-to-use-a-custom-induction-principle-in-coq.html"
  title: "How to use a custom induction principle in Coq?"
  tags: [fixpoint, module]

- path: "examples/how-to-use-an-unequality-to-simplify-a-if-then-else-in-coq.html"
  title: "How to use an unequality to simplify a if-then-else in Coq?"
  tags: [decidable, proving]

- path: "examples/how-to-use-auto-with-repeat-in-custom-tactics.html"
  title: "How to use <tt>auto</tt> with <tt>repeat</tt> in custom tactics?"
  tags: [tactic]

- path: "examples/how-to-use-modules-to-hide-lemmas-in-coq.html"
  title: "How to use modules to hide lemmas in Coq?"
  tags: [module]

- path: "examples/how-to-use-rewrite-on-a-subexpression-of-the-current-goal.html"
  title: "How to use <tt>rewrite</tt> on a subexpression of the current goal"
  tags: [eq_rect, indexed-type, tactic]

- path: "examples/how-to-use-the-lemma-inside-a-module-in-coq.html"
  title: "How to use the <tt>Lemma</tt> inside a module in Coq?"
  tags: [module]

- path: "examples/how-to-write-intermediate-proof-statements-inside-coq-similar-to-how-in-isar-o.html"
  title: "How to write intermediate proof statements inside Coq - similar to how in Isar one has <tt>have Statement using Lemma1, Lemma2 by auto</tt> but in Coq?"
  tags: [proving, tactic]

- path: "examples/how-to-write-to-a-file-from-coq.html"
  title: "How to write to a file, from Coq"

- path: "examples/i-need-help-defining-a-concatenation-in-coq.html"
  title: "I need help defining a concatenation in Coq"
  tags: [compute, convoy-pattern, record, reflection, sigma-type]

- path: "examples/idiomatic-ways-of-selecting-subterm-to-rewrite.html"
  title: "Idiomatic ways of selecting subterm to rewrite"
  tags: [proving, tactic]

- path: "examples/implementing-vector-addition-in-coq.html"
  title: "Implementing vector addition in Coq"
  tags: [convoy-pattern, indexed-type, nested]

- path: "examples/import-module-vs-include-module-in-coq-module-system.html"
  title: "<tt>Import <Module></tt> vs. <tt>Include <Module></tt> in Coq Module system"
  tags: [module]

- path: "examples/improving-dependently-typed-reverse-function.html"
  title: "Improving dependently typed reverse function"
  tags: [convoy-pattern, eq_rect, indexed-type]

- path: "examples/in-coq-how-to-construct-an-element-of-sig-type.html"
  title: "In Coq, How to construct an element of 'sig' type"
  tags: [coercion, convoy-pattern, sigma-type, tactic]

- path: "examples/in-coq-how-to-remove-a-defined-variable-from-the-namespace.html"
  title: "In Coq, how to remove a defined variable from the namespace?"
  tags: [tactic]

- path: "examples/in-coq-if-then-else-allows-non-boolean-first-argument.html"
  title: "In Coq, \"if then else\" allows non-boolean first argument?"
  tags: [match]

- path: "examples/in-coq-inversion-of-existential-quantifier-with-multiple-variables-with-one-co.html"
  title: "In Coq: inversion of existential quantifier with multiple variables, with one command?"
  tags: [tactic]

- path: "examples/in-coq-is-there-a-way-to-see-the-tactics-applied-by-tauto.html"
  title: "In Coq, is there a way to see the tactics applied by <tt>tauto</tt>?"
  tags: [proving]

- path: "examples/in-coq-which-tactic-to-change-the-goal-from-s-x-s-y-to-x-y.html"
  title: "In Coq, which tactic to change the goal from <tt>S x = S y</tt> to <tt>x = y</tt>"
  tags: [tactic]

- path: "examples/in-place-simplification-for-coq.html"
  title: "In-place simplification for Coq"
  tags: [tactic]

- path: "examples/in-the-coq-tactics-language-what-is-the-difference-between-intro-and-intros.html"
  title: "In the Coq tactics language, what is the difference between <tt>intro</tt> and <tt>intros</tt>"
  tags: [tactic]

- path: "examples/incorrect-elimination-of-x-in-the-inductive-type-or.html"
  title: "Incorrect elimination of <tt>X</tt> in the inductive type <tt>or</tt>"
  tags: [compute, convoy-pattern, decidable, proof-irrelevance]

- path: "examples/induction-on-predicates-with-product-type-arguments.html"
  title: "Induction on predicates with product type arguments"
  tags: [indexed-type, match, tactic]

- path: "examples/induction-on-record-member-in-coq.html"
  title: "Induction on record member in Coq?"
  tags: [tactic]

- path: "examples/induction-over-relations.html"
  title: "Induction over relations"
  tags: [convoy-pattern, fixpoint, indexed-type, tactic]

- path: "examples/induction-principle-for-le.html"
  title: "Induction principle for <tt>le</tt>"
  tags: [fixpoint, view]

- path: "examples/induction-proofs-on-msets.html"
  title: "Induction proofs on <tt>MSet</tt>s"
  tags: [fixpoint]

- path: "examples/inductive-definition-for-family-of-types.html"
  title: "Inductive definition for family of types"
  tags: [congruence, convoy-pattern, indexed-type, tactic]

- path: "examples/inductive-definition-of-boolean.html"
  title: "Inductive definition of boolean"
  tags: [universe]

- path: "examples/inductively-defined-dense-vector-lemmas.html"
  title: "Inductively defined dense vector lemmas"
  tags: [decidable, indexed-type, proof-irrelevance, sigma-type]

- path: "examples/injectivity-of-inl-and-inr-in-standard-library.html"
  title: "Injectivity of <tt>inl</tt> and <tt>inr</tt> in standard library"
  tags: [tactic]

- path: "examples/inside-a-branch-of-a-match-block-how-do-i-use-the-assertion-that-the-matched-ex.html"
  title: "Inside a branch of a match block, how do I use the assertion that the matched expression is equal to the branch's data constructor expression?"
  tags: [convoy-pattern, match]

- path: "examples/instantiating-an-existential-with-a-specific-proof.html"
  title: "Instantiating an existential with a specific proof"
  tags: [proving, synthesis, tactic]

- path: "examples/interaction-between-type-classes-and-auto-tactic.html"
  title: "Interaction between type classes and auto tactic"
  tags: [notation, tactic, typeclass]

- path: "examples/interactive-theorem-proving-with-no-specified-goal.html"
  title: "Interactive theorem proving with no specified goal"
  tags: [proving]

- path: "examples/inversion-produces-unexpected-existt-in-coq.html"
  title: "Inversion produces unexpected <tt>existT</tt> in Coq"
  tags: [decidable, indexed-type]

- path: "examples/inverting-an-obviously-untrue-hypothesis-does-not-prove-falsehood.html"
  title: "Inverting an obviously untrue hypothesis does not prove falsehood"
  tags: [congruence, tactic]

- path: "examples/is-it-possible-to-declare-type-dependent-notation-in-coq.html"
  title: "Is it possible to declare type-dependent <tt>Notation</tt> in Coq?"
  tags: [notation, typeclass]

- path: "examples/is-it-possible-to-force-induction-tactic-to-produce-more-equations.html"
  title: "Is it possible to force induction tactic to produce more equations?"
  tags: [fixpoint, indexed-type, tactic, view]

- path: "examples/is-there-a-eapply-like-tactic-that-works-on-exists-goals-in-coq.html"
  title: "Is there a <tt>eapply</tt>-like tactic that works on <tt>exists</tt> goals in Coq?"
  tags: [tactic]

- path: "examples/just-a-universally-quantified-hypotesis-in-coq-proof.html"
  title: "Just a universally quantified hypotesis in Coq proof"
  tags: [proving]

- path: "examples/lemma-about-list-and-revlist.html"
  title: "Lemma about <tt>list</tt> and <tt>rev list</tt>"
  tags: [fixpoint]

- path: "examples/lemma-as-a-type-in-a-record.html"
  title: "Lemma as a type in a record"
  tags: [record, reflection]

- path: "examples/less-or-equal-relation-with-largest-element-of-natural-number-list.html"
  title: "Less or equal relation with largest element of natural number list"
  tags: [tactic]

- path: "examples/lift-existentials-in-coq.html"
  title: "Lift existentials in Coq"
  tags: [classical, proof-irrelevance]

- path: "examples/local-inductive-definitions-and-theorems.html"
  title: "Local <tt>Inductive</tt> definitions and <tt>Theorems</tt>"
  tags: [module]

- path: "examples/locating-definition-of-a-tactic-in-coq-proofs.html"
  title: "Locating definition of a tactic in Coq proofs"
  tags: [tactic]

- path: "examples/logic-auxilliry-lemma-for-tr-rev-correct.html"
  title: "Logic: auxilliry lemma for <tt>tr_rev_correct</tt>"
  tags: [fixpoint]

- path: "examples/ltac-optional-arguments-tactic.html"
  title: "Ltac: optional arguments tactic"
  tags: [notation, tactic]

- path: "examples/ltac-pattern-matching-why-does-forall-x-p-x-not-match-forall-x-x.html"
  title: "Ltac pattern matching: why does <tt>forall x, ?P x</tt> not match <tt>forall x, x</tt>?"
  tags: [match, tactic]

- path: "examples/make-subset-types-compatible-for-function-application.html"
  title: "make subset types compatible for function application"
  tags: [coercion, sigma-type]

- path: "examples/matching-expression-context-under-forall-with-ltac.html"
  title: "Matching expression context under <tt>forall</tt> with Ltac"
  tags: [match, tactic]

- path: "examples/matching-with-ltac-on-a-call-containing-local-variable.html"
  title: "Matching with Ltac on a call containing local variable"
  tags: [tactic]

- path: "examples/merge-duplicate-cases-in-match-coq.html"
  title: "Merge duplicate cases in match Coq"
  tags: [proving, view]

- path: "examples/multiple-successes-in-coq-branching-and-backtracking.html"
  title: "Multiple successes in Coq branching and backtracking?"
  tags: [tactic]

- path: "examples/multiple-where-clauses-for-reserved-notation-in-coq.html"
  title: "Multiple <tt>where</tt>-clauses for <tt>Reserved Notation</tt> in Coq?"
  tags: [notation]

- path: "examples/mutual-recursion-on-an-inductive-type-and-nat.html"
  title: "mutual recursion on an inductive type and <tt>nat</tt>"
  tags: [fixpoint, indexed-type, nested]

- path: "examples/nested-recursion-and-program-fixpoint-or-function.html"
  title: "Nested recursion and <tt>Program Fixpoint</tt> or <tt>Function</tt>"
  tags: [fixpoint, proving, tactic]

- path: "examples/non-positive-occurrence-due-to-polymorphic-function.html"
  title: "Non-positive occurrence due to polymorphic function"
  tags: [complete, indexed-type, proof-irrelevance, sigma-type]

- path: "examples/pattern-match-on-type-in-order-to-implement-equality-for-existentially-typed-con.html"
  title: "Pattern-match on type in order to implement equality for existentially typed constructor in Coq"
  tags: [decidable, match, reflection, tactic]

- path: "examples/pattern-matching-using-information-from-theorems.html"
  title: "Pattern matching using information from theorems"
  tags: [convoy-pattern, proving, sigma-type, tactic]

- path: "examples/pattern-matching-with-even-and-odd-cases.html"
  title: "Pattern Matching with Even and Odd Cases"
  tags: [decidable, fixpoint, view]

- path: "examples/pigeonhole-proof-without-decidable-equality-or-excluded-middle.html"
  title: "Pigeonhole proof without decidable equality or excluded middle"
  tags: [classical, decidable, proving, reflection]

- path: "examples/port-a-coq-lemma-over-z-to-a-similar-lemma-over-nat.html"
  title: "Port a Coq lemma over <tt>Z</tt> to a similar lemma over <tt>nat</tt>"
  tags: [proving, reflection]

- path: "examples/pose-proof-in-coq.html"
  title: "Pose proof in Coq"
  tags: [proving, tactic]

- path: "examples/problems-with-dependent-types-in-coq-proof-assistant.html"
  title: "Problems with dependent types in Coq proof assistant"
  tags: [compute, decidable, fixpoint, nested, reflection]

- path: "examples/problems-with-missing-information-in-obligations-when-defining-using-program-in.html"
  title: "Problems with missing information in Obligations when defining using Program in Coq"
  tags: [tactic]

- path: "examples/program-fixpoint-recursive-call-in-let-and-hypothesis-of-the-obligation.html"
  title: "<tt>Program Fixpoint</tt>: recursive call in <tt>let</tt> and hypothesis of the obligation"
  tags: [convoy-pattern, fixpoint]

- path: "examples/proof-automation-in-coq-how-to-factorize-a-proof.html"
  title: "Proof automation in Coq how to factorize a proof"
  tags: [congruence, decidable, proving, reflection, tactic]

- path: "examples/proof-automation.html"
  title: "Proof automation"
  tags: [tactic]

- path: "examples/proof-by-case-analysis-in-coq.html"
  title: "Proof by case analysis in Coq"
  tags: [fixpoint, proving, tactic, view]

- path: "examples/proof-by-contradiction-in-coq.html"
  title: "Proof by contradiction in Coq"
  tags: [classical, decidable]

- path: "examples/proof-leaking-in-coq-extraction.html"
  title: "Proof leaking in Coq extraction?"
  tags: [complete, compute, fixpoint, proof-irrelevance]

- path: "examples/proof-of-the-application-of-a-substitution-on-a-term.html"
  title: "Proof of the application of a substitution on a term"
  tags: [fixpoint, nested]

- path: "examples/proofs-about-constructors-matched-with.html"
  title: "Proofs about constructors matched with <tt>_</tt>"
  tags: [match, synthesis, tactic]

- path: "examples/proofs-of-structural-properties-of-arguments-in-match-in-coq.html"
  title: "Proofs of structural properties of arguments in match in coq"
  tags: [complete, convoy-pattern, sigma-type, synthesis]

- path: "examples/prove-a-constant-is-even.html"
  title: "Prove a constant is even"
  tags: [reflection]

- path: "examples/prove-equality-on-sigma-types.html"
  title: "Prove equality on Sigma-types"
  tags: [compute, proof-irrelevance, sigma-type]

- path: "examples/prove-properties-of-lists.html"
  title: "Prove properties of lists"
  tags: [fixpoint]

- path: "examples/prove-that-the-only-zero-length-vector-is-nil.html"
  title: "Prove that the only zero-length vector is nil"
  tags: [convoy-pattern, decidable, eq_rect, indexed-type, match]

- path: "examples/proving-a-property-on-sets.html"
  title: "Proving a property on sets"
  tags: [classical, proving]

- path: "examples/proving-decidability-for-a-datatype-that-includes-a-vector.html"
  title: "Proving decidability for a datatype that includes a vector"
  tags: [compute, decidable, fixpoint, indexed-type, module]

- path: "examples/proving-equivalence-of-two-programs-expressed-as-different-types.html"
  title: "Proving equivalence of two programs expressed as different types"
  tags: [reflection]

- path: "examples/proving-even-even-even-with-mutual-induction-using-tactics.html"
  title: "Proving <tt>even + even = even</tt> with mutual induction using tactics"
  tags: [fixpoint]

- path: "examples/proving-false-with-negative-inductive-types-in-coq.html"
  title: "Proving <tt>False</tt> with negative inductive types in Coq"
  tags: [congruence, proving]

- path: "examples/proving-forall-x-xs-ys-subseq-x-xs-ys-subseq-xs-ys-in-coq.html"
  title: "Proving <tt>forall x xs ys, subseq (x :: xs) ys -> subseq xs ys</tt> in Coq"
  tags: [tactic]

- path: "examples/proving-increasing-iota-in-coq.html"
  title: "Proving increasing <tt>iota</tt> in Coq"
  tags: [fixpoint]

- path: "examples/proving-termination-in-coq.html"
  title: "Proving termination in Coq"
  tags: [fixpoint, nested]

- path: "examples/proving-termination-of-function-in-coq.html"
  title: "Proving Termination of Function in Coq"
  tags: [fixpoint, nested, sigma-type, view]

- path: "examples/proving-that-s-expressions-printing-is-injective.html"
  title: "Proving that s-expressions printing is injective"
  tags: [fixpoint, nested]

- path: "examples/proving-uniqueness-of-an-instance-of-an-indexed-inductive-type.html"
  title: "Proving uniqueness of an instance of an indexed inductive type"
  tags: [fixpoint, indexed-type, tactic, view]

- path: "examples/question-about-intros-and-intros-h.html"
  title: "Question about intros <tt>[=]</tt> and intros <tt>[= <- H]</tt>"
  tags: [tactic]

- path: "examples/reasoning-about-lists-in-coq.html"
  title: "Reasoning about lists in Coq"
  tags: [fixpoint]

- path: "examples/reasoning-about-typeclass-instance-that-has-been-picked-up-in-a-theorem.html"
  title: "Reasoning about typeclass instance that has been picked up in a theorem?"
  tags: [compute, tactic, typeclass]

- path: "examples/record-and-definition.html"
  title: "<tt>Record</tt> and <tt>Definition</tt>"
  tags: [record, view]

- path: "examples/record-equality-in-coq.html"
  title: "Record equality in Coq"
  tags: [coercion, decidable, proof-irrelevance, reflection]

- path: "examples/recursion-for-church-encoding-of-equality.html"
  title: "Recursion for Church encoding of equality"
  tags: [congruence, eq_rect, fixpoint, universe]

- path: "examples/recursive-partial-functions-in-coq.html"
  title: "Recursive partial functions in Coq"
  tags: [complete, convoy-pattern, fixpoint, match, sigma-type, tactic]

- path: "examples/recursive-use-of-typeclass-methods-in-coq.html"
  title: "Recursive use of typeclass methods in Coq"
  tags: [fixpoint, record, typeclass]

- path: "examples/redundant-clause-in-match.html"
  title: "Redundant clause in <tt>match</tt>"
  tags: [match]

- path: "examples/relation-between-types-prod-and-sig-in-coq.html"
  title: "Relation between types <tt>prod</tt> and <tt>sig</tt> in Coq"
  tags: [sigma-type]

- path: "examples/removing-the-last-element-of-a-sized-list-in-coq.html"
  title: "Removing the last element of a sized list in Coq"
  tags: [convoy-pattern, fixpoint, indexed-type]

- path: "examples/removing-trivial-match-clause-in-coq.html"
  title: "Removing trivial match clause in Coq"
  tags: [congruence, eq_rect]

- path: "examples/renaming-part-of-hypothesis-in-coq.html"
  title: "Renaming part of hypothesis in Coq"
  tags: [convoy-pattern, fixpoint]

- path: "examples/representing-higher-order-functors-as-containers-in-coq.html"
  title: "Representing Higher-Order Functors as Containers in Coq"
  tags: [indexed-type]

- path: "examples/require-import-require-import.html"
  title: "<tt>Require</tt>, <tt>Import</tt>, <tt>Require Import</tt>"
  tags: [module]

- path: "examples/retrieving-constraints-from-gadt-to-ensure-exhaustion-of-pattern-matching-in-coq.html"
  title: "Retrieving constraints from GADT to ensure exhaustion of pattern matching in Coq"
  tags: [convoy-pattern, eq_rect, indexed-type, match]

- path: "examples/returning-a-record-from-a-definition-in-coq.html"
  title: "Returning a record from a definition in Coq"
  tags: [record]

- path: "examples/rewrite-single-occurence-in-ltac.html"
  title: "Rewrite single occurence in Ltac"
  tags: [compute, tactic]

- path: "examples/rewrite-under-exists.html"
  title: "Rewrite under <tt>exists</tt>"
  tags: [tactic]

- path: "examples/rewrite-works-for-but-not-for-iff-in-coq.html"
  title: "<tt>rewrite</tt> works for <tt>=</tt> but not for <tt><-></tt> (<tt>iff</tt>) in Coq"
  tags: [compute, tactic]

- path: "examples/rewriting-hypothesis-to-false-with-a-contradictory-theorem.html"
  title: "Rewriting hypothesis to false with a contradictory theorem"
  tags: [proving]

- path: "examples/section-mechanism-in-coq-forbid-omitting-of-hypotheses-from-context.html"
  title: "Section mechanism in Coq. Forbid omitting of hypotheses from context"
  tags: [module]

- path: "examples/sf-volume-1-logic-how-to-prove-tr-rev-rev.html"
  title: "SF Volume 1: Logic: How to prove <tt>tr_rev <-> rev</tt>?"
  tags: [fixpoint]

- path: "examples/shorter-notation-for-matching-hypotheses-in-coq.html"
  title: "Shorter notation for matching hypotheses in Coq?"
  tags: [match, tactic]

- path: "examples/show-all-axioms-coq.html"
  title: "Show all axioms Coq"
  tags: [tactic]

- path: "examples/show-theorem-definition-in-coq.html"
  title: "Show theorem definition in Coq"
  tags: [proving, tactic]

- path: "examples/some-help-dealing-with-inject-unject-and-vector-types.html"
  title: "Some help dealing with inject/unject and vector types"
  tags: [compute, convoy-pattern, fixpoint, proving, tactic]

- path: "examples/specialization-of-module-argument-in-coq.html"
  title: "Specialization of module argument in Coq"
  tags: [compute, module]

- path: "examples/split-conjunction-goal-into-subgoals.html"
  title: "Split conjunction goal into subgoals"
  tags: [tactic]

- path: "examples/step-by-step-simplification-in-coq.html"
  title: "Step by step simplification in Coq?"
  tags: [tactic]

- path: "examples/stronger-completeness-axiom-for-real-numbers-in-coq.html"
  title: "Stronger completeness axiom for real numbers in Coq"
  tags: [classical, decidable]

- path: "examples/structural-recursion-on-two-arguments.html"
  title: "Structural recursion on two arguments"
  tags: [compute, fixpoint]

- path: "examples/stuck-on-a-simple-proof-about-regular-expressions.html"
  title: "Stuck on a simple proof about regular expressions"
  tags: [convoy-pattern, fixpoint, module, proving, tactic]

- path: "examples/stuck-on-the-proof-of-a-simple-lemma-which-induction-should-i-use.html"
  title: "Stuck on the proof of a simple Lemma: which induction should I use?"
  tags: [fixpoint, proving, tactic]

- path: "examples/subset-parameter.html"
  title: "Subset parameter"
  tags: [coercion, sigma-type]

- path: "examples/subtyping-in-coq.html"
  title: "Subtyping in Coq"
  tags: [proof-irrelevance, tactic]

- path: "examples/syntax-error-with-in-coq-notations.html"
  title: "Syntax error with <tt><</tt> in Coq notations"
  tags: [notation]

- path: "examples/tactic-automation-simple-decision-procedure.html"
  title: "Tactic automation: simple decision procedure"
  tags: [compute, decidable, tactic, typeclass]

- path: "examples/teach-coq-to-check-termination.html"
  title: "Teach Coq to check termination"
  tags: [fixpoint, nested]

- path: "examples/transfering-proof-from-z-to-n-in-coq.html"
  title: "Transfering proof from Z to N in Coq"
  tags: [tactic]

- path: "examples/transform-casual-list-into-dependently-typed-list-in-coq.html"
  title: "Transform casual list into dependently typed list in Coq"
  tags: [compute, match]

- path: "examples/transitivity-of-in-coq.html"
  title: "Transitivity of <tt>-></tt> in Coq"
  tags: [proving, reflection]

- path: "examples/transitivity-of-subsequence-in-coq.html"
  title: "Transitivity of subsequence in Coq"
  tags: [fixpoint]

- path: "examples/trouble-writing-my-notation-for-natural-numbers-in-coq.html"
  title: "Trouble writing my notation for natural numbers in Coq"
  tags: [notation]

- path: "examples/turn-off-automatic-induction-principle-in-coq.html"
  title: "Turn off automatic induction principle in Coq"
  tags: [fixpoint]

- path: "examples/type-encapsulation-in-coq.html"
  title: "Type encapsulation in Coq"
  tags: [module, record]

- path: "examples/typeclass-resolution-and-autorewrite.html"
  title: "Typeclass resolution and autorewrite"
  tags: [tactic, typeclass]

- path: "examples/typeclasses-with-multiple-fields-vs-single-field-in-coq-unexpected-behaviour.html"
  title: "Typeclasses with multiple fields vs. single field in Coq / Unexpected behaviour of Compute command"
  tags: [compute]

- path: "examples/unable-to-find-an-instance-for-the-variable.html"
  title: "Unable to find an instance for the variable"
  tags: [tactic]

- path: "examples/under-what-conditions-does-eval-cbv-delta-in-expand-a-definition-in-coq.html"
  title: "Under what conditions does <tt>Eval cbv delta in</tt> expand a definition in Coq?"
  tags: [compute, tactic]

- path: "examples/understanding-how-pattern-matching-works-in-coq.html"
  title: "Understanding how pattern matching works in Coq"
  tags: [compute, match]

- path: "examples/understanding-specialize-tactic.html"
  title: "Understanding specialize tactic"
  tags: [indexed-type, tactic]

- path: "examples/understanding-the-intros-keyword-work-in-coq.html"
  title: "Understanding the <tt>intros</tt> keyword work in Coq"
  tags: [indexed-type, tactic]

- path: "examples/understanding-well-founded-proofs-in-coq.html"
  title: "Understanding \"well founded\" proofs in Coq"
  tags: [fixpoint]

- path: "examples/unfold-a-notation-within-a-scope.html"
  title: "Unfold a notation within a scope"
  tags: [notation, tactic]

- path: "examples/unfold-notation-in-ltac.html"
  title: "Unfold notation in ltac"
  tags: [notation, tactic]

- path: "examples/use-module-signature-definition-in-module-implementation.html"
  title: "Use module signature definition in module implementation"
  tags: [module]

- path: "examples/using-an-existential-theorem-in-coq.html"
  title: "Using an existential theorem in Coq"
  tags: [tactic]

- path: "examples/using-dependent-induction-tactic-to-keep-information-while-doing-induction.html"
  title: "Using <tt>dependent induction</tt> tactic to keep information while doing induction"
  tags: [convoy-pattern, tactic]

- path: "examples/using-dependent-types-in-coq-safe-nth-function.html"
  title: "Using dependent types in Coq (safe <tt>nth</tt> function)"
  tags: [complete, convoy-pattern, decidable, indexed-type, proving, reflection, sigma-type]

- path: "examples/using-implicit-type-class-parameters-in-coq-notation.html"
  title: "Using Implicit Type Class Parameters in Coq Notation"
  tags: [module, nested, notation]

- path: "examples/using-induction-starting-from-1-in-coq.html"
  title: "Using induction starting from 1 in Coq"
  tags: [complete, fixpoint]

- path: "examples/using-length-of-list-x-as-an-argument-for-a-constructor-of-x-in-coq.html"
  title: "Using length of list <tt>X</tt> as an argument for a constructor of <tt>X</tt> in Coq"
  tags: [fixpoint, indexed-type, nested, view]

- path: "examples/using-local-notation-inside-a-coq-theorem.html"
  title: "Using local notation inside a Coq theorem"
  tags: [module, tactic]

- path: "examples/using-omega-to-prove-a-lemma-in-coq.html"
  title: "Using <tt>Omega</tt> to prove a lemma in Coq"
  tags: [fixpoint]

- path: "examples/using-typeclass-instances-within-typeclasses.html"
  title: "Using typeclass instances within typeclasses"
  tags: [fixpoint, nested, typeclass]

- path: "examples/vector-error-the-type-of-this-term-is-a-product.html"
  title: "Vector error: The type of this term is a product"
  tags: [convoy-pattern, fixpoint, indexed-type, nested, proving]

- path: "examples/vector-t-a-n-t-a-n0.html"
  title: "Vector : <tt>t A n = t A (n+0)</tt>?"
  tags: [tactic]

- path: "examples/verbose-auto-in-coq.html"
  title: "\"Verbose\" <tt>auto</tt> in Coq"
  tags: [tactic]

- path: "examples/wellfounded-induction-in-coq.html"
  title: "Wellfounded induction in Coq"
  tags: [complete, convoy-pattern, fixpoint, proving, tactic, view]

- path: "examples/what-does-it-mean-when-coq-expands-a-function-as-part-of-the-goal.html"
  title: "What does it mean when Coq expands a function as part of the goal?"
  tags: [fixpoint, tactic]

- path: "examples/what-does-proof-simpl-reflexivity-qed-mean-in-coq.html"
  title: "What does <tt>Proof. simpl. reflexivity. Qed.</tt> mean in Coq?"
  tags: [tactic]

- path: "examples/what-does-the-tactic-destruct-do-in-the-proof-below.html"
  title: "What does the tactic <tt>destruct</tt> do in the proof below?"
  tags: [tactic]

- path: "examples/what-does-the-tactic-induction-followed-by-a-number-do.html"
  title: "What does the tactic <tt>induction</tt> followed by a number do?"
  tags: [tactic]

- path: "examples/what-is-a-concrete-example-of-the-type-set-and-what-is-the-meaning-of-set.html"
  title: "What is a concrete example of the type <tt>Set</tt> and what is the meaning of <tt>Set</tt>?"
  tags: [classical, universe]

- path: "examples/what-is-coqs-type-system-doing-in-this-example.html"
  title: "What is Coq's type system doing in this example?"
  tags: [eq_rect, indexed-type, match]

- path: "examples/what-is-difference-between-destruct-and-case-eq-tactics-in-coq.html"
  title: "What is difference between <tt>destruct</tt> and <tt>case_eq</tt> tactics in Coq?"
  tags: [tactic]

- path: "examples/what-is-eq-rect-and-where-is-it-defined-in-coq.html"
  title: "What is <tt>eq_rect</tt> and where is it defined in Coq?"
  tags: [eq_rect, fixpoint]

- path: "examples/what-is-in-coq.html"
  title: "What <tt><></tt> is in Coq"
  tags: [tactic]

- path: "examples/what-is-the-difference-between-axiom-and-variable-in-coq.html"
  title: "What is the difference between <tt>Axiom</tt> and <tt>Variable</tt> in Coq"
  tags: [tactic]

- path: "examples/what-is-the-difference-between-lemma-and-theorem-in-coq.html"
  title: "What is the difference between <tt>Lemma</tt> and <tt>Theorem</tt> in Coq"
  tags: [proving, tactic]

- path: "examples/what-is-the-tactic-that-does-nothing.html"
  title: "What is the tactic that does nothing?"
  tags: [tactic]

- path: "examples/what-should-be-done-when-simpl-does-not-reduce-all-the-necessary-steps.html"
  title: "What should be done when <tt>simpl</tt> does not reduce all the necessary steps?"
  tags: [tactic]

- path: "examples/whats-the-difference-between-program-fixpoint-and-function-in-coq.html"
  title: "What's the difference between <tt>Program Fixpoint</tt> and <tt>Function</tt> in Coq?"
  tags: [fixpoint, nested, tactic]

- path: "examples/whats-the-difference-between-revert-and-generalize-tactics-in-coq.html"
  title: "What's the difference between <tt>revert</tt> and <tt>generalize</tt> tactics in Coq?"
  tags: [tactic]

- path: "examples/when-are-the-constructors-of-an-inductive-type-exhaustive.html"
  title: "When are the constructors of an inductive type exhaustive?"
  tags: [decidable, eq_rect, indexed-type]

- path: "examples/where-did-lt-index-go.html"
  title: "Where did <tt>lt_index</tt> go?"
  tags: [tactic]

- path: "examples/which-vector-library-to-use-in-coq.html"
  title: "Which vector library to use in Coq?"
  tags: [coercion, fixpoint, sigma-type]

- path: "examples/why-are-logical-connectives-and-booleans-separate-in-coq.html"
  title: "Why are logical connectives and booleans separate in Coq?"
  tags: [classical, compute]

- path: "examples/why-can-i-not-apply-f-equal-to-a-hypothesis.html"
  title: "Why can I not apply <tt>f_equal</tt> to a hypothesis?"
  tags: [congruence, tactic]

- path: "examples/why-can-i-use-the-constructor-tactic-to-prove-reflexivity.html"
  title: "Why can I use the constructor tactic to prove reflexivity?"
  tags: [tactic]

- path: "examples/why-cant-coq-infer-the-that-0n-n-in-this-dependently-typed-program.html"
  title: "Why can't Coq infer the that <tt>0 + n = n</tt> in this dependently typed program?"
  tags: [indexed-type, match, proof-irrelevance, sigma-type]

- path: "examples/why-cant-i-define-the-following-cofixpoint.html"
  title: "Why can't I define the following <tt>CoFixpoint</tt>?"
  tags: [tactic]

- path: "examples/why-coq-doesnt-allow-inversion-destruct-etc-when-the-goal-is-a-type.html"
  title: "Why Coq doesn't allow inversion, destruct, etc. when the goal is a <tt>Type</tt>?"
  tags: [compute, convoy-pattern, proof-irrelevance, tactic]

- path: "examples/why-do-calculus-of-construction-based-languages-use-setoids-so-much.html"
  title: "Why do Calculus of Construction based languages use Setoids so much?"
  tags: [eq_rect]

- path: "examples/why-does-coq-init-logic-define-the-notation-a-b.html"
  title: "Why does <tt>Coq.Init.Logic</tt> define the notation <tt>A -> B</tt>?"
  tags: [notation, tactic]

- path: "examples/why-does-coqs-typechecker-reject-my-map-definition.html"
  title: "Why does Coq's typechecker reject my map definition?"
  tags: [convoy-pattern, fixpoint, indexed-type, match]

- path: "examples/why-does-nesting-the-induction-tactic-also-nest-the-inductive-hypotheses-under-a.html"
  title: "Why does nesting the induction tactic also nest the inductive hypotheses under a lambda?"
  tags: [fixpoint, proving]

- path: "examples/why-does-this-coq-definition-fail-coq-namespace-error-for-inductive-type.html"
  title: "Why does this Coq <tt>Definition</tt> fail? Coq Namespace error for Inductive Type"
  tags: [match, reflection]

- path: "examples/why-does-use-of-coqs-setoid-replace-by-clause-need-an-extra-idtac.html"
  title: "Why does use of Coq's <tt>setoid_replace ... by</tt> clause need an extra <tt>idtac</tt>?"
  tags: [match, tactic]

- path: "examples/why-havent-newer-dependently-typed-languages-adopted-ssreflects-approach.html"
  title: "Why haven't newer dependently typed languages adopted SSReflect's approach?"
  tags: [decidable, indexed-type, proof-irrelevance, record, reflection, typeclass]

- path: "examples/why-is-following-coq-rewrite-not-applying-on-right-hand-side-of-assumption.html"
  title: "Why is following Coq rewrite not applying on right hand side of assumption?"
  tags: [tactic]

- path: "examples/why-is-my-recursive-definition-of-list-min-ill-formed.html"
  title: "Why is my recursive definition of <tt>list_min</tt> ill-formed?"
  tags: [fixpoint, match, nested, proving]

- path: "examples/why-not-have-prop-set-in-coq.html"
  title: "Why not have <tt>Prop : Set</tt> in Coq?"
  tags: [classical, convoy-pattern, proof-irrelevance, universe]

- path: "examples/why-s-n-s-n-simplifies-to-n-n-in-coq.html"
  title: "Why <tt>S n' =? S n'</tt> simplifies to <tt>n' =? n'</tt> in Coq?"
  tags: [tactic]

- path: "examples/why-would-the-tactic-exact-be-complete-for-coq-proofs.html"
  title: "Why would the tactic <tt>exact</tt> be complete for Coq proofs?"
  tags: [tactic]
