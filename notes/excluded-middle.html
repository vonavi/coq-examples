<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>Proof based on the excluded-middle law</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="proof-based-on-the-excluded-middle-law">
<h1 class="title">Proof based on the excluded-middle law</h1>

<p>In <a class="reference external" href="https://en.wikipedia.org/wiki/Intuitionistic_logic">constructive logic</a>, two lemmas
looking almost the same can have rather different complexity to prove
them. Let us give such an example:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk0"><span class="kn">Lemma</span> <span class="nf">forall_not_exists</span> : <span class="kr">forall</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>),
    (<span class="kr">forall</span> <span class="nv">x</span>, P x) -&gt; ~ (<span class="kr">exists</span> <span class="nv">x</span>, ~ P x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>),
(<span class="kr">forall</span> <span class="nv">x</span> : T, P x) -&gt; ~ (<span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>),
(<span class="kr">forall</span> <span class="nv">x</span> : T, P x) -&gt; ~ (<span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk2"><span class="nb">intros</span> T P H [x H0].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>T -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : T, P x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>~ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H0, (H x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>The proof is really not hard; Coq can even solve it automatically:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reset</span> <span class="nf">forall_not_exists</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk3"><span class="kn">Lemma</span> <span class="nf">forall_not_exists</span> : <span class="kr">forall</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>),
    (<span class="kr">forall</span> <span class="nv">x</span>, P x) -&gt; ~ (<span class="kr">exists</span> <span class="nv">x</span>, ~ P x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>),
(<span class="kr">forall</span> <span class="nv">x</span> : T, P x) -&gt; ~ (<span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>),
(<span class="kr">forall</span> <span class="nv">x</span> : T, P x) -&gt; ~ (<span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">firstorder</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>So, we may hope to get such a simple proof for a little-bit
reformulated lemma:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk5"><span class="kn">Lemma</span> <span class="nf">not_forall_exists</span> : <span class="kr">forall</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>),
    ~ (<span class="kr">forall</span> <span class="nv">x</span>, P x) -&gt; (<span class="kr">exists</span> <span class="nv">x</span>, ~ P x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>),
~ (<span class="kr">forall</span> <span class="nv">x</span> : T, P x) -&gt; <span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>),
~ (<span class="kr">forall</span> <span class="nv">x</span> : T, P x) -&gt; <span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk7"><span class="nb">firstorder</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>T -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>~ (<span class="kr">forall</span> <span class="nv">x</span> : T, P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="excluded-middle-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="excluded-middle-v-chk8"><span class="kn">Qed</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(<span class="kr">in</span> proof not_forall_exists): Attempt to save an incomplete proof</blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>Why are we unable to proof? The point is that, due to <a class="reference external" href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry–Howard
correspondence</a>,
deriving a proof in constructive logic is equivalent to computing
lambda terms. As well-known, the power of <a class="reference external" href="https://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a> is the same as that
of <a class="reference external" href="https://en.wikipedia.org/wiki/Turing_machine">Turing machine</a>.
As a result, not every proposition <tt class="docutils literal">P x</tt> returns true or false,
sometimes it may does not halt. After taking a look at this lemma
again, we see that we are also trying to prove that <tt class="docutils literal">P x</tt> return the
result for some <tt class="docutils literal">x</tt>. In contrast, the previous lemma
<tt class="docutils literal">forall_not_exists</tt> includes the statement of <tt class="docutils literal">P x</tt> halting as a
hypothesis.</p>
<p>In other words, <a class="reference external" href="https://en.wikipedia.org/wiki/Law_of_excluded_middle">the excluded-middle law</a> (<tt class="docutils literal">P x \/ ~
P x</tt>) is not always valid in constructive logic; but is not in
contradiction with it. In fact, this law is provided by module
<tt class="docutils literal">Coq.Logic.Classical</tt>, and is usually used in two equivalent forms:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="excluded-middle-v-chk9" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">classic
     : <span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, P \/ ~ P</blockquote></div></div></small></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="excluded-middle-v-chka" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">NNPP
     : <span class="kr">forall</span> <span class="nv">p</span> : <span class="kt">Prop</span>, ~ ~ p -&gt; p</blockquote></div></div></small></span></pre><p>Taking a look again at lemma <tt class="docutils literal">not_forall_exists</tt>, one sees that its
statement has the form of <tt class="docutils literal">~ P <span class="pre">-&gt;</span> Q</tt>. There is a useful trick in
order to deal with such goals called <a class="reference external" href="https://en.wikipedia.org/wiki/Proof_by_contradiction">proof by contradiction</a>. It is based
on the excluded-middle law, and we will proof it in two different
ways.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Logic.Classical.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chkb"><span class="kn">Lemma</span> <span class="nf">assume_opposite</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, (~ P -&gt; Q) -&gt; (~ Q -&gt; P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, (~ P -&gt; Q) -&gt; ~ Q -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chkc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, (~ P -&gt; Q) -&gt; ~ Q -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chkd"><span class="nb">intros</span> P Q H H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>~ P -&gt; Q</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>~ Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chke"><span class="nb">apply</span> NNPP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>~ P -&gt; Q</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>~ Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ ~ P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chkf"><span class="nb">intro</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>~ P -&gt; Q</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>~ Q</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>~ P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H0, (H H1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reset</span> <span class="nf">assume_opposite</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk10"><span class="kn">Lemma</span> <span class="nf">assume_opposite</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, (~ P -&gt; Q) -&gt; (~ Q -&gt; P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, (~ P -&gt; Q) -&gt; ~ Q -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, (~ P -&gt; Q) -&gt; ~ Q -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk12"><span class="nb">intros</span> P Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(~ P -&gt; Q) -&gt; ~ Q -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk13"><span class="nb">case</span> (classic P); <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ P -&gt; (~ P -&gt; Q) -&gt; ~ Q -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk14"><span class="nb">intros</span> H H0 H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>~ P</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>~ P -&gt; Q</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>~ Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk15"><span class="nb">exfalso</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>~ P</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>~ P -&gt; Q</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>~ Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H1, (H0 H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>It should be noticed that lemma <tt class="docutils literal">assume_opposite</tt> changes the order
of computation (the result <tt class="docutils literal">Q</tt> now precedes the assumption <tt class="docutils literal">P</tt>),
which is prohibited in a real computation. However, it does not relate
to propositions (<tt class="docutils literal">Prop</tt>) which are excluded from computation in Coq.
The reason is to keep the ability to add the excluded-middle law for
<tt class="docutils literal">Prop</tt>.</p>
<p>So, let us &quot;change the order of computation&quot; at lemma
<tt class="docutils literal">not_forall_exists</tt>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk16"><span class="kn">Lemma</span> <span class="nf">not_forall_exists</span> : <span class="kr">forall</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>),
    ~ (<span class="kr">forall</span> <span class="nv">x</span>, P x) -&gt; (<span class="kr">exists</span> <span class="nv">x</span>, ~ P x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>),
~ (<span class="kr">forall</span> <span class="nv">x</span> : T, P x) -&gt; <span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk17"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>),
~ (<span class="kr">forall</span> <span class="nv">x</span> : T, P x) -&gt; <span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk18"><span class="nb">intros</span> T P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>T -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (<span class="kr">forall</span> <span class="nv">x</span> : T, P x) -&gt; <span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk19"><span class="nb">apply</span> assume_opposite.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>T -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (<span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x) -&gt; <span class="kr">forall</span> <span class="nv">x</span> : T, P x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk1a"><span class="nb">intros</span> H x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>T -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>~ (<span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x</div></blockquote></div></div></small></span></pre><p>As a result, we get value <tt class="docutils literal">x</tt>---a candidate for <tt class="docutils literal">exists x, ~ P
x</tt>---impossible in the direct computation:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk1b"><span class="nb">assert</span> (~ ~ P x) <span class="bp">by</span> (<span class="nb">intro</span> H0; <span class="nb">apply</span> H; <span class="bp">now</span> <span class="kr">exists</span> <span class="nv">x</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>T -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>~ (<span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>~ ~ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x</div></blockquote></div></div></small></span></pre><p>We will transform the goal to suit lemma <tt class="docutils literal">assume_opposite</tt>, in order
to demonstrate the generality of the lemma. Then, its application will
finish the proof:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="excluded-middle-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="excluded-middle-v-chk1c"><span class="nb">revert</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>T -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>~ (<span class="kr">exists</span> <span class="nv">x</span> : T, ~ P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ ~ P x -&gt; P x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> assume_opposite.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><hr class="docutils" />
<p>Below are appropriate examples found on <a class="reference external" href="https://stackoverflow.com/">Stack Overflow</a>:</p>
<ol class="arabic simple">
<li><a class="reference external" href="../examples/can-any-one-help-me-how-to-prove-this-therom-in-coq.html">../examples/can-any-one-help-me-how-to-prove-this-therom-in-coq.html</a></li>
<li><a class="reference external" href="../examples/how-to-enumerate-set-in-coq-ensemble.html">../examples/how-to-enumerate-set-in-coq-ensemble.html</a></li>
<li><a class="reference external" href="../examples/proving-a-property-on-sets.html">../examples/proving-a-property-on-sets.html</a></li>
</ol>
</div>
</div></body>
</html>
